(* Copyright (c) 2006-2015, Benjamin 'BeRo' Rosseaux (benjamin@rosseaux.de)
 * Licensed under the terms of the LGPL V3 or later, see LGPLv3.txt or
 * http://www.gnu.org/licenses/lgpl.html for details
 *)
unit Synth;
{$undef rtl}
{$ifdef FPC}
 {$mode delphi}
 {$ifdef cpui386}
  {$define cpu386}
 {$endif}
 {$ifdef cpu386}
  {$asmmode intel}
 {$endif}
{$else}
 {$ifdef win32}
  {$define delphiwin32}
  {$define rtl}
 {$endif}
{$endif}
{$ifdef cpu386}
 {$define Use64Bit}
{$endif}
{$ifdef win32}
 {$ifndef VSTi}
  {$define WIN32Plain}
 {$endif}
{$endif}
{$R-}
{$extendedsyntax on}
{$writeableconst on}
{$varstringchecks on}
{$typedaddress off}
{$overflowchecks off}
{$rangechecks off}
{$ifndef fpc}
 {$realcompatibility off}
{$endif}
{$openstrings on}
{$longstrings on}
{$booleval off}
{$define UseFixDenormalValue}
{$ifndef ver130}
 {$ifdef cpu386}
  {$define UseSSE}
 {$endif}
{$endif}

{$define BR808ADSR}
{$define BR808LFO}
{$define BR808VOICEFILTER}
{$define BR808VOICEDISTORTION}
{$define BR808CHANNELDISTORTION}
{$define BR808CHANNELFILTER}
{$define BR808FILTER}
{$define BR808FORMANTFILTER}
{$define BR808OVERRIDEFILTER}
{$define BR808MOOGFILTER}
{$define BR808DELAY}
{$define BR808CHORUSFLANGER}
{$define BR808COMPRESSOR}
{$define BR808PITCHSHIFTER}
{$define BR808EQ}
{$define BR808REVERB}
{$define BR808ENDFILTER}
{$define BR808ENVELOPES}
{$define BR808SAMPLES}
{$define BR808SPEECH}
{$define BR808SMF}

{$ifdef BR808EXEMUSPLAYER}
 {$undef BR808SMF}
{$endif}

{$ifdef BR808SYNTHCONFIG}
 {$I synthconfig.inc}
{$endif}

interface

{$ifdef vsti}
{$undef UseOwnMath}
{$else}
{$define UseOwnMath}
{$endif}

{$ifdef csdk}
const
      MAXPNAMELEN      =  32;    { max product name length (including nil) }
      MAXERRORLENGTH   = 128;    { max error text length (including nil) }
      MAX_JOYSTICKOEMVXDNAME = 260; { max oem vxd name length (including nil) }

      WAVE_FORMAT_PCM     = 1;

type dword=longword;
     uint=dword;

  VERSION = UINT;               { major (high byte), minor (low byte) }
  MMVERSION = UINT;             { major (high byte), minor (low byte) }
  MMRESULT = UINT;              { error return code, 0 means no error }

  PWaveHdr = ^wavehdr_tag;
  wavehdr_tag = packed record
    lpData: PChar;              { pointer to locked data buffer }
    dwBufferLength: DWORD;      { length of data buffer }
    dwBytesRecorded: DWORD;     { used for input only }
    dwUser: DWORD;              { for client's use }
    dwFlags: DWORD;             { assorted flags (see defines) }
    dwLoops: DWORD;             { loop control counter }
    lpNext: PWaveHdr;           { reserved for driver }
    reserved: DWORD;            { reserved for driver }
  end;
//TWaveHdr = wavehdr_tag;
  WAVEHDR = wavehdr_tag;

const
  TIME_MS         = $0001;  { time in milliseconds }
  TIME_SAMPLES    = $0002;  { number of wave samples }
  TIME_BYTES      = $0004;  { current byte offset }
  TIME_SMPTE      = $0008;  { SMPTE time }
  TIME_MIDI       = $0010;  { MIDI time }
  TIME_TICKS      = $0020;  { Ticks within MIDI stream }

  WAVE_MAPPER     = UINT(-1);

  MMSYSERR_BASE          = 0;
  WAVERR_BASE            = 32;

  WAVERR_BADFORMAT      = WAVERR_BASE + 0;    { unsupported wave format }
  WAVERR_STILLPLAYING   = WAVERR_BASE + 1;    { still something playing }
  WAVERR_UNPREPARED     = WAVERR_BASE + 2;    { header not prepared }
  WAVERR_SYNC           = WAVERR_BASE + 3;    { device is synchronous }
  WAVERR_LASTERROR      = WAVERR_BASE + 3;    { last error in range }

  MMSYSERR_NOERROR      = 0;                  { no error }
  MMSYSERR_ERROR        = MMSYSERR_BASE + 1;  { unspecified error }
  MMSYSERR_BADDEVICEID  = MMSYSERR_BASE + 2;  { device ID out of range }
  MMSYSERR_NOTENABLED   = MMSYSERR_BASE + 3;  { driver failed enable }
  MMSYSERR_ALLOCATED    = MMSYSERR_BASE + 4;  { device already allocated }
  MMSYSERR_INVALHANDLE  = MMSYSERR_BASE + 5;  { device handle is invalid }
  MMSYSERR_NODRIVER     = MMSYSERR_BASE + 6;  { no device driver present }
  MMSYSERR_NOMEM        = MMSYSERR_BASE + 7;  { memory allocation error }
  MMSYSERR_NOTSUPPORTED = MMSYSERR_BASE + 8;  { function isn't supported }
  MMSYSERR_BADERRNUM    = MMSYSERR_BASE + 9;  { error value out of range }
  MMSYSERR_INVALFLAG    = MMSYSERR_BASE + 10; { invalid flag passed }
  MMSYSERR_INVALPARAM   = MMSYSERR_BASE + 11; { invalid parameter passed }
  MMSYSERR_HANDLEBUSY   = MMSYSERR_BASE + 12; { handle being used
                                                simultaneously on another
                                                thread (eg callback) }
  MMSYSERR_INVALIDALIAS = MMSYSERR_BASE + 13; { specified alias not found }
  MMSYSERR_BADDB        = MMSYSERR_BASE + 14; { bad registry database }
  MMSYSERR_KEYNOTFOUND  = MMSYSERR_BASE + 15; { registry key not found }
  MMSYSERR_READERROR    = MMSYSERR_BASE + 16; { registry read error }
  MMSYSERR_WRITEERROR   = MMSYSERR_BASE + 17; { registry write error }
  MMSYSERR_DELETEERROR  = MMSYSERR_BASE + 18; { registry delete error }
  MMSYSERR_VALNOTFOUND  = MMSYSERR_BASE + 19; { registry value not found }
  MMSYSERR_NODRIVERCB   = MMSYSERR_BASE + 20; { driver does not call DriverCallback }
  MMSYSERR_LASTERROR    = MMSYSERR_BASE + 20; { last error in range }

type
  PMMTime = ^mmtime_tag;
  mmtime_tag = packed record
    case wType: UINT of        { indicates the contents of the variant record }
     TIME_MS:      (ms: DWORD);
     TIME_SAMPLES: (sample: DWORD);
     TIME_BYTES:   (cb: DWORD);
     TIME_TICKS:   (ticks: DWORD);
     TIME_SMPTE: (
        hour: Byte;
        min: Byte;
        sec: Byte;
        frame: Byte;
        fps: Byte;
        dummy: Byte;
        pad: array[0..1] of Byte);
      TIME_MIDI : (songptrpos: DWORD);
  end;
  MMTIME = mmtime_tag;

  PWaveFormatEx = ^TWaveFormatEx;
  tWAVEFORMATEX = packed record
    wFormatTag: Word;         { format type }
    nChannels: Word;          { number of channels (i.e. mono, stereo, etc.) }
    nSamplesPerSec: DWORD;  { sample rate }
    nAvgBytesPerSec: DWORD; { for buffer estimation }
    nBlockAlign: Word;      { block size of data }
    wBitsPerSample: Word;   { number of bits per sample of mono data }
    cbSize: Word;           { the count in bytes of the size of }
  end;

{ flags for dwFlags field of WAVEHDR }
const
  WHDR_DONE       = $00000001;  { done bit }
  WHDR_PREPARED   = $00000002;  { set if this header has been prepared }
  WHDR_BEGINLOOP  = $00000004;  { loop start block }
  WHDR_ENDLOOP    = $00000008;  { loop end block }
  WHDR_INQUEUE    = $00000010;  { reserved for driver }

{ waveform output device capabilities structure }
type
  PWaveOutCapsA = ^TWaveOutCapsA;
  PWaveOutCapsW = ^TWaveOutCapsW;
  PWaveOutCaps = PWaveOutCapsA;
  tagWAVEOUTCAPSA = record
    wMid: Word;                 { manufacturer ID }
    wPid: Word;                 { product ID }
    vDriverVersion: MMVERSION;       { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of AnsiChar;  { product name (NULL terminated string) }
    dwFormats: DWORD;          { formats supported }
    wChannels: Word;            { number of sources supported }
    dwSupport: DWORD;          { functionality supported by driver }
  end;
  tagWAVEOUTCAPSW = record
    wMid: Word;                 { manufacturer ID }
    wPid: Word;                 { product ID }
    vDriverVersion: MMVERSION;       { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of WideChar;  { product name (NULL terminated string) }
    dwFormats: DWORD;          { formats supported }
    wChannels: Word;            { number of sources supported }
    dwSupport: DWORD;          { functionality supported by driver }
  end;
  tagWAVEOUTCAPS = tagWAVEOUTCAPSA;
  TWaveOutCapsA = tagWAVEOUTCAPSA;
  TWaveOutCapsW = tagWAVEOUTCAPSW;
  TWaveOutCaps = TWaveOutCapsA;
  WAVEOUTCAPSA = tagWAVEOUTCAPSA;
  WAVEOUTCAPSW = tagWAVEOUTCAPSW;
  WAVEOUTCAPS = WAVEOUTCAPSA;


{ flags for dwSupport field of WAVEOUTCAPS }
const
  WAVECAPS_PITCH          = $0001;   { supports pitch control }
  WAVECAPS_PLAYBACKRATE   = $0002;   { supports playback rate control }
  WAVECAPS_VOLUME         = $0004;   { supports volume control }
  WAVECAPS_LRVOLUME       = $0008;   { separate left-right volume control }
  WAVECAPS_SYNC           = $0010;
  WAVECAPS_SAMPLEACCURATE = $0020;
  WAVECAPS_DIRECTSOUND    = $0040;

type
  PHWAVE = ^HWAVE;
  HWAVE = longint;
  PHWAVEIN = ^HWAVEIN;
  HWAVEIN = longint;
  PHWAVEOUT = ^HWAVEOUT;
  HWAVEOUT = longint;

  THandle=longword;

function waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external name '_waveOutOpen@24';
function waveOutClose(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external name '_waveOutClose@4';
function waveOutReset(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external name '_waveOutReset@4';
function waveOutPrepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr;  uSize: UINT): MMRESULT; stdcall; external name '_waveOutPrepareHeader@12';
function waveOutUnprepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr;  uSize: UINT): MMRESULT; stdcall; external name '_waveOutUnprepareHeader@12';
function waveOutGetDevCaps(uDeviceID: UINT; lpCaps: PWaveOutCaps; uSize: UINT): MMRESULT; stdcall; external name '_waveOutGetDevCapsA@12';
function waveOutWrite(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external name '_waveOutWrite@12';
function waveOutGetPosition(hWaveOut: HWAVEOUT; lpInfo: PMMTime; uSize: UINT): MMRESULT; stdcall; external name '_waveOutGetPosition@12';
function timeGetTime: DWORD; stdcall; external name '_timeGetTime@0';

type tfarproc=pointer;
       TFNThreadStartRoutine = TFarProc;

     PRTLCriticalSection = ^TRTLCriticalSection;

  PListEntry = ^TListEntry;
  _LIST_ENTRY = packed record
    Flink: PListEntry;
    Blink: PListEntry;
  end;
  TListEntry=PListEntry;

  PRTLCriticalSectionDebug = ^TRTLCriticalSectionDebug;
  _RTL_CRITICAL_SECTION_DEBUG = packed record
    Type_18: Word;
    CreatorBackTraceIndex: Word;
    CriticalSection: PRTLCriticalSection;
    ProcessLocksList: TListEntry;
    EntryCount: DWORD;
    ContentionCount: DWORD;
    Spare: array[0..1] of DWORD;
  end;
  TRTLCriticalSectionDebug = _RTL_CRITICAL_SECTION_DEBUG;
  RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;

  _RTL_CRITICAL_SECTION = packed record
    DebugInfo: PRTLCriticalSectionDebug;
    LockCount: Longint;
    RecursionCount: Longint;
    OwningThread: THandle;
    LockSemaphore: THandle;
    Reserved: DWORD;
  end;
  TRTLCriticalSection = _RTL_CRITICAL_SECTION;
  RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;

   TLargeInteger = Int64;
   
   PSystemInfo = ^TSystemInfo;
  _SYSTEM_INFO = packed record
    case longint of
      0: (
        dwOemId: DWORD);
      1: (
        wProcessorArchitecture: Word;
        wReserved: Word;
        dwPageSize: DWORD;
        lpMinimumApplicationAddress: Pointer;
        lpMaximumApplicationAddress: Pointer;
        dwActiveProcessorMask: DWORD;
        dwNumberOfProcessors: DWORD;
        dwProcessorType: DWORD;
        dwAllocationGranularity: DWORD;
        wProcessorLevel: Word;
        wProcessorRevision: Word);
  end;
  TSystemInfo = _SYSTEM_INFO;
  SYSTEM_INFO = _SYSTEM_INFO;

const  CREATE_SUSPENDED                = $00000004;

  THREAD_BASE_PRIORITY_LOWRT = 15;  { value that gets a thread to LowRealtime-1 }
  THREAD_BASE_PRIORITY_MAX = 2;     { maximum thread base priority boost }
  THREAD_BASE_PRIORITY_MIN = -2;    { minimum thread base priority boost }
  THREAD_BASE_PRIORITY_IDLE = -15;  { value that gets a thread to idle }

  DETACHED_PROCESS                = $00000008;

  CREATE_NEW_CONSOLE              = $00000010;

  NORMAL_PRIORITY_CLASS           = $00000020;
  IDLE_PRIORITY_CLASS             = $00000040;
  HIGH_PRIORITY_CLASS             = $00000080;
  REALTIME_PRIORITY_CLASS         = $00000100;

  CREATE_NEW_PROCESS_GROUP        = $00000200;
  CREATE_UNICODE_ENVIRONMENT      = $00000400;

  CREATE_SEPARATE_WOW_VDM         = $00000800;
  CREATE_SHARED_WOW_VDM           = $00001000;
  CREATE_FORCEDOS                 = $00002000;

  CREATE_DEFAULT_ERROR_MODE       = $04000000;
  CREATE_NO_WINDOW                = $08000000;

  PROFILE_USER                    = $10000000;
  PROFILE_KERNEL                  = $20000000;
  PROFILE_SERVER                  = $40000000;

  THREAD_PRIORITY_LOWEST              = THREAD_BASE_PRIORITY_MIN;
  THREAD_PRIORITY_BELOW_NORMAL        = THREAD_PRIORITY_LOWEST + 1;
  THREAD_PRIORITY_NORMAL              = 0;
  THREAD_PRIORITY_HIGHEST             = THREAD_BASE_PRIORITY_MAX;
  THREAD_PRIORITY_ABOVE_NORMAL        = THREAD_PRIORITY_HIGHEST - 1;

  THREAD_PRIORITY_TIME_CRITICAL       = THREAD_BASE_PRIORITY_LOWRT;
  THREAD_PRIORITY_IDLE                = THREAD_BASE_PRIORITY_IDLE;

procedure Sleep(dwMilliseconds: DWORD); stdcall; external name '_Sleep@4';
procedure ExitThread(dwExitCode: DWORD); stdcall; external name '_ExitThread@4';
function TerminateThread(hThread: THandle; dwExitCode: DWORD): LONGBOOL; stdcall; external name '_TerminateThread@8';
function SetThreadPriority(hThread: THandle; nPriority: longint): LONGBOOL; stdcall; external name '_SetThreadPriority@8';
function CreateThread(lpThreadAttributes: Pointer;  dwStackSize: DWORD; lpStartAddress: TFNThreadStartRoutine;  lpParameter: Pointer; dwCreationFlags: DWORD; var lpThreadId: DWORD): THandle; stdcall; external name '_CreateThread@24';
procedure InitializeCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external name '_InitializeCriticalSection@4';
procedure EnterCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external name '_EnterCriticalSection@4';
procedure LeaveCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external name '_LeaveCriticalSection@4';
procedure DeleteCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external name '_DeleteCriticalSection@4';
function WaitForSingleObject(hHandle: THandle; dwMilliseconds: DWORD): DWORD; stdcall; external name '_WaitForSingleObject@8';
function WaitForMultipleObjects(Count: DWORD; hHandles: pointer; bWaitAll: BOOL; dwMilliseconds: DWORD): DWORD; stdcall; external name '_WaitForMultipleObjects@16';
function CloseHandle(hObject: THandle): LONGBOOL; stdcall; external name '_CloseHandle@4';
function SuspendThread(hThread: THandle): DWORD; stdcall; external name '_SuspendThread@4';
function ResumeThread(hThread: THandle): DWORD; stdcall; external name '_ResumeThread@4';
function CreateEventA(lpEventAttributes: PSecurityAttributes; bManualReset, bInitialState: BOOL; lpName: PAnsiChar): THandle; stdcall; external name '_CreateEventA@16';
function SetEvent(hEvent: THandle): BOOL; stdcall; external name '_SetEvent@4';
procedure GetSystemInfo(var lpSystemInfo: TSystemInfo); stdcall; external name '_GetSystemInfo@4';
function GetProcessAffinityMask(hProcess: THandle; var lpProcessAffinityMask, lpSystemAffinityMask: DWORD): BOOL; stdcall; external name '_GetProcessAffinityMask@12';
function GetThreadPriority(hThread: THandle): longint; stdcall; external name '_GetThreadPriority@4';
function SetThreadIdealProcessor(hThread: THandle; dwIdealProcessor: DWORD): BOOL; stdcall; external name '_SetThreadIdealProcessor@8';
function GetCurrentThread: THandle; stdcall; external name '_GetCurrentThread@0';

{$else}
{$ifdef WIN32Plain}
{$ifdef fpc}
const
      MAXPNAMELEN      =  32;    { max product name length (including nil) }
      MAXERRORLENGTH   = 128;    { max error text length (including nil) }
      MAX_JOYSTICKOEMVXDNAME = 260; { max oem vxd name length (including nil) }

      WAVE_FORMAT_PCM     = 1;

type dword=longword;
     uint=dword;

  VERSION = UINT;               { major (high byte), minor (low byte) }
  MMVERSION = UINT;             { major (high byte), minor (low byte) }
  MMRESULT = UINT;              { error return code, 0 means no error }

  PWaveHdr = ^wavehdr_tag;
  wavehdr_tag = packed record
    lpData: PChar;              { pointer to locked data buffer }
    dwBufferLength: DWORD;      { length of data buffer }
    dwBytesRecorded: DWORD;     { used for input only }
    dwUser: DWORD;              { for client's use }
    dwFlags: DWORD;             { assorted flags (see defines) }
    dwLoops: DWORD;             { loop control counter }
    lpNext: PWaveHdr;           { reserved for driver }
    reserved: DWORD;            { reserved for driver }
  end;
//TWaveHdr = wavehdr_tag;
  WAVEHDR = wavehdr_tag;

const
  TIME_MS         = $0001;  { time in milliseconds }
  TIME_SAMPLES    = $0002;  { number of wave samples }
  TIME_BYTES      = $0004;  { current byte offset }
  TIME_SMPTE      = $0008;  { SMPTE time }
  TIME_MIDI       = $0010;  { MIDI time }
  TIME_TICKS      = $0020;  { Ticks within MIDI stream }

  WAVE_MAPPER     = UINT(-1);

  MMSYSERR_BASE          = 0;
  WAVERR_BASE            = 32;

  WAVERR_BADFORMAT      = WAVERR_BASE + 0;    { unsupported wave format }
  WAVERR_STILLPLAYING   = WAVERR_BASE + 1;    { still something playing }
  WAVERR_UNPREPARED     = WAVERR_BASE + 2;    { header not prepared }
  WAVERR_SYNC           = WAVERR_BASE + 3;    { device is synchronous }
  WAVERR_LASTERROR      = WAVERR_BASE + 3;    { last error in range }

  MMSYSERR_NOERROR      = 0;                  { no error }
  MMSYSERR_ERROR        = MMSYSERR_BASE + 1;  { unspecified error }
  MMSYSERR_BADDEVICEID  = MMSYSERR_BASE + 2;  { device ID out of range }
  MMSYSERR_NOTENABLED   = MMSYSERR_BASE + 3;  { driver failed enable }
  MMSYSERR_ALLOCATED    = MMSYSERR_BASE + 4;  { device already allocated }
  MMSYSERR_INVALHANDLE  = MMSYSERR_BASE + 5;  { device handle is invalid }
  MMSYSERR_NODRIVER     = MMSYSERR_BASE + 6;  { no device driver present }
  MMSYSERR_NOMEM        = MMSYSERR_BASE + 7;  { memory allocation error }
  MMSYSERR_NOTSUPPORTED = MMSYSERR_BASE + 8;  { function isn't supported }
  MMSYSERR_BADERRNUM    = MMSYSERR_BASE + 9;  { error value out of range }
  MMSYSERR_INVALFLAG    = MMSYSERR_BASE + 10; { invalid flag passed }
  MMSYSERR_INVALPARAM   = MMSYSERR_BASE + 11; { invalid parameter passed }
  MMSYSERR_HANDLEBUSY   = MMSYSERR_BASE + 12; { handle being used
                                                simultaneously on another
                                                thread (eg callback) }
  MMSYSERR_INVALIDALIAS = MMSYSERR_BASE + 13; { specified alias not found }
  MMSYSERR_BADDB        = MMSYSERR_BASE + 14; { bad registry database }
  MMSYSERR_KEYNOTFOUND  = MMSYSERR_BASE + 15; { registry key not found }
  MMSYSERR_READERROR    = MMSYSERR_BASE + 16; { registry read error }
  MMSYSERR_WRITEERROR   = MMSYSERR_BASE + 17; { registry write error }
  MMSYSERR_DELETEERROR  = MMSYSERR_BASE + 18; { registry delete error }
  MMSYSERR_VALNOTFOUND  = MMSYSERR_BASE + 19; { registry value not found }
  MMSYSERR_NODRIVERCB   = MMSYSERR_BASE + 20; { driver does not call DriverCallback }
  MMSYSERR_LASTERROR    = MMSYSERR_BASE + 20; { last error in range }

type
  PMMTime = ^mmtime_tag;
  mmtime_tag = packed record
    case wType: UINT of        { indicates the contents of the variant record }
     TIME_MS:      (ms: DWORD);
     TIME_SAMPLES: (sample: DWORD);
     TIME_BYTES:   (cb: DWORD);
     TIME_TICKS:   (ticks: DWORD);
     TIME_SMPTE: (
        hour: Byte;
        min: Byte;
        sec: Byte;
        frame: Byte;
        fps: Byte;
        dummy: Byte;
        pad: array[0..1] of Byte);
      TIME_MIDI : (songptrpos: DWORD);
  end;
  MMTIME = mmtime_tag;

  PWaveFormatEx = ^TWaveFormatEx;
  tWAVEFORMATEX = packed record
    wFormatTag: Word;         { format type }
    nChannels: Word;          { number of channels (i.e. mono, stereo, etc.) }
    nSamplesPerSec: DWORD;  { sample rate }
    nAvgBytesPerSec: DWORD; { for buffer estimation }
    nBlockAlign: Word;      { block size of data }
    wBitsPerSample: Word;   { number of bits per sample of mono data }
    cbSize: Word;           { the count in bytes of the size of }
  end;

{ flags for dwFlags field of WAVEHDR }
const
  WHDR_DONE       = $00000001;  { done bit }
  WHDR_PREPARED   = $00000002;  { set if this header has been prepared }
  WHDR_BEGINLOOP  = $00000004;  { loop start block }
  WHDR_ENDLOOP    = $00000008;  { loop end block }
  WHDR_INQUEUE    = $00000010;  { reserved for driver }

{ waveform output device capabilities structure }
type
  PWaveOutCapsA = ^TWaveOutCapsA;
  PWaveOutCapsW = ^TWaveOutCapsW;
  PWaveOutCaps = PWaveOutCapsA;
  tagWAVEOUTCAPSA = record
    wMid: Word;                 { manufacturer ID }
    wPid: Word;                 { product ID }
    vDriverVersion: MMVERSION;       { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of AnsiChar;  { product name (NULL terminated string) }
    dwFormats: DWORD;          { formats supported }
    wChannels: Word;            { number of sources supported }
    dwSupport: DWORD;          { functionality supported by driver }
  end;
  tagWAVEOUTCAPSW = record
    wMid: Word;                 { manufacturer ID }
    wPid: Word;                 { product ID }
    vDriverVersion: MMVERSION;       { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of WideChar;  { product name (NULL terminated string) }
    dwFormats: DWORD;          { formats supported }
    wChannels: Word;            { number of sources supported }
    dwSupport: DWORD;          { functionality supported by driver }
  end;
  tagWAVEOUTCAPS = tagWAVEOUTCAPSA;
  TWaveOutCapsA = tagWAVEOUTCAPSA;
  TWaveOutCapsW = tagWAVEOUTCAPSW;
  TWaveOutCaps = TWaveOutCapsA;
  WAVEOUTCAPSA = tagWAVEOUTCAPSA;
  WAVEOUTCAPSW = tagWAVEOUTCAPSW;
  WAVEOUTCAPS = WAVEOUTCAPSA;


{ flags for dwSupport field of WAVEOUTCAPS }
const
  WAVECAPS_PITCH          = $0001;   { supports pitch control }
  WAVECAPS_PLAYBACKRATE   = $0002;   { supports playback rate control }
  WAVECAPS_VOLUME         = $0004;   { supports volume control }
  WAVECAPS_LRVOLUME       = $0008;   { separate left-right volume control }
  WAVECAPS_SYNC           = $0010;
  WAVECAPS_SAMPLEACCURATE = $0020;
  WAVECAPS_DIRECTSOUND    = $0040;

type
  PHWAVE = ^HWAVE;
  HWAVE = longint;
  PHWAVEIN = ^HWAVEIN;
  HWAVEIN = longint;
  PHWAVEOUT = ^HWAVEOUT;
  HWAVEOUT = longint;

  THandle=longword;

function waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutOpen';
function waveOutClose(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutClose';
function waveOutReset(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutReset';
function waveOutPrepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr;  uSize: UINT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutPrepareHeader';
function waveOutUnprepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr;  uSize: UINT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutUnprepareHeader';
function waveOutGetDevCaps(uDeviceID: UINT; lpCaps: PWaveOutCaps; uSize: UINT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutGetDevCapsA';
function waveOutWrite(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutWrite';
function waveOutGetPosition(hWaveOut: HWAVEOUT; lpInfo: PMMTime; uSize: UINT): MMRESULT; stdcall; external 'winmm.dll' name 'waveOutGetPosition';
function timeGetTime: DWORD; stdcall; external 'winmm.dll' name 'timeGetTime';

type tfarproc=pointer;
       TFNThreadStartRoutine = TFarProc;

     PRTLCriticalSection = ^TRTLCriticalSection;

  PListEntry = ^TListEntry;
  _LIST_ENTRY = packed record
    Flink: PListEntry;
    Blink: PListEntry;
  end;
  TListEntry=PListEntry;

  PRTLCriticalSectionDebug = ^TRTLCriticalSectionDebug;
  _RTL_CRITICAL_SECTION_DEBUG = packed record
    Type_18: Word;
    CreatorBackTraceIndex: Word;
    CriticalSection: PRTLCriticalSection;
    ProcessLocksList: TListEntry;
    EntryCount: DWORD;
    ContentionCount: DWORD;
    Spare: array[0..1] of DWORD;
  end;
  TRTLCriticalSectionDebug = _RTL_CRITICAL_SECTION_DEBUG;
  RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;

  _RTL_CRITICAL_SECTION = packed record
    DebugInfo: PRTLCriticalSectionDebug;
    LockCount: Longint;
    RecursionCount: Longint;
    OwningThread: THandle;
    LockSemaphore: THandle;
    Reserved: DWORD;
  end;
  TRTLCriticalSection = _RTL_CRITICAL_SECTION;
  RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;

const  CREATE_SUSPENDED                = $00000004;

  THREAD_BASE_PRIORITY_LOWRT = 15;  { value that gets a thread to LowRealtime-1 }
  THREAD_BASE_PRIORITY_MAX = 2;     { maximum thread base priority boost }
  THREAD_BASE_PRIORITY_MIN = -2;    { minimum thread base priority boost }
  THREAD_BASE_PRIORITY_IDLE = -15;  { value that gets a thread to idle }

  DETACHED_PROCESS                = $00000008;

  CREATE_NEW_CONSOLE              = $00000010;

  NORMAL_PRIORITY_CLASS           = $00000020;
  IDLE_PRIORITY_CLASS             = $00000040;
  HIGH_PRIORITY_CLASS             = $00000080;
  REALTIME_PRIORITY_CLASS         = $00000100;

  CREATE_NEW_PROCESS_GROUP        = $00000200;
  CREATE_UNICODE_ENVIRONMENT      = $00000400;

  CREATE_SEPARATE_WOW_VDM         = $00000800;
  CREATE_SHARED_WOW_VDM           = $00001000;
  CREATE_FORCEDOS                 = $00002000;

  CREATE_DEFAULT_ERROR_MODE       = $04000000;
  CREATE_NO_WINDOW                = $08000000;

  PROFILE_USER                    = $10000000;
  PROFILE_KERNEL                  = $20000000;
  PROFILE_SERVER                  = $40000000;

  THREAD_PRIORITY_LOWEST              = THREAD_BASE_PRIORITY_MIN;
  THREAD_PRIORITY_BELOW_NORMAL        = THREAD_PRIORITY_LOWEST + 1;
  THREAD_PRIORITY_NORMAL              = 0;
  THREAD_PRIORITY_HIGHEST             = THREAD_BASE_PRIORITY_MAX;
  THREAD_PRIORITY_ABOVE_NORMAL        = THREAD_PRIORITY_HIGHEST - 1;

  THREAD_PRIORITY_TIME_CRITICAL       = THREAD_BASE_PRIORITY_LOWRT;
  THREAD_PRIORITY_IDLE                = THREAD_BASE_PRIORITY_IDLE;

procedure Sleep(dwMilliseconds: DWORD); stdcall; external 'kernel32.dll' name 'Sleep';
procedure ExitThread(dwExitCode: DWORD); stdcall; external 'kernel32.dll' name 'ExitThread';
function TerminateThread(hThread: THandle; dwExitCode: DWORD): LONGBOOL; stdcall; external 'kernel32.dll' name 'TerminateThread';
function SetThreadPriority(hThread: THandle; nPriority: longint): LONGBOOL; stdcall; external 'kernel32.dll' name 'SetThreadPriority';
function CreateThread(lpThreadAttributes: Pointer;  dwStackSize: DWORD; lpStartAddress: TFNThreadStartRoutine;  lpParameter: Pointer; dwCreationFlags: DWORD; var lpThreadId: DWORD): THandle; stdcall; external 'kernel32.dll' name 'CreateThread';
procedure InitializeCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external 'kernel32.dll' name 'InitializeCriticalSection';
procedure EnterCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external 'kernel32.dll' name 'EnterCriticalSection';
procedure LeaveCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external 'kernel32.dll' name 'LeaveCriticalSection';
procedure DeleteCriticalSection(var lpCriticalSection: TRTLCriticalSection); stdcall; external 'kernel32.dll' name 'DeleteCriticalSection';
function WaitForSingleObject(hHandle: THandle; dwMilliseconds: DWORD): DWORD; stdcall; external 'kernel32.dll' name 'WaitForSingleObject';
function CloseHandle(hObject: THandle): LONGBOOL; stdcall; external 'kernel32.dll' name 'CloseHandle';
function SuspendThread(hThread: THandle): DWORD; stdcall; external 'kernel32.dll' name 'SuspendThread';
function ResumeThread(hThread: THandle): DWORD; stdcall; external 'kernel32.dll' name 'ResumeThread';
{$else}
uses Windows,MMSystem;
{$endif}
{$else}
uses {$ifdef win32}Windows,{$endif}Math;
{$define UseOwnMath}
{$endif}
{$endif}

{$ifndef fpc}
type ptruint=longword;
     ptrint=longint;
{$endif}

const BR808SynthesizerVersion:longword=$00000004;

      NumberOfChannels=16;
      NumberOfVoices=99;
      NumberOfVoicesStandard=32;
      MaxSamples=128;
      MaxInstruments=128;
      MaxInstrumentOscillator=8;
      MaxInstrumentADSR=8;
      MaxInstrumentEnvelopes=8;
      MaxInstrumentLFO=8;
      MaxInstrumentFilter=8;
      MaxInstrumentDistortion=8;
      MaxInstrumentDelay=8;
      MaxEnvelopeNodes=32768;
      MaxProcessBuffers=MaxInstrumentOscillator;
      MaxThreads=16;
      MaxModulationMatrixMemory=8;
      MaxModulationMatrixBuffers=12;
      MaxModulationMatrixItems=255;
      MaxReverbAllPassFilters=16;
      MaxSpeechTexts=128;
      MaxEQBands=10;
      NumPadSynthHarmonics=256;

      DelayBufferSeconds=4;

      OutputShift=12;

      PitchBufferShift=10;
      PitchBufferSize=1 shl PitchBufferShift;
      PitchBufferMask=PitchBufferSize-1;

      MIDI_ALLNOTESOFF=$7b;
      MIDI_NOTEOFF=$80;
      MIDI_NOTEON=$90;
      MIDI_KEYAFTERTOUCH=$a0;
      MIDI_CONTROLCHANGE=$b0;
      MIDI_PROGRAMCHANGE=$c0;
      MIDI_CHANNELAFTERTOUCH=$d0;
      MIDI_PITCHBEND=$e0;
      MIDI_SYSTEMMESSAGE=$f0;
      MIDI_BEGINSYSEX=$f0;
      MIDI_MTCQUARTERFRAME=$f1;
      MIDI_TRACKPOSPTR=$f2;
      MIDI_TRACKSELECT=$f3;
      MIDI_ENDSYSEX=$f7;
      MIDI_TIMINGCLOCK=$f8;
      MIDI_START=$fa;
      MIDI_CONTINUE=$fb;
      MIDI_STOP=$fc;
      MIDI_ACTIVESENSING=$fe;
      MIDI_SYSTEMRESET=$ff;

      EQ_FFT_LENGTH=1024;

      eqm6db=0;
      eqm12db=1;
      eqm24db=2;

      psfGAUSS=0;
      psfSINGLE=1;
      psfDETUNE=2;
      psfSPREAD=3;

      slNONE=0;
      slFORWARD=1;
      slPINGPONG=2;
      slBACKWARD=3;

      nnaNoteCut=0;
      nnaNoteOff=1;

      cmMono=0;
      cmPoly=1;

      stNone=0;
      stPhaseModulation=1;
      stRingModulation=2;
      stAmplitudeModulation=3;
      stAdditive=4;
      stSubtractive=5;
      stFrequencyModulation=6;
      stPhaseMulModulation=7;
      stFrequencyMulModulation=8;

      wfNONE=0;
      wfSINE=1;
      wfTRIANGLE=2;
      wfPARABOLA=3;
      wfPULSE=4;
      wfSAWUP=5;
      wfSAWDOWN=6;
      wfSAWTRI=7;
      wfWHITENOISE=8;
      wfPINKNOISE=9;
      wfGRAYNOISE=10;
      wfBROWNNOISE=11;
      wfBLUENOISE=12;
      wfCLIPNOISE=13;
      wfGAUSSIANNOISE=14;
      wfBLTRI=15;
      wfBLPARABOLA=16;
      wfBLPULSE=17;
      wfBLSAWUP=18;
      wfBLSAWDOWN=19;
      wfPLUCKEDSTRING=20;
      wfSUPEROSC=21;
      wfSAMPLE=22;

      esNONE=0;
      esATTACK=1;
      esDECAY=2;
      esSUSTAIN=3;
      esRELEASE=4;

      emNONE=0;
      emLINEAR=1;
      emEXP=2;
      emLOG=3;

      emsOFF=0;
      emsON=1;
      emsTIME=2;

      lwfNONE=0;
      lwfSINE=1;
      lwfSAWUP=2;
      lwfSAWDOWN=3;
      lwfTRI=4;
      lwfSQUARE=5;
      lwfRANDOM=6;
      lwfSAMPLE=7;

      lpsGLOBAL=0;
      lpsCHANNEL=1;
      lpsVOICE=2;
      lpsRANDOM=3;

      fmNONE=0;
      fmLOWPASS=1;
      fmHIGHPASS=2;
      fmBANDPASS=3;
      fmNOTCH=4;
      fmALLPASS=5;
      fmBIQUADLOWPASS=6;
      fmBIQUADHIGHPASS=7;
      fmBIQUADBANDPASS=8;
      fmBIQUADNOTCH=9;
      fmBIQUADPEAKINGBANDEQ=10;
      fmBIQUADLOWSHELF=11;
      fmBIQUADHIGHSHELF=12;
      fmFORMANT=13;
      fmOVERDRIVE=14;
      fmMOOGLOWPASS=15;
      fmMOOGHIGHPASS=16;
      fmMOOGBANDPASS=17;

      ffvA=0;
      ffvE=1;
      ffvI=2;
      ffvO=3;
      ffvU=4;

      dmNONE=0;
      dmSOFT=1;
      dmHARD=2;
      dmFASTWAVESHAPER=3;
      dmWAVESHAPER1=4;
      dmWAVESHAPER2=5;
      dmGLOUBIBOULGA=6;
      dmFOLDBACK=7;
      dmSATURATION=8;
      dmDECIMATORCRUSHER=9;
      dmBITCRUSHER=10;
      dmDECIMATOR=11;
      dmOVERDRIVE=12;
      dmARCTANGENT=13;
      dmASYMMETRIC=14;
      dmASYMMETRIC2=15;
      dmPOWER=16;
      dmPOWER2=17;
      dmPOWER3=18;
      dmSINE=19;
      dmSINUS=20;
      dmQUANTISIZE=21;
      dmZIGZAG=22;
      dmLIMITER=23;
      dmUPPERLIMITER=24;
      dmLOWERLIMITER=25;
      dmINVERSELIMITER=26;
      dmCLIP=27;
      dmSIGMOID=28;
      dmDIFF=29;
      dmSTEREOEXPANDER=30;
      dmSTEREOENHANCER=31;
      dmSTEREOFIELDROTATION=32;

      cmNONE=0;
      cmMonoEnvFollowPeak=1;
      cmMonoAveragePeak=2;
      cmMonoMinimumPeak=3;
      cmMonoMaximumPeak=4;
      cmMonoLowPassRMS=5;
      cmMonoAverageRMS=6;
      cmStereoEnvFollowPeak=7;
      cmStereoAveragePeak=8;
      cmStereoMinimumPeak=9;
      cmStereoMaximumPeak=10;
      cmStereoLowPassRMS=11;
      cmStereoAverageRMS=12;

      eimNEAREST=0;
      eimLINEAR=1;
      eimCOSINE=2;
      eimCUBIC=3;
      eimCATMULLROM=4;

      voDistortion=0;
      voFilter=1;

      coDistortion=0;
      coFilter=1;
      coDelay=2;
      coChorusFlanger=3;
      coCompressor=4;
      coSpeech=5;
      coPitchShifter=6;
      coEQ=7;

      goPITCHSHIFTER=0;
      goENDFILTER=1;
      goEQ=2;
      goCOMPRESSOR=3;

      mmismLINEAR=0;
      mmismSQR=1;
      mmismSQRT=2;
      mmismSIN1D4=3;
      mmismCOS1D4=4;

      mmiNONE=0;
      mmiADSR=1;
      mmiENV=2;
      mmiLFO=3;
      mmiVALUE=4;
      mmiCONTROLLER=5;
      mmiNOTE=6;
      mmiVELOCITY=7;
      mmiKEYOFFVELOCITY=8;
      mmiAFTERTOUCH=9;
      mmiMODULATION=10;
      mmiBREATH=11;
      mmiVOLUME=12;
      mmiEXPRESSION=13;
      mmiPANNING=14;
      mmiPORTAMENTOTIME=15;
      mmiFOOTPEDAL=16;
      mmiHOLDPEDAL=17;
      mmiPORTAMENTOPEDAL=18;
      mmiSOSTENUTOPEDAL=19;
      mmiSOFTPEDAL=20;
      mmiLEGATOPEDAL=21;
      mmiHOLD2PEDAL=22;
      mmiVALUEEXT=23;
      mmiRESCALE=24;
      mmiINVRESCALE=25;
      mmiMEMORY=26;
      mmiNRPN=27;

      mmoGlobalChannelVolume=$00;
      mmoGlobalOutput=$0a;
      mmoGlobalReverb=$0b;
      mmoGlobalDelay=$0c;
      mmoGlobalChorusFlanger=$0d;

      mmoVolume=$10;
      mmoPanning=$11;
      mmoTranspose=$12;
      mmoPitch=$13;

      mmoOscTranspose=$20;
      mmoOscPitch=$21;
      mmoOscFeedBack=$22;
      mmoOscColor=$23;
      mmoOscVolume=$24;
      mmoOscHardSync=$25;
      mmoOscGlide=$26;
      mmoOscSmpPos=$27;
      mmoOscPluckedStringReflection=$28;
      mmoOscPluckedStringPick=$29;
      mmoOscPluckedStringPickUp=$2a;
      mmoOscSuperOscDetune=$2b;
      mmoOscSuperOscMix=$2c;

      mmoFilterCutOff=$30;
      mmoFilterResonance=$31;
      mmoFilterVolume=$32;
      mmoFilterAmplify=$33;

      mmoADSRAttack=$40;
      mmoADSRDecay=$41;
      mmoADSRSustain=$42;
      mmoADSRRelease=$43;
      mmoADSRDecayLevel=$44;
      mmoADSRAmplify=$45;

      mmoEnvelopeAmplify=$4a;

      mmoLFORate=$50;
      mmoLFOPhase=$51;
      mmoLFODepth=$52;
      mmoLFOMiddle=$53;

      mmoVoiceDistortionGain=$60;
      mmoVoiceDistortionDist=$61;
      mmoVoiceDistortionRate=$62;

      mmoChannelDistortionGain=$6a;
      mmoChannelDistortionDist=$6b;
      mmoChannelDistortionRate=$6c;

      mmoChannelFilterCutOff=$70;
      mmoChannelFilterResonance=$71;
      mmoChannelFilterVolume=$72;
      mmoChannelFilterAmplify=$73;

      mmoChannelDelayTimeLeft=$7a;
      mmoChannelDelayFeedBackLeft=$7b;
      mmoChannelDelayTimeRight=$7c;
      mmoChannelDelayFeedBackRight=$7d;
      mmoChannelDelayWet=$7e;
      mmoChannelDelayDry=$7f;

      mmoChannelChorusFlangerTimeLeft=$80;
      mmoChannelChorusFlangerFeedBackLeft=$81;
      mmoChannelChorusFlangerLFORateLeft=$82;
      mmoChannelChorusFlangerLFODepthLeft=$83;
      mmoChannelChorusFlangerLFOPhaseLeft=$84;
      mmoChannelChorusFlangerTimeRight=$85;
      mmoChannelChorusFlangerFeedBackRight=$86;
      mmoChannelChorusFlangerLFORateRight=$87;
      mmoChannelChorusFlangerLFODepthRight=$88;
      mmoChannelChorusFlangerLFOPhaseRight=$89;
      mmoChannelChorusFlangerWet=$8a;
      mmoChannelChorusFlangerDry=$8b;

      mmoChannelCompressorWindowSize=$90;
      mmoChannelCompressorSoftHardKnee=$91;
      mmoChannelCompressorThreshold=$92;
      mmoChannelCompressorRatio=$93;
      mmoChannelCompressorAttack=$94;
      mmoChannelCompressorRelease=$95;
      mmoChannelCompressorOutGain=$96;

      mmoChannelSpeechTextNumber=$a0;
      mmoChannelSpeechSpeed=$a1;
      mmoChannelSpeechColor=$a2;
      mmoChannelSpeechNoiseGain=$a3;
      mmoChannelSpeechGain=$a4;
      mmoChannelSpeechPosition=$a5;
      mmoChannelSpeechCascadeGain=$a6;
      mmoChannelSpeechParallelGain=$a7;
      mmoChannelSpeechAspirationGain=$a8;
      mmoChannelSpeechFricationGain=$a9;

      mmoChannelPitchShifterTune=$b0;
      mmoChannelPitchShifterFineTune=$b1;

      mmoChannelEQGain0=$c0;
      mmoChannelEQGain1=$c1;
      mmoChannelEQGain2=$c2;
      mmoChannelEQGain3=$c3;
      mmoChannelEQGain4=$c4;
      mmoChannelEQGain5=$c5;
      mmoChannelEQGain6=$c6;
      mmoChannelEQGain7=$c7;
      mmoChannelEQGain8=$c8;
      mmoChannelEQGain9=$c9;

      mmoMEMORY=$ff;

      mmpMUL=0;
      mmpMULABS=1;
      mmpADD=2;
      mmpSUB=3;
      mmpDIV=4;
      mmpDIVABS=5;

      rmLINEAR=0;
      rmEXP=1;

      Falv=$1;
      Fapr=$2;
      Fbck=$4;
      Fblb=$8;
      Fcnt=$10;
      Fdnt=$20;
      Ffnt=$40;
      Ffrc=$80;
      Fglt=$100;
      Fhgh=$200;
      Flat=$400;
      Flbd=$800;
      Flbv=$1000;
      Flmd=$2000;
      Flow=$4000;
      Fmdl=$8000;
      Fnas=$10000;
      Fpal=$20000;
      Fpla=$40000;
      Frnd=$80000;
      Frzd=$100000;
      Fsmh=$200000;
      fstp=$400000;
      Fumd=$800000;
      Funr=$1000000;
      Fvcd=$2000000;
      Fvel=$4000000;
      Fvls=$8000000;
      Fvwl=$10000000;

      SPfn=0;
      SPf1=1;
      SPf2=2;
      SPf3=3;
      SPb1=4;
      SPb2=5;
      SPb3=6;
      SPan=7;
      SPa1=8;
      SPa2=9;
      SPa3=10;
      SPa4=11;
      SPa5=12;
      SPa6=13;
      SPab=14;
      SPav=15;
      SPavc=16;
      SPasp=17;
      SPaf=18;
      NumberOfSegmentParameters=19;

      NumberOfSegments=69;

      vF=0;
      vB=1;
      vA=2;

      FracValue=1.0;

      AdjustAMP=14;

      fF1=0;
      fF2=1;
      fF3=2;
      fF4=3;
      fF5=4;
      fF6=5;
      fB1=6;
      fB2=7;
      fB3=8;
      fB4=9;
      fB5=10;
      fB6=11;
      fA1=12;
      fA2=13;
      fA3=14;
      fA4=15;
      fA5=16;
      fA6=17;
      fAspiration=18;
      fCascadeVoicing=19;
      fParallelVoicing=20;
      fByPass=21;
      fFrication=22;
      fFN=23;
      fStart=fF1;
      fEnd=fFN;

      NoValue=1.0e-10;

{$I SynthSpeechSegmentsIndices.inc}

{$ifdef VSTi}
{$I SynthSpeechSegmentsPhonemsData.inc}
{$endif}

      wfeNONE=0;
      wfeNOTEON=1;
      wfeNOTEOFF=2;

      FloatOne:single=1;

      fCI12:double=1/12;
      fCI17:double=1/17;
      fCI63:double=1/63;
      fCI64:single=1/64;
      fCI100:double=1/100;
      fCI126:double=1/126;
      fCI127:double=1/127;
      fCI128:single=1/128;
      fCI200:double=1/200;
      fCI255:double=1/255;
      fCI256:single=1/256;
      fCI256d17:double=256/17;
      fCI999:double=1/999;
      fCI999m4:double=4/999;
      fCI1200:double=1/1200;
      fCI16383:double=1/16383;
      fCI8192:single=1/8192;
      fCI16384:single=1/16384;
      fCI32768:single=1/32768;
      fCI65536:single=1/65536;

      InfiniteRatio:single=1/$100000000;

      FixDenormalValue:single=1e-18;

      SampleFixUp=32;

      EPSILON=1e-12;

      PIValue=3.1415926535897932384626433832795;
      PI2Value=2*PIValue;

      FracFactor:INT64=$100000000;//(1 shl PositionShift);

      PositionShift=32;
      PositionFactor:INT64=$100000000;//(1 shl PositionShift);
      PositionMask=$FFFFFFFF;//INT64(1 shl PositionShift)-1;
      PositionDivFactor=1/$100000000;//(1 shl PositionShift);

      PositionAllRemainBits=14;
      PositionAllRemainFactor=1 shl PositionAllRemainBits;

      SINC8_FRACBITS=12; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC8_LUTLEN=1 shl SINC8_FRACBITS;
      SINC8_LOG2WIDTH=3; // Anzahl der Samples im Fenster
      SINC8_WIDTH=1 shl SINC8_LOG2WIDTH;

      SINC16_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC16_LUTLEN=1 shl SINC16_FRACBITS;
      SINC16_LOG2WIDTH=4; // Anzahl der Samples im Fenster
      SINC16_WIDTH=1 shl SINC16_LOG2WIDTH;

      SINC32_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC32_LUTLEN=1 shl SINC32_FRACBITS;
      SINC32_LOG2WIDTH=5; // Anzahl der Samples im Fenster
      SINC32_WIDTH=1 shl SINC32_LOG2WIDTH;

      SINC64_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC64_LUTLEN=1 shl SINC64_FRACBITS;
      SINC64_LOG2WIDTH=6; // Anzahl der Samples im Fenster
      SINC64_WIDTH=1 shl SINC64_LOG2WIDTH;

      SINC128_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC128_LUTLEN=1 shl SINC128_FRACBITS;
      SINC128_LOG2WIDTH=7; // Anzahl der Samples im Fenster
      SINC128_WIDTH=1 shl SINC128_LOG2WIDTH;

      SINC256_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC256_LUTLEN=1 shl SINC256_FRACBITS;
      SINC256_LOG2WIDTH=8; // Anzahl der Samples im Fenster
      SINC256_WIDTH=1 shl SINC256_LOG2WIDTH;

      SINC512_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC512_LUTLEN=1 shl SINC512_FRACBITS;
      SINC512_LOG2WIDTH=9; // Anzahl der Samples im Fenster
      SINC512_WIDTH=1 shl SINC512_LOG2WIDTH;

      SINC1024_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC1024_LUTLEN=1 shl SINC1024_FRACBITS;
      SINC1024_LOG2WIDTH=10; // Anzahl der Samples im Fenster
      SINC1024_WIDTH=1 shl SINC1024_LOG2WIDTH;

      SINC_CUTOFF=0.97; /// 0.90; // cutoff (1.0== pi/2)
      SINC_HANN=0;
      SINC_HAMMING=1;
      SINC_BLACKMANEXACT=2;
      SINC_BLACKMAN3T61=3;
      SINC_BLACKMAN3T67=4;
      SINC_BLACKMAN4T92=5;
      SINC_BLACKMAN4T74=6;
      SINC_KAISER4T=7;
      SINC_TYPE=SINC_BLACKMANEXACT;
      SINC8_FRACSHIFT=PositionShift-SINC8_FRACBITS;
      SINC8_FRACMASK=(1 shl SINC8_FRACBITS)-1;
      SINC8_FRACSHIFTLENGTH=1 shl SINC8_FRACSHIFT;
      SINC8_FRACSHIFTMASK=SINC8_FRACSHIFTLENGTH-1;
      SINC8_FRACSHIFTFACTOR=1/SINC8_FRACSHIFTLENGTH;
      SINC16_FRACSHIFT=PositionShift-SINC16_FRACBITS;
      SINC16_FRACMASK=(1 shl SINC16_FRACBITS)-1;
      SINC16_FRACSHIFTLENGTH=1 shl SINC16_FRACSHIFT;
      SINC16_FRACSHIFTMASK=SINC16_FRACSHIFTLENGTH-1;
      SINC16_FRACSHIFTFACTOR=1/SINC16_FRACSHIFTLENGTH;
      SINC32_FRACSHIFT=PositionShift-SINC32_FRACBITS;
      SINC32_FRACMASK=(1 shl SINC32_FRACBITS)-1;
      SINC32_FRACSHIFTLENGTH=1 shl SINC32_FRACSHIFT;
      SINC32_FRACSHIFTMASK=SINC32_FRACSHIFTLENGTH-1;
      SINC32_FRACSHIFTFACTOR=1/SINC32_FRACSHIFTLENGTH;
      SINC64_FRACSHIFT=PositionShift-SINC64_FRACBITS;
      SINC64_FRACMASK=(1 shl SINC64_FRACBITS)-1;
      SINC64_FRACSHIFTLENGTH=1 shl SINC64_FRACSHIFT;
      SINC64_FRACSHIFTMASK=SINC64_FRACSHIFTLENGTH-1;
      SINC64_FRACSHIFTFACTOR=1/SINC64_FRACSHIFTLENGTH;
      SINC128_FRACSHIFT=PositionShift-SINC128_FRACBITS;
      SINC128_FRACMASK=(1 shl SINC128_FRACBITS)-1;
      SINC128_FRACSHIFTLENGTH=1 shl SINC128_FRACSHIFT;
      SINC128_FRACSHIFTMASK=SINC128_FRACSHIFTLENGTH-1;
      SINC128_FRACSHIFTFACTOR=1/SINC128_FRACSHIFTLENGTH;
      SINC256_FRACSHIFT=PositionShift-SINC256_FRACBITS;
      SINC256_FRACMASK=(1 shl SINC256_FRACBITS)-1;
      SINC256_FRACSHIFTLENGTH=1 shl SINC256_FRACSHIFT;
      SINC256_FRACSHIFTMASK=SINC256_FRACSHIFTLENGTH-1;
      SINC256_FRACSHIFTFACTOR=1/SINC256_FRACSHIFTLENGTH;
      SINC512_FRACSHIFT=PositionShift-SINC512_FRACBITS;
      SINC512_FRACMASK=(1 shl SINC512_FRACBITS)-1;
      SINC512_FRACSHIFTLENGTH=1 shl SINC512_FRACSHIFT;
      SINC512_FRACSHIFTMASK=SINC512_FRACSHIFTLENGTH-1;
      SINC512_FRACSHIFTFACTOR=1/SINC512_FRACSHIFTLENGTH;
      SINC1024_FRACSHIFT=PositionShift-SINC1024_FRACBITS;
      SINC1024_FRACMASK=(1 shl SINC1024_FRACBITS)-1;
      SINC1024_FRACSHIFTLENGTH=1 shl SINC1024_FRACSHIFT;
      SINC1024_FRACSHIFTMASK=SINC1024_FRACSHIFTLENGTH-1;
      SINC1024_FRACSHIFTFACTOR=1/SINC1024_FRACSHIFTLENGTH;
{     SINC_FRACSHIFT=PositionShift-(SINC_FRACBITS+1+SINC_LOG2WIDTH);
      SINC_FRACMASK=(((1 shl ((PositionShift+1)-SINC_FRACSHIFT))-1) AND NOT ((1 shl SINC_LOG2WIDTH)-1));
      SINC_FRACHALVE=1 shl (PositionShift-(SINC_FRACBITS+2));}

      EventPoolSize=4096;

      I32:int64=$100000000;

      BANDLIMITED_WAVETABLE_BITS=12;//14;//4;
      BANDLIMITED_WAVETABLE_SIZE=1 shl BANDLIMITED_WAVETABLE_BITS;
      BANDLIMITED_WAVETABLE_MASK=BANDLIMITED_WAVETABLE_SIZE-1;

      BANDLIMITED_MAP_BITS=18;
      BANDLIMITED_MAP_SIZE=1 shl BANDLIMITED_MAP_BITS;
      BANDLIMITED_MAP_MASK=BANDLIMITED_MAP_SIZE-1;

//    SINC_CUTOFF=0.97; /// 0.90; // cutoff (1.0== pi/2)
      SINC_FRACBITS=16; // log2(number)-1 der vorberechnten Taps (Bereich ist [4..12])
      SINC_LUTLEN=1 shl SINC_FRACBITS;
      SINC_LOG2WIDTH=4; // Anzahl der Samples im Fenster
      SINC_WIDTH=1 shl SINC_LOG2WIDTH;
      SINC_FRACSHIFT=PositionShift-SINC_FRACBITS;
      SINC_FRACMASK=(1 shl SINC_FRACBITS)-1;
      SINC_FRACSHIFTLENGTH=1 shl SINC_FRACSHIFT;
      SINC_FRACSHIFTMASK=SINC_FRACSHIFTLENGTH-1;
      SINC_FRACSHIFTFACTOR=1/SINC_FRACSHIFTLENGTH;

      DOWNSAMPLE_MAX=4;
      DOWNSAMPLE_MAXFACTOR=1 shl DOWNSAMPLE_MAX;
      DOWNSAMPLE_MAXWIDTH=1 shl DOWNSAMPLE_MAX;
      DOWNSAMPLESINC_MAXWIDTH=DOWNSAMPLE_MAXWIDTH;

      FS_SINC_CUTOFF=0.97; /// 0.90; // cutoff (1.0== pi/2)
      PS_INTERPOLATION_WIDTH=5;

      CHORUS_MAX=4;

      CHORUS_INTERPOLATION_SUBSAMPLES_BITS=8;
      CHORUS_INTERPOLATION_SUBSAMPLES=1 shl CHORUS_INTERPOLATION_SUBSAMPLES_BITS;
      CHORUS_INTERPOLATION_SUBSAMPLES_MASK=CHORUS_INTERPOLATION_SUBSAMPLES-1;

      CHORUS_INTERPOLATION_SAMPLES=5;

      ADPCMIMAStepTable:array[0..88] of longint=(7,8,9,10,11,12,13,14,16,17,
                                                 19,21,23,25,28,31,34,37,41,45,
                                                 50,55,60,66,73,80,88,97,107,118,
                                                 130,143,157,173,190,209,230,253,279,307,
                                                 337,371,408,449,494,544,598,658,724,796,
                                                 876,963,1060,1166,1282,1411,1552,1707,1878,2066,
                                                 2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,
                                                 5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,
                                                 15289,16818,18500,20350,22385,24623,27086,29794,32767);
      ADPCMIMAIndexTable:array[0..15] of longint=(-1,-1,-1,-1,2,4,6,8,-1,-1,-1,-1,2,4,6,8);
      ADPCMIMADifferenceLookUpTable:array[0..15] of longint=(1,3,5,7,9,11,13,15,-1,-3,-5,-7,-9,-11,-13,-15);

      sodcmORIGINAL=0;
      sodcmSYMMETRIC=1;
      sodcmMODERN=2;

      sodcmFIRST=sodcmORIGINAL;
      sodcmLAST=sodcmMODERN;

      soCountSubOscillators=9;

      sowfSAWUP=0;
      sowfSAWDOWN=1;
      sowfSINE=2;
      oswfTRIANGLE=3;
      sowfPULSE=4;
      sowfPARABOLA=5;
      sowfHPSAWUP=6;
      sowfHPSAWDOWN=7;
      sowfHPSINE=8;
      oswfHPTRIANGLE=9;
      sowfHPPULSE=10;
      sowfHPPARABOLA=11;
      sowfBLSAWUP=12;
      sowfBLSAWDOWN=13;
      sowfBLSINE=14;
      oswfBLTRIANGLE=15;
      sowfBLPULSE=16;
      sowfBLPARABOLA=17;

      soDetuneCoefficients:array[sodcmFIRST..sodcmLAST,0..soCountSubOscillators-1] of single=
       ((0,-0.01952356,0.01991221,-0.06288439,0.06216538,-0.11002313,0.10745242,-0.14321312,0.14523353),
       (0,-0.019,0.019,-0.062,0.062,-0.108,0.108,-0.144,0.144),
       (0,-0.02,0.02,-0.6,0.06,-0.12,0.12,-0.2,0.2));

      psdlmNEAREST=0;
      psdlmLINEAR=1;
      psdlmLAGRANGE=2;
      psdlmCUBIC=3;
      psdlmSINC=4;
      psdlmALLPASSACCESS=5;
      psdlmALLPASSLOGIC=6;
      psdlmAFTERLAST=7;

      SynthFCW:word=$27f;

      MMXExt:longbool=false;
      SSEExt:longbool=false;
      SSE2Ext:longbool=false;
      SSE3Ext:longbool=false;

      FixedWorkBufferSize=1024;

type pbyte=^byte;
     pshortint=^shortint;
     pword=^word;
     psmallint=^smallint;
     plongword=^longword;
     plongint=^longint;
     psingle=^single;
     pboolean=^boolean;

     PByteArray=^TByteArray;
     TByteArray=array[0..65535] of byte;

     psinglearray=^tsinglearray;
     tsinglearray=array[0..65535] of single;

{$ifdef WIN32Plain}
     TWAVEHDR=WAVEHDR;
     TMMTime=MMTime;
{$endif}

     PBandlimitedWaveTable=^TBandlimitedWaveTable;
     TBandlimitedWaveTable=array[0..BANDLIMITED_WAVETABLE_SIZE-1] of single;

     PBandlimitedDoubleWaveTable=^TBandlimitedDoubleWaveTable;
     TBandlimitedDoubleWaveTable=array[0..(BANDLIMITED_WAVETABLE_SIZE*2)-1] of single;

     PBandlimitedWaveTables=^TBandlimitedWaveTables;
     TBandlimitedWaveTables=array[0..127] of TBandlimitedWaveTable;

     TBandlimitedMap=array[0..BANDLIMITED_MAP_SIZE-1] of longint;

     PDownsampleSINCSubArray=^TDownsampleSINCSubArray;
     TDownsampleSINCSubArray=packed array[0..DOWNSAMPLESINC_MAXWIDTH-1] of single;

     PDownsampleSINCArray=^TDownsampleSINCArray;
     TDownsampleSINCArray=packed array[0..DOWNSAMPLESINC_MAXWIDTH-1] of TDownsampleSINCSubArray;

     PSynthTauss88NoiseStates=^TSynthTauss88NoiseStates;
     TSynthTauss88NoiseStates=array[0..2] of longword;

     PSynthADPCMIMAState=^TSynthADPCMIMAState;
     TSynthADPCMIMAState=record
      PrevSample:longint;
      StepIndex:longint;
     end;

     PSynthFFTValue=^TSynthFFTValue;
     TSynthFFTValue=double;

     PSynthFFTValueArray=^TSynthFFTValueArray;
     TSynthFFTValueArray=array[0..0] of TSynthFFTValue;

     PSynthFFTIntegerArray=^TSynthFFTIntegerArray;
     TSynthFFTIntegerArray=array[0..0] of longint;

     TSynthFFTBitReversedLookUpTable=record
      Data:PSynthFFTIntegerArray;
     end;

     TSynthFFTTrigonemtricTable=record
      Data:PSynthFFTValueArray;
     end;

     TSynthFFT=record
      BitReversedLookUpTable:TSynthFFTBitReversedLookUpTable;
      TrigonemtricTable:TSynthFFTTrigonemtricTable;
      Sqrt2Div2:TSynthFFTValue;
      FrameSize:longint;
      BitCount:longint;
      BufferData:PSynthFFTValueArray;
     end;

     TSynthPadSynthHarmonics=array[0..NumPadSynthHarmonics-1] of single;

     TSynthSpeechSegmentName=array[1..4] of char;

     PSynthSpeechSegmentParameter=^TSynthSpeechSegmentParameter;
     TSynthSpeechSegmentParameter=packed record
      Steady,Fixed:single;
      Prop,Extern,Intern:byte;
     end;

     PSynthSpeechSegment=^TSynthSpeechSegment;
     TSynthSpeechSegment=packed record
//    Name:TSynthSpeechSegmentName;
      Rank,Duration{,AdditionalDuration}:byte;
      Features:longword;
      Parameters:array[0..NumberOfSegmentParameters-1] of TSynthSpeechSegmentParameter;
     end;

     PSynthSpeechSegments=^TSynthSpeechSegments;
     TSynthSpeechSegments=array[0..NumberOfSegments-1] of TSynthSpeechSegment;

     TSynthSpeechSegmentsStream=packed record
//    Name:ARRAY[0..NumberOfSegments-1] OF TSynthSpeechSegmentName;
      Rank:array[0..NumberOfSegments-1] of byte;
      Duration:array[0..NumberOfSegments-1] of byte;
//    AdditionalDuration:ARRAY[0..NumberOfSegments-1] OF BYTE;
      Features:array[0..NumberOfSegments-1] of longword;
      Prop:array[0..NumberOfSegmentParameters-1,0..NumberOfSegments-1] of byte;
      Extern:array[0..NumberOfSegmentParameters-1,0..NumberOfSegments-1] of byte;
      Intern:array[0..NumberOfSegmentParameters-1,0..NumberOfSegments-1] of byte;
      Steady:array[0..NumberOfSegmentParameters-1,0..NumberOfSegments-1] of single;
      Fixed:array[0..NumberOfSegmentParameters-1,0..NumberOfSegments-1] of single;
     end;

     PSynthSpeechSegmentItem=^TSynthSpeechSegmentItem;
     TSynthSpeechSegmentItem=record
      SegmentIndex,DurationTimeFactor,WaitForEvent:longint;
     end;

     PSynthSpeechSegmentItems=^TSynthSpeechSegmentItems;
     TSynthSpeechSegmentItems=array[0..0] of TSynthSpeechSegmentItem;

     PSynthSpeechSegmentList=^TSynthSpeechSegmentList;
     TSynthSpeechSegmentList=record
      Items:PSynthSpeechSegmentItems;
      ItemCount:longint;
{$ifdef VSTi}
      Phonems:string;
{$endif}
     end;

     TSynthSpeechSegmentLists=array[0..MaxInstruments-1,0..MaxSpeechTexts-1] of TSynthSpeechSegmentList;

     TSynthSpeechSegmentListInstance=record
      List:PSynthSpeechSegmentList;
      Position:longint;
     end;

     TSynthSpeechResonator=record {Digital 12dB IIR Resonator}
      A,B,C, {Filter variables}
      P1,P2:single; {2 Poles with 12 dB}
     end;

     PSynthSpeechSlope=^TSynthSpeechSlope;
     TSynthSpeechSlope=packed record
      Value:single;
      Time:longint;
     end;

     PSynthSpeechTransform=^TSynthSpeechTransform;
     TSynthSpeechTransform=array[0..NumberOfSegmentParameters-1] of TSynthSpeechSlope;

     PSynthSpeechFilter=^TSynthSpeechFilter;
     TSynthSpeechFilter=packed record
      A,B,V:single;
     end;

     TSynthSpeechFrameField=fStart..fEnd;

     PSynthSpeechFrame=^TSynthSpeechFrame;
     TSynthSpeechFrame=array[TSynthSpeechFrameField] of single;

     TSynthSpeechResonators=array[0..5] of TSynthSpeechResonator;

     TSynthSpeechSegmentSet=set of byte;

     TSynthSpeechChannel=record
      CascadeResonator:TSynthSpeechResonators;
      ParallelResonator:TSynthSpeechResonators;
      ResonatorOut:TSynthSpeechResonator;
     end;
     TSynthSpeechChannels=array[0..1] of TSynthSpeechChannel;

     PSynthByteArray=^TSynthByteArray;
     TSynthByteArray=array[0..(1 shl 30)-1] of byte;

     PSynthFloatValue=^TSynthFloatValue;
     TSynthFloatValue=single; // 32-Bit Floating Point Sample

     PSynthFloatValues=^TSynthFloatValues;
     TSynthFloatValues=array[0..65536] of TSynthFloatValue;

     PSingles=^TSingles;
     TSingles=array[0..65536] of Single;

     PLongwords=^TLongwords;
     TLongwords=array[0..65536] of longword;

     PSynthBufferSample=^TSynthBufferSample;
     TSynthBufferSample=packed record
      case boolean of
       false:(Channel:array[0..1] of TSynthFloatValue);
       true:(
        Left:TSynthFloatValue;
        Right:TSynthFloatValue;
       );
     end;

     PSynthBufferSamples=^TSynthBufferSamples;
     TSynthBufferSamples=array[0..65536] of TSynthBufferSample;

     PSynthWorkSampleBuffer=^TSynthWorkSampleBuffer;
     TSynthWorkSampleBuffer=array[0..FixedWorkBufferSize-1] of TSynthBufferSample;

     PSynthWorkBuffer=^TSynthWorkBuffer;
     TSynthWorkBuffer=array[0..FixedWorkBufferSize-1] of TSynthFloatValue;

     PSynthWorkBooleanBuffer=^TSynthWorkBooleanBuffer;
     TSynthWorkBooleanBuffer=array[0..FixedWorkBufferSize-1] of boolean;

     PSynthPitchShifterBuffer=^TSynthPitchShifterBuffer;
     TSynthPitchShifterBuffer=array[0..PitchBufferSize+16] of TSynthBufferSample;

     PSynthPitchShifterFadeBuffer=^TSynthPitchShifterFadeBuffer;
     TSynthPitchShifterFadeBuffer=array[0..PitchBufferSize+1] of single;

     TSynthEventData=array[1..4] of byte;

     PSynthEvent=^TSynthEvent;
     TSynthEvent=packed record
      Time:int64;
      ID:int64;
      Command:byte;
      Data:TSynthEventData;
      SysEx:pointer;
      SysExLen:longint;
      Previous,Next:PSynthEvent;
      SampleIndex:int64;
      Parent,Left,Right:PSynthEvent;
      Level:int64;
     end;

     PSynthEventPool=^TSynthEventPool;
     TSynthEventPool=record
      Events:array[0..EventPoolSize-1] of TSynthEvent;
      Position:longint;
      Next:PSynthEventPool;
     end;

     TSynthRamping=packed record
      Current:single;
      Dest:single;
      Step:single;
      Factor:single;
      BufferAlreadyFilledValue:single;
      Remain:longint;
      BufferAlreadyFilledSamples:longint;
      Active:boolean;
      HasBufferAlreadyFilled:boolean;
     end;

     PSynthButterworthFilter=^TSynthButterworthFilter;
     TSynthButterworthFilter=record
      Order:longint;
      OrderInv,Gain:double;
      Coefs,State:array[0..127] of double;
     end;

{    TSynthAllPass=record
      a,x0,x1,x2,y0,y1,y2:single;
     end;

     TSynthAllPassFilterCascade=record
      AllPassFilters:array[0..31] of TSynthAllPass;
      Order:longint;
     end;

     TSynthHalfBandFilter=record
      Order:longint;
      Last:single;
      aCoeffs,bCoeffs:array[0..31] of single;
      FilterA,FilterB:TSynthAllPassFilterCascade;
     end;}

     TSynthOversampler=record
      Factor:longint;
      UpFilter,DownFilter:TSynthButterworthFilter;
      Buffer:array[0..127] of double;
{     DownHalfBand:TSynthHalfBandFilter;
      UpHalfBand:TSynthHalfBandFilter;}
     end;

     TSynthPluckedStringAllPassHistory=record
      x1,y1:single;
     end;

     TSynthPluckedStringAllPassHistories=array[0..1] of TSynthPluckedStringAllPassHistory;

     TSynthPluckedStringInterpolationArray=array[0..PS_INTERPOLATION_WIDTH-1] of single;

     TSynthPluckedStringDelayLine=record
      Buffer:PSynthFloatValues;
      Mode:byte;
      Position:longint;
      Len:longint;
      LenFrac:single;
      OldSamples:single;
      AllPassCoef:single;
      AllPassHistories:TSynthPluckedStringAllPassHistories;
      InterpolationArray:TSynthPluckedStringInterpolationArray;
     end;

     PSynthPluckedString=^TSynthPluckedString;
     TSynthPluckedString=record
      UpperRail:TSynthPluckedStringDelayLine;
      LowerRail:TSynthPluckedStringDelayLine;
      State:single;
      Location:longint;
      Seed:longword;
      ReflectionFactor:single;
      AllPassInLoop:bytebool;
      AllPassCoef:single;
      AllPassLast:single;
      OldLen:longint;
     end;

     TSynthPluckedStrings=array[0..NumberOfVoices-1,0..MaxInstrumentOscillator-1] of TSynthPluckedString;

     TSynthPluckedStringBuffers=array[0..NumberOfVoices-1,0..MaxInstrumentOscillator-1,0..1] of PSynthFloatValues;

     TSynthSampleLoop=packed record
      Mode:byte;
      Backwards:boolean;
      StartSample:longint;
      EndSample:longint;
     end;

     PSynthSampleHeader=^TSynthSampleHeader;
     TSynthSampleHeader=packed record
      Samples:longint;
      Channels:byte;
      SampleRate:longint;
      PhaseSamples:longint;
      Note:longint;
      FineTune:longword;
      Loop:TSynthSampleLoop;
      SustainLoop:TSynthSampleLoop;
      RandomStartPosition:boolean;
     end;

     TSynthSamplePadSynth=packed record
      Active:boolean;
      ToGenerate:boolean;
      WavetableSize:longint;
      SampleRate:longint;
      Profile:byte;
      Frequency:single;
      BandWidth:single;
      BandWidthScale:single;
      ExtendedAlgorithm:boolean;
      CurveMode:byte;
      CurveSteepness:byte;
      Stereo:boolean;
      ExtendedBalance:boolean;
      Balance:shortint;
      NumHarmonics:longint;
      Harmonics:TSynthPadSynthHarmonics;
     end;

     PSynthSample=^TSynthSample;
     TSynthSample=record
      Header:TSynthSampleHeader;
      PadSynth:TSynthSamplePadSynth;
      Data:PSynthFloatValue;
      WorkData:PSynthFloatValue;
     end;

     TSynthSpeechInstanceData=record
      Active:boolean;
      DoStop:longint;
      Channel:TSynthSpeechChannels;
      LastNoise:single;
      LastParGlotOut:single;
      Speed:longint;
      LastSegment,CurrentSegment,NewSegment,StressSegment:PSynthSpeechSegment;
      LastSegmentItem,CurrentSegmentitem,NewSegmentItem:TSynthSpeechSegmentItem;
      StartSegmentValues,EndSegmentValues:TSynthSpeechTransform;
      StartStress,EndStress:TSynthSpeechSlope;
      Filter:array[0..NumberOfSegmentParameters-1] of TSynthSpeechFilter;
      TimeParameters:array[0..NumberOfSegmentParameters-1] of single;
      Duration,Time,DurationCounter,TimeRemain,FrameLength,FrameRemain:longint;
      Factor:single;
      Frame:TSynthSpeechFrame;
      WaitForEvent:longint;
      SegmentList:TSynthSpeechSegmentListInstance;
      TextNumber:longint;
      Color:longint;
      NoiseGain:longint;
      Gain:longint;
      F4,F5,F6,B4,B5,B6:longint;
      CascadeGain:longint;
      ParallelGain:longint;
      AspirationGain:longint;
      FricationGain:longint;
      Seed:longword;
     end;

     PSynthInstrumentOscillator=^TSynthInstrumentOscillator;
     TSynthInstrumentOscillator=packed record
      NoteBegin:byte;
      NoteEnd:byte;
      WaveForm:byte;
      FeedBack:smallint;
      Color:shortint;
      Transpose:shortint;
      FineTune:shortint;
      PhaseStart:byte;
      SynthesisType:byte;
      Volume:byte;
      HardSync:boolean;
      Glide:byte;
      Carry:boolean;
      PMFMExtendedMode:boolean;
      RandomPhase:boolean;
      UsePanning:boolean;
      Panning:shortint;
      Output:boolean;
      Input:shortint;
      HardSyncInput:shortint;
      PluckedStringDelayLineMode:byte;
      PluckedStringDelayLineWidth:byte;
      PluckedStringReflection:byte;
      PluckedStringPick:byte;
      PluckedStringPickUp:byte;
      SuperOscWaveform:byte;
      SuperOscMode:byte;
      SuperOscCount:byte;
      SuperOscDetune:byte;
      SuperOscMix:byte;
     end;
     TSynthInstrumentOscillators=array[0..MaxInstrumentOscillator-1] of TSynthInstrumentOscillator;

     PSynthInstrumentOscillatorData=^TSynthInstrumentOscillatorData;
     TSynthInstrumentOscillatorData=record
      RampingPhase:TSynthRamping;
      Phase:single;
      PhaseIncrement:single;
      RealPhaseIncrement:single;
      SampleIndex:int64;
      SampleBackwards:boolean;
      SampleActive:boolean;
      KeyOff:boolean;
      GlideSamples:longint;
      NoiseMode:longint;
      GaussianNoiseState:longbool;
      GaussianNoiseNext:single;
      PinkNoiseStates:array[0..4] of single;
      GrayNoiseStates:TSynthTauss88NoiseStates;
      GrayNoiseState:longint;
      NoiseLast:single;
      FeedBack:single;
      Last:single;
      NewNoteEx:boolean;
      NewFrequencyEx:boolean;
      NewNote:boolean;
      NewFrequency:boolean;
      Seed:longword;
      Patch:byte;
      PluckedString:TSynthPluckedString;
      SuperOscPhases:array[0..soCountSubOscillators-1] of single;
      SuperOscSVF:array[0..soCountSubOscillators-1,0..2] of single;
      Sample:PSynthSample;
     end;
     TSynthInstrumentOscillatorsData=array[0..MaxInstrumentOscillator-1] of TSynthInstrumentOscillatorData;

     PSynthInstrumentADSR=^TSynthInstrumentADSR;
     TSynthInstrumentADSR=packed record
      Active:boolean;
      Modes:array[esATTACK..esRELEASE] of byte;
      Times:array[esATTACK..esRELEASE] of byte;
      TargetDecayLevel:byte;
      Amplify:byte;
      ActiveCheck:boolean;
      Carry:boolean;
      Centerise:boolean;
     end;
     TSynthInstrumentADSRs=array[0..MaxInstrumentADSR-1] of TSynthInstrumentADSR;

     PSynthInstrumentADSRData=^TSynthInstrumentADSRData;
     TSynthInstrumentADSRData=record
      Levels:array[esATTACK..esRELEASE] of single;
      Times:array[esATTACK..esRELEASE] of longint;
      Samples:array[esATTACK..esRELEASE] of longint;
      Amplify:single;
      CoefA,CoefB,CoefC,CoefX,Value:single;
      SampleRemain:longint;
      State,OldState:byte;
     end;
     TSynthInstrumentADSRsData=array[0..MaxInstrumentADSR-1] of TSynthInstrumentADSRData;

     PSynthInstrumentEnvelope=^TSynthInstrumentEnvelope;
     TSynthInstrumentEnvelope=packed record
      Active:boolean;   
      Amplify:byte;
      ActiveCheck:boolean;
      Carry:boolean;
      Centerise:boolean;
     end;
     TSynthInstrumentEnvelopes=array[0..MaxInstrumentEnvelopes-1] of TSynthInstrumentEnvelope;

     PSynthInstrumentEnvelopeData=^TSynthInstrumentEnvelopeData;
     TSynthInstrumentEnvelopeData=record
      KeyOff:boolean;
      EndOfEnvelope:boolean;
      SampleRemain:longint;
      SampleCounter:longint;
      CurrentNode:longint;
      InterpolationMode:longint;
      X0,X1,X2,X3:longint;
      Y0,Y1,Y2,Y3:single;
      X2MX1DF:single;
      LastValue:single;
     end;
     TSynthInstrumentEnvelopesData=array[0..MaxInstrumentEnvelopes-1] of TSynthInstrumentEnvelopeData;

     PSynthInstrumentLFO=^TSynthInstrumentLFO;
     TSynthInstrumentLFO=packed record
      WaveForm:byte;
      Sample:byte;
      Rate:byte;
      Depth:byte;
      Middle:shortint;
      Sweep:byte;
      PhaseStart:byte;
      Amp:boolean;
      Carry:boolean;
      PhaseSync:byte;
     end;
     TSynthInstrumentLFOs=array[0..MaxInstrumentLFO-1] of TSynthInstrumentLFO;

     PSynthInstrumentLFOData=^TSynthInstrumentLFOData;
     TSynthInstrumentLFOData=record
      Phase:single;
      PhaseIncrement:single;
      Sweep:single;
      SweepIncrement:single;
      Last:single;
      Seed:longword;
     end;
     TSynthInstrumentLFOsData=array[0..MaxInstrumentLFO-1] of TSynthInstrumentLFOData;

     PSynthInstrumentFilter=^TSynthInstrumentFilter;
     TSynthInstrumentFilter=packed record
      Mode:byte;
      CutOff:byte;
      Resonance:byte;
      Volume:byte;
      Amplify:shortint;
      Cascaded:boolean;
      Chain:boolean;
      Carry:boolean;
      MinHz:word;
      MaxHz:word;
     end;
     TSynthInstrumentFilters=array[0..MaxInstrumentFilter-1] of TSynthInstrumentFilter;

     TSynthInstrumentFilterDataSVFMemory=record
      Low,Band,High:single;
     end;
     TSynthInstrumentFilterDataSVFMemorys=array[0..1,boolean] of TSynthInstrumentFilterDataSVFMemory;

     TSynthInstrumentFilterDataBIQUADMemory=record
      Ready:boolean;
      VF,VQ,VA:single;
      Gain:single;
      B0,B1,B2,A0,A1,A2:single;
      Y1,Y2,Y3,Y4:single;
      HA1L,HA2L,HB1L,HB2L,HA1R,HA2R,HB1R,HB2R:single;
      Samples:longword;
      MinHz,MaxHz:single;
     end;

     TSynthInstrumentFilterDataFormantMemory=array[0..1,0..9] of single;

     PSynthInstrumentFilterDataMoogHistoryMemory=^TSynthInstrumentFilterDataMoogHistoryMemory;
     TSynthInstrumentFilterDataMoogHistoryMemory=array[0..4] of single;

     TSynthInstrumentFilterDataMoogMemory=record
      Ready:boolean;
      f,p,q:single;
      b:array[0..1] of TSynthInstrumentFilterDataMoogHistoryMemory;
     end;

     PSynthInstrumentFilterData=^TSynthInstrumentFilterData;
     TSynthInstrumentFilterData=record
      SVFMemory:TSynthInstrumentFilterDataSVFMemorys;
      BIQUADMemory:TSynthInstrumentFilterDataBIQUADMemory;
      BIQUADMemoryCascaded:TSynthInstrumentFilterDataBIQUADMemory;
      FormantMemory:TSynthInstrumentFilterDataFormantMemory;
      FormantMemoryCascaded:TSynthInstrumentFilterDataFormantMemory;
      MoogMemory:TSynthInstrumentFilterDataMoogMemory;
      MoogMemoryCascaded:TSynthInstrumentFilterDataMoogMemory;
      OverdriveLeft,OverdriveRight:single;
      OverdriveLeftCascaded,OverdriveRightCascaded:single;
     end;
     TSynthInstrumentFiltersData=array[0..MaxInstrumentFilter-1] of TSynthInstrumentFilterData;

     PSynthInstrumentDistortion=^TSynthInstrumentDistortion;
     TSynthInstrumentDistortion=packed record
      Mode:byte;
      Gain:byte;
      Dist:byte;
      Rate:byte;
      Carry:boolean;
     end;

     TSynthInstrumentDistortions=array[0..MaxInstrumentDistortion-1] of TSynthInstrumentDistortion;

     PSynthInstrumentDistortionData=^TSynthInstrumentDistortionData;
     TSynthInstrumentDistortionData=record
      Phases:array[0..1] of single;
      PhaseIncrement:single;
      SavedSamples:array[0..1] of single;
      OverdriveLeft,OverdriveRight:single;
     end;

     TSynthInstrumentDistortionDatas=array[0..MaxInstrumentDistortion-1] of TSynthInstrumentDistortionData;

{    PSynthInstrumentGate=^TSynthInstrumentGate;
     TSynthInstrumentGate=PACKED RECORD
      Active:BOOLEAN;
      Pattern:WORD;
      OnVolume:BYTE;
      OffVolume:BYTE;
      BPM:BYTE;
      Carry:BOOLEAN;
     END;}

{    PSynthInstrumentChannelFilter=^TSynthInstrumentChannelFilter;
     TSynthInstrumentChannelFilter=packed record
      Mode:byte;
      CutOff:byte;
      Resonance:byte;
      Volume:byte;
      Amplify:shortint;
      Cascaded:boolean;
      Carry:boolean;
      MinHz:word;
      MaxHz:word;
     end;}

     PSynthDelay=^TSynthDelay;
     TSynthDelay=packed record
      Active:boolean;
      ClockSync:boolean;
      Wet:byte;
      Dry:byte;
      TimeLeft:byte;
      FeedBackLeft:shortint;
      TimeRight:byte;
      FeedBackRight:shortint;
      Fine:boolean;
      Recursive:boolean;
     end;

     PSynthDelayData=^TSynthDelayData;
     TSynthDelayData=record
      IndexLeft,IndexRight:longint;
      DelayLeft,DelayRight:single;
      LenLeft,LenRight:longint;
      CoefLeft,CoefRight:single;
      x1Left,x1Right:single;
      y1Left,y1Right:single;
      Fine:longbool;
     end;

     PSynthChorusFlanger=^TSynthChorusFlanger;
     TSynthChorusFlanger=packed record
      Active:boolean;
      Fine:boolean;
      Count:byte;
      Wet:byte;
      Dry:byte;
      TimeLeft:byte;
      FeedBackLeft:shortint;
      LFORateLeft:byte;
      LFODepthLeft:byte;
      LFOPhaseLeft:byte;
      TimeRight:byte;
      FeedBackRight:shortint;
      LFORateRight:byte;
      LFODepthRight:byte;
      LFOPhaseRight:byte;
      Carry:boolean;
     end;

     PSynthChorusFlangerData=^TSynthChorusFlangerData;
     TSynthChorusFlangerData=record
      IndexLeft,IndexRight:longint;
      LFOPhaseLeft,LFOPhaseRight:single;
     end;

     PSynthCompressor=^TSynthCompressor;
     TSynthCompressor=packed record
      Mode:byte;
      Threshold:word;
      Ratio:byte;
      WindowSize:word;
      SoftHardKnee:byte;
      Attack:word;
      Release:word;
      OutGain:smallint;
      AutoGain:boolean;
      SideIn:byte;
     end;

     PSynthCompressorData=^TSynthCompressorData;
     TSynthCompressorData=record
      EnvelopeLeft,GainLeft:single;
      EnvelopeRight,GainRight:single;
      RMSPeakValueLeft,RMSPeakValueRight:single;
      RMSStateValueLeft,RMSStateValueRight:double;
      WindowCoefFactor:single;
      PeakBuffer:PSynthBufferSamples;
      PeakBufferPosition:longint;
      RMSSumLeft,RMSSumRight:single;
      RMSNewSumLeft,RMSNewSumRight:single;
      WindowSamples:longint;
      InvWindowSamples:single;
      WindowSize:longint;
      WindowMask:longint;
     end;

     PSynthPitchShifter=^TSynthPitchShifter;
     TSynthPitchShifter=packed record
      Active:boolean;
      Tune:shortint;
      FineTune:shortint;
     end;

     PSynthPitchShifterData=^TSynthPitchShifterData;
     TSynthPitchShifterData=record
      Buffer:TSynthPitchShifterBuffer;
      P1:longword;
      P2:longword;
      InputPointer:longword;
      OutputIncrement:longword;
     end;

     PSynthEQ=^TSynthEQ;
     TSynthEQ=packed record
      Active:boolean;
      Mode:byte;
      PreAmp:byte;
      Octave:longint;
      Cascaded:boolean;
      AddCascaded:boolean;
      BandHz:array[0..MaxEQBands-1] of word;
      Gain:array[0..MaxEQBands-1] of byte;
     end;

     TSynthEQDataCoefficients=record
      Beta:single;
      Alpha:single;
      Gamma:single;
     end;

     TSynthEQDataHistory=record
      x:array[0..2] of single;
      y:array[0..2] of single;
     end;

     PSynthEQBandData=^TSynthEQBandData;
     TSynthEQBandData=record
      BandHz:longint;
      Gain:longint;
      GainValue:single;
      Coefficients:TSynthEQDataCoefficients;
      History:array[0..1,0..1] of TSynthEQDataHistory;
     end;

     PSynthEQBandsData=^TSynthEQBandsData;
     TSynthEQBandsData=array[0..MaxEQBands-1] of TSynthEQBandData;

     PSynthEQData=^TSynthEQData;
     TSynthEQData=record
      Bands:TSynthEQBandsData;
      Mode:longint;
      PreAmp:longint;
      PreAmpValue:single;
      i:longint;
      j:longint;
      k:longint;
     end;

     TSynthInstrumentSpeech=packed record
      Active:boolean;
      FrameLength:byte;
      Speed:byte;
      TextNumber:byte;
      Color:shortint;
      NoiseGain:byte;
      Gain:byte;
      F4:word;
      F5:word;
      F6:word;
      B4:word;
      B5:word;
      B6:word;
      CascadeGain:byte;
      ParallelGain:byte;
      AspirationGain:byte;
      FricationGain:byte;
     end;

     PSynthInstrumentModulationMatrixItem=^TSynthInstrumentModulationMatrixItem;
     TSynthInstrumentModulationMatrixItem=packed record
      Source,SourceIndex,SourceFlags,SourceMode,Target,TargetIndex,Polarity:byte;
      Amount:shortint;
     end;
     TSynthInstrumentModulationMatrix=array[0..MaxModulationMatrixItems-1] of TSynthInstrumentModulationMatrixItem;

     TSynthInstrumentVoiceOrder=array[voDistortion..voFilter] of byte;

     TSynthInstrumentChannelOrder=array[coDistortion..coEQ] of byte;

     TSynthChannelLFO=packed record
      Active:boolean;
      Rate:byte;
     end;

     TSynthDelays=array[0..MaxInstrumentDelay-1] of TSynthDelay;

     TSynthDelayDatas=array[0..MaxInstrumentDelay-1] of TSynthDelayData;

     TSynthInstrumentLink=record
      Active:boolean;
      Channel:shortint;
      ProgramNr:shortint;
     end;

     TSynthTuningTable=array[0..127] of double;

     TSynthTuningTables=array[0..127,0..127] of TSynthTuningTable;
     
     PSynthInstrument=^TSynthInstrument;
     TSynthInstrument=packed record
      Volume:byte;
      Transpose:shortint;
      Oscillator:TSynthInstrumentOscillators;
      ADSR:TSynthInstrumentADSRs;
      Envelope:TSynthInstrumentEnvelopes;
      LFO:TSynthInstrumentLFOs;
      Filter:TSynthInstrumentFilters;
      VoiceDistortion:TSynthInstrumentDistortions;
      ChannelDistortion:TSynthInstrumentDistortions;
      ChannelFilter:TSynthInstrumentFilters;
      ChannelDelay:TSynthDelays;
      ChannelChorusFlanger:TSynthChorusFlanger;
      ChannelCompressor:TSynthCompressor;
      ChannelSpeech:TSynthInstrumentSpeech;
      ChannelPitchShifter:TSynthPitchShifter;
      ChannelEQ:TSynthEQ;
      ChannelLFO:TSynthChannelLFO;
      ChannelVolume:byte;
      GlobalOutput:byte;
      GlobalReverb:byte;
      GlobalDelay:byte;
      GlobalChorusFlanger:byte;
      MaxPolyphony:byte;
      Carry:boolean;
      VoiceOrder:TSynthInstrumentVoiceOrder;
      ChannelOrder:TSynthInstrumentChannelOrder;
      Link:TSynthInstrumentLink;
      Controller7BitFlags:longword;
      UseTuningTable:boolean;
      ModulationMatrixItems:byte;
      ModulationMatrix:TSynthInstrumentModulationMatrix;
      TuningTable:TSynthTuningTable;
     end;

     PSynthInstruments=^TSynthInstruments;
     TSynthInstruments=array[0..MaxInstruments-1] of TSynthInstrument;

     PSynthEndFilter=^TSynthEndFilter;
     TSynthEndFilter=packed record
      Active:boolean;
      LowCut:byte;
      HighCut:byte;
     end;

     PSynthEndFilterData=^TSynthEndFilterData;
     TSynthEndFilterData=packed record
      FDL,FDR:array[1..4] of TSynthFloatValue;
     end;

     PSynthReverb=^TSynthReverb;
     TSynthReverb=packed record
      Active:boolean;
      PreDelay:byte;
      CombFilterSeparation:byte;
      RoomSize:byte;
      FeedBack:byte;
      Absortion:byte;
      Dry:byte;
      Wet:byte;
      NumberOfAllPassFilters:byte;
     end;

     PSynthReverbData=^TSynthReverbData;
     TSynthReverbData=packed record
      AllPassBuffer:array[0..MaxReverbAllPassFilters-1] of PSynthBufferSamples;
      Counter:array[0..MaxReverbAllPassFilters-1,0..3] of longint;
      LastLowPassLeft:single;
      LastLowPassRight:single;
      LeftBuffer:PSynthFloatValues;
      RightBuffer:PSynthFloatValues;
      LeftDelayedCounter:longint;
      RightDelayedCounter:longint;
      LeftCounter:longint;
      RightCounter:longint;
      Ready:boolean;
     end;

     TSynthClock=packed record
      BPM:byte;
      TPB:byte;
     end;

     TSynthGlobalOrder=array[goPITCHSHIFTER..goCOMPRESSOR] of byte;

     TSynthGlobalVoices=packed record
      Count:longint;
     end;

     TSynthGlobal=packed record
      Oversample:byte;
      FineOversample:boolean;
      FineSincOversample:boolean;
      OversampleOrder:byte;
      RampingLen:word;
      RampingMode:byte;
      Clipping:boolean;
      Reverb:TSynthReverb;
      Delay:TSynthDelay;
      ChorusFlanger:TSynthChorusFlanger;
      PitchShifter:TSynthPitchShifter;
      EndFilter:TSynthEndFilter;
      EQ:TSynthEQ;
      Compressor:TSynthCompressor;
      Order:TSynthGlobalOrder;
      Clock:TSynthClock;
      Voices:TSynthGlobalVoices;
      FinalCompressor:TSynthCompressor;
     end;

     TSynthGlobalData=packed record
      Reverb:TSynthReverbData;
      Delay:TSynthDelayData;
      ChorusFlanger:TSynthChorusFlangerData;
      PitchShifter:TSynthPitchShifterData;
      EndFilter:TSynthEndFilterData;
      EQ:TSynthEQData;
      Compressor:TSynthCompressorData;
      DelayBuffer:PSynthBufferSample;
      ChorusFlangerBuffer:PSynthBufferSample;
      CompressorBuffer:PSynthBufferSample;
      FinalCompressor:TSynthCompressorData;
      FinalCompressorBuffer:PSynthBufferSample;
     end;

     PSynthEnvelopeNode=^TSynthEnvelopeNode;
     TSynthEnvelopeNode=packed record
      Time:word;
      Value:byte;
      Interpolation:byte;
     end;

     PSynthEnvelopeNodes=^TSynthEnvelopeNodes;
     TSynthEnvelopeNodes=array[word] of TSynthEnvelopeNode;

     PSynthEnvelope=^TSynthEnvelope;
     TSynthEnvelope=packed record
      Nodes:PSynthEnvelopeNodes;
      NodesAllocated:longint;
      NodesCount:word;
      NegValue:byte;
      PosValue:byte;
      LoopStart:shortint; // if 8 bit on = Loop inactive
      LoopEnd:shortint; // if 8 bit on = Loop inactive
      SustainLoopStart:shortint; // if 8 bit on = Sustain Loop inactive
      SustainLoopEnd:shortint; // if 8 bit on = Sustain Loop inactive
     end;
     TSynthEnvelopes=array[0..MaxInstruments-1,0..MaxInstrumentEnvelopes-1] of TSynthEnvelope;

     TSynthSamples=array[0..MaxInstruments-1,0..MaxSamples-1] of TSynthSample;

     PSynthRPN=^TSynthRPN;
     TSynthRPN=packed record
      Parameter:longint;
      NParameter:longint;
      Data:longint;
     end;

     TSynthNRPNControllers=array[byte] of word;

     TSynthControllers=array[byte] of byte;

     TSynthChannelLFOData=record
      Phase:single;
      PhaseIncrement:single;
     end;

     PSynthChannel=^TSynthChannel;
     TSynthChannel=record
      Number:longword;
      Instrument:PSynthInstrument;
      LastInstrument:PSynthInstrument;
      LastVoiceInstrument:PSynthInstrument;
      KeyOff:longbool;
      LastVoice:pointer;
      NewestVoice:pointer;
      DelayBuffer:array[0..MaxInstrumentDelay-1] of PSynthBufferSample;
      ChorusFlangerBuffer:PSynthBufferSample;
      CompressorBuffer:PSynthBufferSample;
      Buffer:PSynthBufferSample;
      NRPNControllers:TSynthNRPNControllers;
      Controllers:TSynthControllers;
      WorkControllers:TSynthControllers;
      NRPNSelect:longint;
      OmniMode:boolean;
      PolyMode:boolean;
      Bank:longint;
      Patch:longint;
      MainVolume:longint;
      Balance:longint;
      Panning:longint;
      Expression:longint;
      Modulation:longint;
      Breath:longint;
      PitchBendDepthSemitones:longint;
      PitchBendDepthCents:longint;
      PitchBend:longint;
      PortamentoTime:longint;
      FootPedal:longint;
      HoldPedal:boolean;
      PortamentoPedal:boolean;
      SostenutoPedal:boolean;
      SoftPedal:boolean;
      LegatoPedal:boolean;
      Hold2Pedal:boolean;
      RPN:TSynthRPN;
      Last:TSynthBufferSample;
      LastVolumeFactor:single;
      ChannelDistortionData:TSynthInstrumentDistortionDatas;
      ChannelFilterData:TSynthInstrumentFiltersData;
      ChannelDelayData:TSynthDelayDatas;
      ChannelChorusFlangerData:TSynthChorusFlangerData;
      ChannelCompressorData:TSynthCompressorData;
      ChannelPitchShifterData:TSynthPitchShifterData;
      ChannelEQData:TSynthEQData;
      ChannelLFOData:TSynthChannelLFOData;
      RampingVolume,RampingExpression,RampingPanning,RampingBreath,RampingModulation,RampingPortamentoTime,RampingFootPedal,
      RampingHoldPedal,RampingPortamentoPedal,RampingSostenutoPedal,RampingSoftPedal,RampingLegatoPedal,RampingHold2Pedal:TSynthRamping;
      RampingControllers:array[0..127] of TSynthRamping;
      RampingNRPNControllers:array[0..255] of TSynthRamping;
      SpeechInstance:TSynthSpeechInstanceData;
      SideIn:longword;
      Ready:longbool;
      TuningBank:longint;
      TuningProgram:longint;
      TuningTable:TSynthTuningTable;
      CoarseTuning:longint;
      FineTuning:longint; 
      Voices:array[0..NumberOfVoices*2] of pointer;
      CountVoices:longint;
      MustHaveBuffer:boolean;
      HasBuffer:boolean;
      HaveAUXReverb:boolean;
      HaveAUXDelay:boolean;
      HaveAUXChorusFlanger:boolean;
      Peaks:TSynthBufferSample;
      OutPeaks:TSynthBufferSample;
     end;

     TSynthChannels=array[0..NumberOfChannels-1] of TSynthChannel;

     PSynthVoice=^TSynthVoice;
     TSynthVoice=record
      Active:boolean;
      Carry:boolean;
      WaitForClickRemoval:boolean;
      LifeTime:longword;
      Channel:PSynthChannel;
      Instrument:PSynthInstrument;
      LastInstrument:PSynthInstrument;     
      OscillatorData:TSynthInstrumentOscillatorsData;
      ADSRData:TSynthInstrumentADSRsData;
      EnvelopeData:TSynthInstrumentEnvelopesData;
      LFOData:TSynthInstrumentLFOsData;
      FilterData:TSynthInstrumentFiltersData;
      VoiceDistortionData:TSynthInstrumentDistortionDatas;
      FloatNote:single;
      Note:longint;
      Velocity:longint;
      KeyOffVelocity:longint;
      AfterTouch:longint;
      Holding:boolean;
      Sostenutoing:boolean;
      KeyOff:boolean;
      Last:TSynthBufferSample;
      TempLast:TSynthBufferSample;
      NeedClickRemoval:boolean;
      RampingNote:TSynthRamping;
      RampingVelocity:TSynthRamping;
      RampingKeyOffVelocity:TSynthRamping;
      RampingAfterTouch:TSynthRamping;
      Patch:longint;
      Number:longint;
     end;

     TSynthVoices=array[0..NumberOfVoices-1] of TSynthVoice;

     TSynthProcessBuffers=array[0..MaxProcessBuffers-1] of TSynthWorkSampleBuffer;

     PSynthSINCSubArray=^TSynthSINCSubArray;
     TSynthSINCSubArray=PACKED ARRAY[0..SINC16_WIDTH-1] OF TSynthFloatValue;

     PSynthSINCArray=^TSynthSINCArray;
     TSynthSINCArray=PACKED ARRAY[0..SINC16_LUTLEN-1] OF TSynthSINCSubArray;

     PSynthInformations=^TSynthInformations;
     TSynthInformations=record
      TrackName:pchar;
      Author:pchar;
      Comments:pchar;
     end;

     PSynthTrack=^TSynthTrack;
     PSynthTrackSampleInstance=^TSynthTrackSampleInstance;

     PSynthTrackSampleLoop=^TSynthTrackSampleLoop;
     TSynthTrackSampleLoop=record
      Mode:longint;
      StartSample:longint;
      EndSample:longint;
     end;

     PSynthTrackSample=^TSynthTrackSample;
     TSynthTrackSample=record
      Previous,Next:PSynthTrackSample;
      Parent:PSynthTrack;
      TrackSampleInstanceRoot,TrackSampleInstanceLast:PSynthTrackSampleInstance;
      Samples:longint;
      Data:PSynthBufferSample;
      Loop:TSynthTrackSampleLoop;
      SustainLoop:TSynthTrackSampleLoop;
      LastLeft:single;
      LastRight:single;
     end;

     TSynthTrackSampleInstance=record
      Previous,Next:PSynthTrackSampleInstance;
      Parent:PSynthTrackSample;
      Active:boolean;
      KeyOff:boolean;
      Backwards:boolean;
      Position:int64;
      PositionEx:int64;
      Increment:int64;
      Panning:single;
      Volume:single;
      VolumeLeft:single;
      VolumeRight:single;
      DestVolumeLeft:single;
      DestVolumeRight:single;
      PanningVolumeLeft:single;
      PanningVolumeRight:single;
      VolumeRampingRemain:longint;
      VolumeRampingLeft:single;
      VolumeRampingRight:single;
      LastLeft:single;
      LastRight:single;
     end;

     PSynthBufferHook=^TSynthBufferHook;
     TSynthBufferHook=procedure(Track:PSynthTrack); stdcall;

     PSynthEventHook=^TSynthEventHook;
     TSynthEventHook=procedure(Track:PSynthTrack;Event:PSynthEvent); stdcall;

     TSynthChorusSINCTable=array[0..CHORUS_INTERPOLATION_SAMPLES-1,0..CHORUS_INTERPOLATION_SUBSAMPLES-1] of single;

     TSynthJobMode=(sjmCHANNELINIT,sjmVOICE,sjmCHANNELFINALIZE);

     PSynthJob=^TSynthJob;
     TSynthJob=record
      Mode:TSynthJobMode;
      Samples:longint;
      NewTick:boolean;
      Track:PSynthTrack;
      Channel:PSynthChannel;
      Voice:PSynthVoice;
     end;

     TSynthJobs=array[0..((NumberOfChannels+NumberOfVoices)*2)-1] of TSynthJob;

     PSynthJobManager=^TSynthJobManager;

     PSynthJobThread=^TSynthJobThread;
     TSynthJobThread=record
      Track:PSynthTrack;
      ThreadNumber:longint;
      ThreadHandle:THandle;
      ThreadID:{$ifdef fpc}THandle{$else}TThreadID{$endif};
      Event:{$ifdef fpc}PRTLEvent{$else}THandle{$endif};
      DoneEvent:{$ifdef fpc}PRTLEvent{$else}THandle{$endif};
     end;

     TSynthJobThreads=array[0..MaxThreads-1] of TSynthJobThread;

     TSynthJobManager=record
      Jobs:TSynthJobs;
      JobQueueIndex:longint;
      CountJobs:longint;
      Threads:TSynthJobThreads;
      CountThreads:longint;
{$ifdef win32}
      DoneEventHandles:array[0..MaxThreads-1] of THandle;
{$endif}
     end;

     PSynthWorkBuffers=^TSynthWorkBuffers;
     TSynthWorkBuffers=packed record
      GlobalReverbBuffer:TSynthWorkSampleBuffer;
      GlobalDelayBuffer:TSynthWorkSampleBuffer;
      GlobalChorusFlangerBuffer:TSynthWorkSampleBuffer;
      SilenceBuffer:TSynthWorkSampleBuffer;
      ChannelBuffer:array[0..NumberOfChannels-1] of TSynthWorkSampleBuffer;
{$ifdef MultiOutput}
      ChannelOutRouteBuffer:array[0..NumberOfChannels-1] of TSynthWorkSampleBuffer;
{$endif}
      VoiceBuffer:array[0..NumberOfVoices-1] of TSynthWorkSampleBuffer;
      OutputVoiceBuffer:array[0..MaxThreads-1] of TSynthWorkSampleBuffer;
      FilterBuffer:array[0..MaxThreads-1] of TSynthWorkSampleBuffer;
      FilterTempBuffer:array[0..MaxThreads-1] of TSynthWorkSampleBuffer;
      FilterOutputBuffer:array[0..MaxThreads-1] of TSynthWorkSampleBuffer;
      AUXReverbBuffer:array[0..NumberOfChannels-1] of TSynthWorkSampleBuffer;
      AUXDelayBuffer:array[0..NumberOfChannels-1] of TSynthWorkSampleBuffer;
      AUXChorusFlangerBuffer:array[0..NumberOfChannels-1] of TSynthWorkSampleBuffer;
      ProcessBuffers:array[0..MaxThreads-1] of TSynthProcessBuffers;
      ADSRBuffers:array[0..MaxThreads-1,0..MaxInstrumentADSR-1] of TSynthWorkBuffer;
      EnvelopeBuffers:array[0..MaxThreads-1,0..MaxInstrumentEnvelopes-1] of TSynthWorkBuffer;
      LFOBuffers:array[0..MaxThreads-1,0..MaxInstrumentLFO-1] of TSynthWorkBuffer;
      ModulationMatrixBuffers:array[0..MaxThreads-1,0..MaxModulationMatrixBuffers-1] of TSynthWorkBuffer;
      TempModulationMatrixBuffers:array[0..MaxThreads-1] of TSynthWorkBuffer;
      PitchBuffers:array[0..MaxThreads-1] of TSynthWorkBuffer;
      GlideBuffer:array[0..MaxThreads-1] of TSynthWorkBuffer;
      MemoryBuffers:array[0..MaxThreads-1,0..MaxModulationMatrixMemory-1] of TSynthWorkBuffer;
      VoiceNoteBuffer:array[0..NumberOfVoices-1,0..1] of TSynthWorkBuffer;
      VoiceVelocityBuffer:array[0..NumberOfVoices-1,0..1] of TSynthWorkBuffer;
      VoiceKeyOffVelocityBuffer:array[0..NumberOfVoices-1,0..1] of TSynthWorkBuffer;
      VoiceAfterTouchBuffer:array[0..NumberOfVoices-1,0..1] of TSynthWorkBuffer;
      ChannelVolumeBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelExpressionBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelPanningBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelBreathBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelModulationBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelPortamentoTimeBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelFootPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelHoldPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelPortamentoPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelSostenutoPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelSoftPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelLegatoPedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelHold2PedalBuffer:array[0..NumberOfChannels-1,0..1] of TSynthWorkBuffer;
      ChannelControllersBuffer:array[0..NumberOfChannels-1,0..127,0..1] of TSynthWorkBuffer;
      ChannelNRPNControllersBuffer:array[0..NumberOfChannels-1,0..255,0..1] of TSynthWorkBuffer;
      Values7BitBuffers:array[0..127] of TSynthWorkBuffer;
      Values7BitSqrBuffers:array[0..127] of TSynthWorkBuffer;
      Values8BitBuffers:array[0..255] of TSynthWorkBuffer;
      Values8BitSqrBuffers:array[0..255] of TSynthWorkBuffer;
      Values8BitExtBuffers:array[0..255] of TSynthWorkBuffer;
      Values8BitExtSqrBuffers:array[0..255] of TSynthWorkBuffer;
      Values14BitBuffers:array[0..127] of TSynthWorkBuffer;
      Values14BitSqrBuffers:array[0..127] of TSynthWorkBuffer;
      ValuesRescaleBuffers:array[0..255] of TSynthWorkBuffer;
      ValuesRescaleSqrBuffers:array[0..25] of TSynthWorkBuffer;
      ValuesInvRescaleBuffers:array[0..255] of TSynthWorkBuffer;
      ValuesInvRescaleSqrBuffers:array[0..255] of TSynthWorkBuffer;
      HardSyncBuffer:array[0..MaxThreads-1,-2..8] of TSynthWorkBooleanBuffer;
     end;

     TSynthTrack=record
      LinkPrevious,LinkNext,LinkRoot,LinkLast,LinkParent:PSynthTrack;
      TrackSampleRoot,TrackSampleLast:PSynthTrackSample;
{$ifdef WIN32Plain}
      Frequency:longword;
      OutputBufferSize:longword;
      WaveFormat:TWaveFormatEx;
      WaveHandle:longword;
      WaveOutHandle:longword;
      WaveHandler:array[0..3] of PWAVEHDR;
      BufferCounter:longword;
      ToFill:longword;
      ThreadHandle:THandle;
      ThreadID:THandle;
      ThreadCriticalSection:TRTLCriticalSection;
      ThreadTerminated:longbool;
      IsSampleAccurate:boolean;
      LastGetPositionSample:longword;
      AddGetPositionSample:longword;
      FirstBufferTime:longword;
      FirstBufferSample:longword;
      FirstBuffer:boolean;
{$endif}
      Active:longbool;
      ThreadIsWorking:longbool;
      ThreadsTerminated:longbool;
      Threads:longint;
      JobManager:TSynthJobManager;
      ThreadPlay:boolean;
      SoundOutput:boolean;
      Informations:TSynthInformations;
      EventQuery:PSynthEvent;
      CurrentEvent:PSynthEvent;
      LastEvent:PSynthEvent;
//    PluckedStrings:TSynthPluckedStrings;
      PluckedStringBuffers:TSynthPluckedStringBuffers;
      Channels:TSynthChannels;
      Voices:TSynthVoices;
      Global:TSynthGlobal;
      Instruments:TSynthInstruments;
      Samples:TSynthSamples;
      Envelopes:TSynthEnvelopes;
      SpeechSegmentLists:TSynthSpeechSegmentLists;
      GlobalData:TSynthGlobalData;
      DoAudioProcessing:boolean;
      LinkContentDestroy:boolean;
      ProcessedSamples:int64;
      Time:longword;
      Tempo:longint;
      DifferenceTicksIncrement:longint;
      IntervalSamples:int64;
      SamplesRemain:int64;
      BaseSampleRate:longint;
      InternalSampleRate:longint;
      DelayBufferSize:longint;
      DelayBufferMask:longint;
      InternalSampleRateRampingFactor:double;//single;
      InternalSampleRateFactor:double;//single;
      InternalHalfSampleRateFactor:double;//single;
      InternalBufferSamples:longint;
      BaseBufferSamples:longint;
      LastOversampling:longint;
      LastOversamplingOrder:longint;
      LastFineOversampling:boolean;
      FineOversampling:boolean;
      FineSincOversampling:boolean;
      OversamplingOrder:longint;
      Oversampling:longint;
      OversamplingFactor:longint;
      InternalSamplingFactor:longint;
      TicksPerQuarterNote:longint;
      WorkBuffers:PSynthWorkBuffers;
      Buffer:PSynthBufferSample;
      OversampleBuffer:PSynthBufferSample;
{$ifdef MultiOutput}
      ChannelBuffer:array[0..NumberOfChannels-1] of PSynthBufferSample;
{$endif}
      ADSRBuffersActive:array[0..MaxThreads-1,0..MaxInstrumentADSR-1] of boolean;
      EnvelopeBuffersActive:array[0..MaxThreads-1,0..MaxInstrumentEnvelopes-1] of boolean;
      LFOBuffersActive:array[0..MaxThreads-1,0..MaxInstrumentLFO-1] of boolean;
      ModulationMatrixMemoryBuffers:array[0..MaxThreads-1,0..MaxModulationMatrixMemory-1] of PSynthFloatValue;
      VoiceBufferOut:array[0..NumberOfVoices-1] of PSynthBufferSample;
      BaseClickRemovalFactor:single;
      ClickRemovalFactor:single;
      F1D0Buffer:PSynthFloatValue;
      F0D5BUffer:PSynthFloatValue;
      ZeroBuffer:PSynthFloatValue;
      RampingSamples:longint;
      CurrentRampingSamples:longint;
      SINCTable:TSynthSINCArray;
      PitchShifterFadeBuffer:TSynthPitchShifterFadeBuffer;
      Played:boolean;
      Volume:single;
      GlobalLFOPhase:single;
      GlobalLFOPhaseIncrement:single;
      BufferStartHook:TSynthBufferHook;
      BufferEndHook:TSynthBufferHook;
      EventHook:TSynthEventHook;
      UseMultithreading:boolean;
      UseSSE:boolean;
      Looping:boolean;
      ClipSamples:boolean;
      AGC:boolean;
      AGCFactor:single;
      AGCAttackFactor:single;
      AGCReleaseFactor:single;
      Seed:longword;
      OmniMode:boolean;
      OmniChannel:longint;
      GeneralMIDIMode:longint;
      VoiceAllocationAlgorithm:longint;
      MasterVolume:longint;
      MasterBalance:longint;
      MasterCoarseTuning:single;
      MasterFineTuning:single;
{$ifndef vsti}
      BalancedRootEvent:TSynthEvent;
{$endif}
      BandlimitedSaw:TBandlimitedWaveTables;
      BandlimitedParabola:TBandlimitedWaveTables;
      BandlimitedSineLUT:TBandlimitedWaveTable;
      BandlimitedDoubleSineLUT:TBandlimitedDoubleWaveTable;
      BandlimitedMap:TBandlimitedMap;
      DownsampleSINC:PSingles;
      DownsampleSINCRingBuffer:array[-1..{$ifdef MultiOutput}NumberOfChannels-1{$else}-1{$endif}] of PSynthBufferSamples;
      DownsampleSINCRingBufferIndex:array[-1..{$ifdef MultiOutput}NumberOfChannels-1{$else}-1{$endif}] of longint;
      DownsampleSINCRingBufferLen:longint;
      DownsampleSINCRingBufferMask:longint;
      DownsampleSINCLen:longint;
      DownsampleSINCPoints:longint;
      Oversamplers:array[-1..{$ifdef MultiOutput}NumberOfChannels-1{$else}-1{$endif},0..1] of TSynthOversampler;
      ChorusSINCTable:TSynthChorusSINCTable;
      ChorusSamples:longint;
      ChorusSamplesMask:longint;
      POTBufferSize:longint;
      POTBufferMask:longint;
      ScanPeaks:boolean;
      ScanPeakFactor:single;
      HasReverb:boolean;
      HasDelay:boolean;
      HasChorusFlanger:boolean;
{$ifdef vsti}
      Master:boolean;
{$else}
      EventPool:TSynthEventPool;
{$endif}
{$ifdef textdebug}
      TextDebug:text;
      TimeDebug:int64;
      DebugWait:boolean;
{$endif}
      ChannelInitialPrograms:array[0..NumberOfChannels-1] of byte;
      TuningTables:TSynthTuningTables;
     end;

     TGetExternalPointer=function(Name:pansichar):pointer;

     TSetPublicPointer=procedure(Name:pansichar;ThePointer:pointer);

function ComparePAnsiChar(a,b:pansichar):boolean; register;

function LinkTRI(RawCode:pointer;RawCodeSize:longint;var CodeSize:longint;var EntryPoint:pointer;GetExternalPointer:TGetExternalPointer;SetPublicPointer:TSetPublicPointer):pointer;

procedure GetMemAligned(var p;Size:longint);
procedure FreeMemAligned(const p);

function SynthLockCreate:pointer;
procedure SynthLockDestroy(var Lock:pointer);
procedure SynthLockEnter(Lock:pointer);
procedure SynthLockLeave(Lock:pointer);

procedure SynthPadSynthGenerateHarmonics(var PadSynth:TSynthSamplePadSynth);

procedure SynthResizeEnvelope(Envelope:PSynthEnvelope;Count:longint);

function SoftTRUNCEx(FloatValue:single):longint;
function SoftTRUNC(FloatValue:single):longint;
function SoftTRUNCDSP(FloatValue:single):longint;

function FastTRUNC(FloatValue:single):longint;

function LOG10(X:single):single;

function MIDITimeCentsToMilliseconds(TimeCents:longint):longint;
function MIDIRelativeGainToLinear(Gain:longint):longint;
function MIDIRelativeLinearToGain(Gain:longint):longint;
function MIDIToLinearVolume(MIDIVolume:longword):longword;
function MIDIToLinearVolumeFloat(MIDIVolume:longword):single;

function SynthEnvelopeGetValue(Envelope:PSynthEnvelope;Time:double):single;
procedure SynthEnvelopeSort(Envelope:PSynthEnvelope;NodeNumber:pointer=nil);

function SynthADPCMIMADecompressSample(var ADPCMIMAState:TSynthADPCMIMAState;nibble:byte):longint;
{$ifdef VSTi}
function SynthADPCMIMACompressSample(var ADPCMIMAState:TSynthADPCMIMAState;sample:smallint):byte;
{$endif}

{$ifndef csdk}
procedure SynthCleanBuffer(Buffer:pointer;Samples:longint); 
{$endif}
{
function SynthGetBandlimitedWavetable(Track:PSynthTrack;const BandlimitedWaveTables:TBandlimitedWaveTables;Phase,PhaseIncrement:single):single;
function SynthGetBandlimitedWavetableFast(Track:PSynthTrack;const BandlimitedWaveTables:TBandlimitedWaveTables;Phase,PhaseIncrement:single):single;
 }
procedure SynthInitSample(Track:PSynthTrack;Sample:PSynthSample);
procedure SynthInitSamples(Track:PSynthTrack);

procedure SynthInitEQ(EQ:PSynthEQ);
procedure SynthInitEQISO(EQ:PSynthEQ);

procedure SynthFFTCreate(var Instance:TSynthFFT;const AFrameSize:longint);
procedure SynthFFTDestroy(var Instance:TSynthFFT);
procedure SynthFFTFFT(var Instance:TSynthFFT;FFTData,WaveData:PSynthFFTValueArray);
procedure SynthFFTIFFT(var Instance:TSynthFFT;FFTData,WaveData:PSynthFFTValueArray);
procedure SynthFFTRescale(var Instance:TSynthFFT;WaveData:PSynthFFTValueArray);

{$ifdef csdk}
function SynthGetTrackSize:longword; stdcall;
{$endif}

function SynthCreate(SampleRate,BufferSamples:longint;ThreadPlay:longbool=true;SoundOutput:longbool=true):PSynthTrack; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthDestroy(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}

procedure SynthInitInstrument(Instrument:PSynthInstrument);

procedure SynthInit(Track:PSynthTrack;SampleRate,BufferSamples:longint;ThreadPlay:longbool=true;SoundOutput:longbool=true); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthReinit(Track:PSynthTrack;SampleRate,BufferSamples:longint); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifdef VSTi}
procedure SynthConvertOldToNewUnits(Track:PSynthTrack);
{$endif}
{$ifdef VSTi}
{$ifdef BR808SPEECH}
procedure SynthSpeechConvertSpeechText(Track:PSynthTrack;InstrumentNumber,SpeechTextNumber:longint;InputText:string);
{$endif}
{$endif}
procedure SynthDone(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthLink(Track,ToTrack:PSynthTrack); {$ifdef csdk}stdcall;{$endif}
procedure SynthUnlink(Track:PSynthTrack); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetAGC(Track:PSynthTrack;AGC:longbool); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetClipping(Track:PSynthTrack;Clipping:longbool); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetLooping(Track:PSynthTrack;Looping:longbool); {$ifdef csdk}stdcall;{$endif}
function SynthGetTrackName(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthGetTrackAuthor(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthGetTrackComments(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthGetBuffer(Track:PSynthTrack):pointer; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthGetRootEvent(Track:PSynthTrack):PSynthEvent; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthSetBufferStartHook(Track:PSynthTrack;Hook:TSynthBufferHook); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthSetBufferEndHook(Track:PSynthTrack;Hook:TSynthBufferHook); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthSetEventHook(Track:PSynthTrack;Hook:TSynthEventHook); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthCreateTrackSample(Track:PSynthTrack;LoopMode:longint=slNONE;LoopStart:longint=0;LoopEnd:longint=0;SustainLoopMode:longint=slNONE;SustainLoopStart:longint=0;SustainLoopEnd:longint=0):PSynthTrackSample; {$ifdef csdk}stdcall;{$endif}
procedure SynthDestroyTrackSample(TrackSample:PSynthTrackSample); {$ifdef csdk}stdcall;{$endif}
function SynthCreateTrackSampleInstance(TrackSample:PSynthTrackSample):PSynthTrackSampleInstance; {$ifdef csdk}stdcall;{$endif}
procedure SynthDestroyTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall;{$endif}
procedure SynthStartTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall;{$endif}
procedure SynthStopTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall;{$endif}
procedure SynthKeyOffTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall;{$endif}
procedure SynthUpdateTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetTrackSampleInstanceVolume(TrackSampleInstance:PSynthTrackSampleInstance;Volume:single); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetTrackSampleInstancePanning(TrackSampleInstance:PSynthTrackSampleInstance;Panning:single); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetTrackSampleInstancePanningLeftRight(TrackSampleInstance:PSynthTrackSampleInstance;PanningLeft,PanningRight:single); {$ifdef csdk}stdcall;{$endif}
procedure SynthSetTrackSampleInstancePitch(TrackSampleInstance:PSynthTrackSampleInstance;Pitch:single); {$ifdef csdk}stdcall;{$endif}
procedure SynthResetVoices(Track:PSynthTrack);{$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthResetChannels(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthReset(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthCheckDelayBuffers(Track:PSynthTrack);
procedure SynthAddEvent(Track:PSynthTrack;NewEvent:PSynthEvent); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadBankInformations(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadBank(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadSMF(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadBMFInformations(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadBMFSampleRate(Data:pbyte;DataSize:longword):longword; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthReadBMF(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthFreeTrack(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthClearTrack(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthChangeTempo(Track:PSynthTrack); stdcall;
procedure SynthChangeTempoEx(Track:PSynthTrack;NewTicksPerQuarterNote,NewTempo:longint); stdcall;
procedure SynthProgramChange(Track:PSynthTrack;Channel:PSynthChannel;Data:byte);
procedure SynthResetEventQuery(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthFillBuffer(Track:PSynthTrack;Samples:longint{$ifdef vsti};InputBuffer:PSynthBufferSample{$endif}); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifndef VSTi}
procedure SynthFillOutputBuffer(Track:PSynthTrack;OutputData:pointer); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$endif}
function SynthSeekToSample(Track:PSynthTrack;DestSample:int64=-1):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthSeekToMS(Track:PSynthTrack;DestMS:int64=-1):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthTimePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthSamplePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifdef WIN32Plain}
function SynthGetTimePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
function SynthGetSamplePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthPoll(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthCreateThread(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthExitThread(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthPlay(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthStop(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthEnter(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
procedure SynthLeave(Track:PSynthTrack); {$ifdef csdk}stdcall;{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$endif}

implementation

{$ifdef VSTi}
{$ifdef BR808SPEECH}
uses SpeechRules;
{$endif}
{$endif}

{$ifdef BR808SPEECH}
{$I SynthSpeechSegmentsData.inc}
{$endif}

type PInt64=^TInt64;
     TInt64=packed record
{$ifdef BigEndian}
      Hi:longint;
      Lo:longword;
{$else}
      Lo:longword;
      Hi:longint;
{$endif}
     end;

const EventSizes:array[0..$f] of byte=(0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,0);
      RandomSeed:longword=$12345678;
      i127:longword=127;

      halfpi=pi*0.5;

{$ifdef BR808SPEECH}
      DefaultFrameValues:TSynthSpeechFrame=(500,1500,2800,3250,3700,4990, // Fx
                                            60,90,150,200,200,500,        // Bx
                                            0,0,0,0,0,0,                  // Ax
                                            0,0,0,0,0,500);

var SpeechSegmentsArray:TSynthSpeechSegments;
{$endif}

procedure SynthProcessModulationMatrix(Track:PSynthTrack;ThreadNumber:longint;var DestBuf:PSynthFloatValue;Instrument:PSynthInstrument;Channel:PSynthChannel;Voice:PSynthVoice;Target,TargetIndex:byte;Samples:longint;DefaultBuffer:PSynthFloatValue); forward;

{$ifdef csdk}
function abs(i:longint):longint; overload; inline;
begin
 if i<0 then begin
  result:=-i;
 end else begin
  result:=i;
 end;
end;

function abs(i:single):single; overload; inline;
begin
 longword(pointer(@result)^):=longword(pointer(@i)^) and $7fffffff;
end;

function abs(i:double):double; overload; inline;
begin
 int64(pointer(@result)^):=int64(pointer(@i)^) and $7fffffffffffffff;
end;

const HEAP_NO_SERIALIZE=$00001;
      HEAP_GROWABLE=$00002;
      HEAP_GENERATE_EXCEPTIONS=$00004;
      HEAP_ZERO_MEMORY=$00008;
      HEAP_REALLOC_IN_PLACE_ONLY=$00010;
      HEAP_TAIL_CHECKING_ENABLED=$00020;
      HEAP_FREE_CHECKING_ENABLED=$00040;
      HEAP_DISABLE_COALESCE_ON_FREE=$00080;
      HEAP_CREATE_ALIGN_16=$10000;
      HEAP_CREATE_ENABLE_TRACING=$20000;
      HEAP_MAXIMUM_TAG=$00fff;
      HEAP_PSEUDO_TAG_FLAG=$08000;
      HEAP_TAG_SHIFT=16;

function GetProcessHeap:THandle; stdcall; external name '_GetProcessHeap@0';
function HeapAlloc(hHeap:THandle;dwFlags,dwBytes:dword):pointer; stdcall; external name '_HeapAlloc@12';
function HeapFree(hHeap:THandle;dwFlags:dword;lpMem:pointer):LONGBOOL; stdcall; external name '_HeapFree@12';

const HeapHandle:longword=$ffffffff;
      HeapFlags:dword=HEAP_GENERATE_EXCEPTIONS;

procedure GetMem(var DestPointer;Size:longint);
var DestPointerPointer:pointer absolute DestPointer;
begin
 if HeapHandle=$ffffffff then begin
  HeapHandle:=GetProcessHeap;
 end;
 DestPointerPointer:=HeapAlloc(HeapHandle,HeapFlags,Size);
end;

procedure FreeMem(var DestPointer);
var DestPointerPointer:pointer absolute DestPointer;
begin
 HeapFree(HeapHandle,HeapFlags and HEAP_NO_SERIALIZE,DestPointerPointer);
end;

function FPCGetMem(Size:longword):pointer; register; [alias : 'fpc_getmem'];
begin
 GetMem(result,Size);
end;

procedure FPCFreeMem(p:pointer); register; [alias : 'fpc_freemem'];
begin
 FreeMem(p);
end;

{$Q- no overflow checking }
{$R- no range checking }
{$asmmode att}
    type
       tqwordrec = packed record
         low : dword;
         high : dword;
       end;

   function fpc_div_qword(n,z : qword) : qword;assembler;[alias: 'FPC_DIV_QWORD']; compilerproc;
      var
         shift,lzz,lzn : longint;
         saveebx,saveedi : longint;
      asm
            movl %ebx,saveebx
            movl %edi,saveedi
            { the following piece of code is taken from the     }
            { AMD Athlon Processor x86 Code Optimization manual }
            movl n+4,%ecx
            movl n,%ebx
            movl %ecx,%eax
            orl %ebx,%eax
            jnz .Lnodivzero
            jmp .Lexit
.Lnodivzero:
            movl z+4,%edx
            movl z,%eax
            testl %ecx,%ecx
            jnz .Lqworddivbigdivisor
            cmpl %ebx,%edx
            jae .Lqworddivtwo_divs
            divl %ebx
            movl %ecx,%edx
            jmp .Lexit

         .Lqworddivtwo_divs:
            movl %eax,%ecx
            movl %edx,%eax
            xorl %edx,%edx
            divl %ebx
            xchgl %ecx,%eax
            divl %ebx
            movl %ecx,%edx
            jmp .Lexit

         .Lqworddivbigdivisor:
            movl %ecx,%edi
            shrl $1,%edx
            rcrl $1,%eax
            rorl $1,%edi
            rcrl $1,%ebx
            bsrl %ecx,%ecx
            shrdl %cl,%edi,%ebx
            shrdl %cl,%edx,%eax
            shrl %cl,%edx
            roll $1,%edi
            divl %ebx
            movl z,%ebx
            movl %eax,%ecx
            imull %eax,%edi
            mull n
            addl %edi,%edx
            subl %eax,%ebx
            movl %ecx,%eax
            movl z+4,%ecx
            sbbl %edx,%ecx
            sbbl $0,%eax
            xorl %edx,%edx
.Lexit:
            movl saveebx,%ebx
            movl saveedi,%edi
      end;

    function fpc_mul_qword(f1,f2 : qword;checkoverflow : longbool) : qword;[alias: 'FPC_MUL_QWORD']; compilerproc;
      var
        r : qword;
        overflowed : boolean;
      begin
        overflowed:=false;
        { the following piece of code is taken from the
          AMD Athlon Processor x86 Code Optimization manual }
        asm
           movl f1+4,%edx
           movl f2+4,%ecx
           cmpl $0,checkoverflow
           jnz .Loverflowchecked

           orl %ecx,%edx
           movl f2,%edx
           movl f1,%eax
           jnz .Lqwordmultwomul
           mull %edx
           jmp .Lqwordmulready
        .Lqwordmultwomul:
           imul f1+4,%edx
           imul %eax,%ecx
           addl %edx,%ecx
           mull f2
           add %ecx,%edx
        .Lqwordmulready:
           movl %eax,r
           movl %edx,r+4
           jmp .Lend

        .Loverflowchecked:
           { if both upper dwords are <>0 then it overflows always }
           or %ecx,%ecx
           jz .Loverok1
           or %edx,%edx
           jnz .Loverflowed
        .Loverok1:
           { overflow checked code }
           orl %ecx,%edx
           movl f2,%edi
           movl f1,%esi
           jnz .Lqwordmultwomul2
           movl %edi,%eax
           mull %esi
           movl %eax,%esi
           movl %edx,%edi
           jmp .Lqwordmulready2

        .Lqwordmultwomul2:
           movl f1+4,%eax
           mull %edi
           movl %eax,%edi
           jc  .Loverflowed

           movl %esi,%eax
           mull %ecx
           movl %eax,%ecx
           jc  .Loverflowed

           addl %edi,%ecx
           jc  .Loverflowed

           movl f2,%eax
           mull %esi
           movl %eax,%esi
           movl %edx,%edi

           addl %ecx,%edi
           jc  .Loverflowed

        .Lqwordmulready2:
           movl %esi,r
           movl %edi,r+4
           jmp .Lend

        .Loverflowed:
           movb $1,overflowed

        .Lend:
        end [ 'eax','edx','ecx','edi','esi' ];
        fpc_mul_qword:=r;
      end;
{$asmmode intel}

    function fpc_mul_int64(f1,f2 : int64;checkoverflow : longbool) : int64;[alias: 'FPC_MUL_INT64']; compilerproc;

      var
         sign : boolean;
         q1,q2,q3 : qword;

      begin
           begin
              sign:=false;
              if f1<0 then
                begin
                   sign:=not(sign);
                   q1:=qword(-f1);
                end
              else
                q1:=f1;
              if f2<0 then
                begin
                   sign:=not(sign);
                   q2:=qword(-f2);
                end
              else
                q2:=f2;
              { the q1*q2 is coded as call to mulqword }
              q3:=q1*q2;

              if checkoverflow and (q1 <> 0) and (q2 <>0) and
              ((q1>q3) or (q2>q3) or
                { the bit 63 can be only set if we have $80000000 00000000 }
                { and sign is true                                         }
                (q3 shr 63<>0) and
                 ((q3<>(qword(1) shl 63)) or not(sign))
                ) then
                begin
                end;

              if sign then
                fpc_mul_int64:=-q3
              else
                fpc_mul_int64:=q3;
           end;
      end;

    function fpc_div_int64(n,z : int64) : int64;[alias: 'FPC_DIV_INT64']; compilerproc;

      var
         sign : boolean;
         q1,q2 : qword;

      begin
         { can the fpu do the work? }
           begin
              sign:=false;
              if z<0 then
                begin
                   sign:=not(sign);
                   q1:=qword(-z);
                end
              else
                q1:=z;
              if n<0 then
                begin
                   sign:=not(sign);
                   q2:=qword(-n);
                end
              else
                q2:=n;

              { the div is coded by the compiler as call to divqword }
              if sign then
                fpc_div_int64:=-(q1 div q2)
              else
                fpc_div_int64:=q1 div q2;
           end;
      end;

function SynthGetTrackSize:longword; stdcall;
begin
 result:=sizeof(TSynthTrack);
end;

{$endif}

function Swap32(const Value:longword):longword; {$ifdef cpu386}assembler; {$ifdef cpu386}register;{$endif} {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
asm
 BSWAP EAX
end;
{$else}
begin
{$ifdef cpu386}
 result:=((Value and $ff) shl 24) or (((Value and $ff00) shr 8) shl 16) or (((Value and $ff0000) shr 16) shl 8) or ((Value and $ff000000) shr 24);
{$else}
 result:=Value;
{$endif}
end;
{$endif}

function Swap16(const Value:word):word; {$ifdef cpu386}assembler; {$ifdef cpu386}register;{$endif} {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
asm
 XCHG AH,AL
end;
{$else}
begin
{$ifdef cpu386}
 result:=((Value and $ff) shl 8) or ((Value and $ff00) shr 8);
{$else}
 result:=Value;
{$endif}
end;
{$endif}

procedure SIMDSetFlags;
{$ifdef UseSSE}
// Flush to Zero=Bit 15
// Underflow exception mask=Bit 11
// Denormals are zeros=Bit 6
// Denormal exception mask=Bit 8
// $8840(ftz+uem+daz+dem) and $8940(ftz+uem+daz)
const DenormalsAreZero=1 shl 6;
      InvalidOperationExceptionMask=1 shl 7;
      DenormalExceptionMask=1 shl 8;
      DivodeByZeroExceptionMask=1 shl 9;
      OverflowExceptionMask=1 shl 10;
      UnderflowExceptionMask=1 shl 11;
      PrecisionMask=1 shl 12;
      FlushToZero=1 shl 15;
      SIMDFlags=InvalidOperationExceptionMask or DenormalExceptionMask or DivodeByZeroExceptionMask or OverflowExceptionMask or UnderflowExceptionMask or PrecisionMask or FlushToZero;
      RoundToNearest=longword(longword($ffffffff) and not ((1 shl 13) or (1 shl 14)));
var SIMDCtrl:longword;
begin
 if SSEExt then begin
  asm
   push eax
   stmxcsr dword ptr SIMDCtrl
   mov eax,dword ptr SIMDCtrl
   or eax,SIMDFlags
   and eax,RoundToNearest
   cmp dword ptr SSE2Ext,0
   jz @NoSSE2
    or eax,DenormalsAreZero // DAZ on SSE1-only CPUs is often buggy, so avoid better DAZ on SSE1-only CPUs
   @NoSSE2:
   mov dword ptr SIMDCtrl,eax
   ldmxcsr dword ptr SIMDCtrl
   pop eax
  end;
 end;
end;
{$else}
begin
end;
{$endif}

procedure CheckCPU;
{$ifdef UseSSE}
var Features,FeaturesExt:longword;
{$endif}
begin
{$ifdef UseSSE}
 Features:=0;
 FeaturesExt:=0;
 asm
  pushad

  // Check for CPUID opcode
  pushfd
  pop eax
  mov edx,eax
  xor eax,$200000
  push eax
  popfd
  pushfd
  pop eax
  xor eax,edx
  jz @NoCPUID
   // Get cpu features per CPUID opcode
   mov eax,1
   cpuid
   mov dword ptr FeaturesExt,ecx
   mov dword ptr Features,edx
  @NoCPUID:
  popad
 end;
 MMXExt:=(Features and $00800000)<>0;
 SSEExt:=(Features and $02000000)<>0;
 SSE2Ext:=(Features and $04000000)<>0;
 SSE3Ext:=(FeaturesExt and $00000001)<>0;
{$else}
 MMXExt:=false;
 SSEExt:=false;
 SSE2Ext:=false;
 SSE3Ext:=false;
{$endif}
end;

procedure SwapLittleEndianData16(var Data);
{$ifdef BIG_ENDIAN}
var Value:word absolute Data;
begin
 Value:=((Value and $FF00) shr 8) or ((Value and $00FF) shl 8);
{$else}
begin
{$endif}
end;

procedure SwapLittleEndianData32(var Data);
{$ifdef BIG_ENDIAN}
var Value:longword absolute Data;
begin
 Value:=((Value and $FF000000) shr 24) or ((Value and $00FF0000) shr 8) or
        ((Value and $0000FF00) shl 8) or ((Value and $000000FF) shl 24);
{$else}
begin
{$endif}
end;

function RandomFloat(var Seed:longword):single;
var RandomValue:longword;
begin
 Seed:=(Seed*1664525)+1013904223; //RandomSeed:=(RandomSeed*$524281)+$3133731;
 RandomValue:=((Seed shr 9) and $7fffff) or $40000000;
 result:=((single(pointer(@RandomValue)^)-3)+1)*0.5;
end;

function RandomInteger:longint;
begin
 RandomSeed:=(RandomSeed*1664525)+1013904223;
 result:=RandomSeed;
end;

const PI2:single=PI*2;

function Clip(Value,Min,Max:single):single;
begin
 result:=Value;
 if result<Min then begin
  result:=Min;
 end else if result>Max then begin
  result:=Max;
 end;
end;

function Min(Value,Min:single):single;
begin
 if Value>Min then begin
  result:=Min;
 end else begin
  result:=Value;
 end;
end;

function Max(Value,Max:single):single;
begin
 if Value<Max then begin
  result:=Max;
 end else begin
  result:=Value;
 end;
end;

{function Clip(Value,Min,Max:single):single;
var Temp1,Temp2:single;
begin
 Temp1:=abs(Value-Min);
 Temp2:=abs(Value-Max);
 result:=((Temp1+(Min+Max))-Temp2)*0.5;
end;}

function FastSQRT(Value:single):single;
const f0d5:single=0.5;
var Casted:longword absolute result;
begin
 result:=Value;
 Casted:=($be6eb50c-Casted) shr 1;
 result:=Value*(f0d5*(result*(3-(Value*sqr(result)))));
end;

function FastTRUNC(FloatValue:single):longint;
var FloatValueCasted:longword absolute FloatValue;
    Exponent,Sig,IsDenormalized:longword;
    Shift:longint;
begin
 Exponent:=(FloatValueCasted and $7fffffff) shr 23;
 Shift:=Exponent-$96;
 Sig:=(FloatValueCasted and $7fffff) or $00800000;
 IsDenormalized:=$ffffffff+(longword(Shift shr 31) shl 1);
 result:=((((($ffffffff+longword(longword(Exponent-$7e) shr 31)) and (Sig shr (32-Shift))) and not IsDenormalized) or
        (longword(Sig shl (Shift and 31)) and IsDenormalized))*(1-((FloatValueCasted shr 31) shl 1))) and
        ($ffffffff+(longword(longword(($9e+1)-Exponent) shr 31) shl 1));
end;

function FastdBtoAmp(Value:single):single;
const Factor0:single=1.6609640474436811739351597147447E-1;
      Factor1:single=7.02679339377207945E-1;
      Factor2:single=2.39338555345344262E-1;
var ValueCasted:longint absolute Value;
    ResultCasted:longint absolute result;
begin
 if (((ValueCasted) and $ff800000) shr 23)>$3f then begin
  Value:=Value*Factor0;
  ResultCasted:=FastTRUNC(Value);
  Value:=Value-ResultCasted;
  ResultCasted:=($7f+ResultCasted) shl 23;
  result:=result*(1+(Value*(Factor1+(Value*Factor2))));
 end else begin
  result:=ord(ValueCasted=0);
 end;
end;

function LinearToDetune(x:single):single;
var x2,x3,x4,x5,x6,x7,x8,x9,x10,x11:single;
begin
 x2:=x*x;
 x3:=x2*x;
 x4:=x3*x;
 x5:=x4*x;
 x6:=x5*x;
 x7:=x6*x;
 x8:=x7*x;
 x9:=x8*x;
 x10:=x9*x;
 x11:=x10*x;
 result:=(((((((((((10028.7312891634*x11)-(50818.8652045924*x10))+
         (111363.4808729368*x9))-(138150.6761080548*x8))+
         (106649.6679158292*x7))-(53046.9642751875*x6))+
         (17019.9518580080*x5))-(3425.0836591318*x4))+
         (404.2703938388*x3))-(24.1878824391*x2))+
         (0.6717417634*x))+0.003011559;
end;

function LinearToCenterOscAmp(x:single):single;
begin
 result:=0.99785-(0.55366*x);
end;

function LinearToSideOscAmp(x:single):single;
begin
 result:=(0.044372-(0.73764*(x*x)))+(1.2841*x);
end;

function SoftSQRT(Value:single):single; stdcall;
begin
 plongint(@result)^:=((plongint(@Value)^-$3f800000) div 2)+$3f800000;
end;

{$ifdef cpu386}
function exp(x:single):single; assembler; stdcall;
asm
 fld dword ptr x
 fldl2e
 fmulp st(1),st(0)

 fldl2e
 fmulp st(1),st(0)

 fld1
 fld st(1)
 fprem
 f2xm1
 faddp st(1),st(0)
 fscale

 fstp st(1)
 fstp dword ptr result
end;

function power(Number,Exponent:single):single; assembler; stdcall;
asm
 fld dword ptr Exponent
 fld dword ptr Number
 fyl2x
 fld1
 fld st(1)
 fprem
 f2xm1
 faddp st(1),st
 fscale
 fstp st(1)
end;

function frac(X:single):single; assembler; stdcall;
asm
 fld dword ptr x
 fld1
 fxch st(1)
 fprem
 fxch st(1)
 fstp st(0)
end;

function ROUND64(x:single):int64; assembler; stdcall;
asm
 fld dword ptr x
 sub esp,8
 fistp qword ptr [esp]
 pop eax
 pop edx
end;

{$ifndef rtl}
{$ifdef ver130}
function TRUNC(X:single):longint; assembler; stdcall;
asm
 fld dword ptr x
 fistp dword ptr result
end;
{$else}
function TRUNC(X:single):longint; assembler; stdcall;
asm
 cvttss2si eax,dword ptr x
end;
{$endif}

procedure Move(const Source;var Dest;Count:longint); assembler; {$ifdef cpu386}register;{$endif} {$ifdef FPC}NOSTACKFRAME;{$endif}
asm
 PUSH ESI
 PUSH EDI
 PUSH ECX
 MOV ESI,EAX
 MOV EDI,EDX
 REP MOVSB
 POP ECX
 POP EDI
 POP ESI
end;

procedure FillChar(var Dest;Count:longint;Value:ansichar); assembler; {$ifdef cpu386}register;{$endif} {$ifdef FPC}NOSTACKFRAME;{$endif}
asm
 PUSH EDI
 PUSH ECX
 PUSH EAX
 MOV EDI,EAX
 MOV EAX,ECX
 MOV ECX,EDX
 REP STOSB
 POP EAX
 POP ECX
 POP EDI
end;
{$endif}
{$else}
function power(Number,Exponent:single):single;
begin
 result:=EXP(Exponent*LN(Nummer));
end;

function ROUND64(X:single):int64;
begin
 result:=ROUND(X);
end;

{$ifndef rtl}
function frac(X:single):single;
begin
 result:=X-SOFTTRUNC(X);
end;

procedure Move(const Source;var Dest;Count:longint);
var Src,Dst:pbyte;
    Counter:longint;
begin
 Src:=@Source;
 Dst:=@Dest;
 for Counter:=1 to Count do begin
  Dst^:=Src^;
  inc(Src);
  inc(Dst);
 end;
end;

procedure FillChar(var Dest;Count:longint;Value:ansichar);
var Dst:pansichar;
    Counter:longint;
begin
 Dst:=@Dest;
 for Counter:=1 to Count do begin
  Dst^:=Value;
  inc(Dst);
 end;
end;
{$endif}
{$endif}

function sinh(const x:double):double;
begin
 if abs(x)<1e-14 then begin
  result:=0;
 end else begin
  result:=(exp(x)-exp(-x))*0.5;
 end;
end;

function PopulationCount(Value:longword):longword;{$ifdef cpu386}assembler; register;
asm
 // result:=Value-((Value shr 1) and $55555555);
 mov ecx,eax
 shr ecx,1
 and ecx,$55555555
 sub eax,ecx

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov ecx,eax
 and eax,$33333333
 shr ecx,2
 and ecx,$33333333
 add ecx,eax

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov eax,ecx
 shr eax,4
 add eax,ecx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov ecx,eax
 shr ecx,8
 add eax,ecx

 // inc(result,result shr 16);
 mov ecx,eax
 shr ecx,16
 add eax,ecx

 // result:=result and $3f;
 and eax,$3f
end;
{$else}
{$ifdef cpuamd64}assembler; register;
asm
{$ifdef windows}
 PopulationCount eax,ecx
{$else}
 PopulationCount eax,edi
{$endif}
 jz @NotFound
  xor eax,eax
 @NotFound:
 and rax,$ffffffff
end;
{$else}
begin
 result:=Value-((Value shr 1) and $55555555);
 result:=(result and $33333333)+((result shr 2) and $33333333);
 result:=(result+(result shr 4)) and $0f0f0f0f;
 inc(result,result shr 8);
 inc(result,result shr 16);
 result:=result and $3f;
end;
{$endif}
{$endif}

function FindFirstZeroBit(Value:longword):longword;{$ifdef cpu386}assembler; register;
asm
 not eax
 bsf eax,eax
 jnz @Found
  xor eax,eax
 @Found:
end;
{$else}
{$ifdef cpuamd64}assembler; register;
asm
{$ifdef windows}
 mov edx,ecx
{$else}
 mov edx,edi
{$endif}
 mov eax,edx
 not eax
 dec eax
 and eax,edx
 PopulationCount eax,eax
 jz @NotFound
  xor eax,eax
 @NotFound:
 and rax,$ffffffff
end;
{$else}
begin
 result:=PopulationCount(Value and ((not Value)-1));
end;
{$endif}
{$endif}

function CountLeadingZeros(x:longword):longword;{$ifdef cpu386}assembler; register;
asm
 bsr eax,eax
 jnz @NonZero
  mov eax,32
 jmp @Done
 @NonZero:
  xor eax,31
 @Done:
end;
{$else}
begin
 x:=x or (x shr 1);
 x:=x or (x shr 1);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 result:=32-PopulationCount(x);
end;
{$endif}

function CountLeadingOnes(x:longword):longword;{$ifdef cpu386}assembler; register;
asm
 not eax
 bsr eax,eax
 jnz @NonZero
  mov eax,32
 jmp @Done
 @NonZero:
  xor eax,31
 @Done:
end;
{$else}
begin
 result:=CountLeadingZeros(not x);
end;
{$endif}

function CountTrailingZeros(x:longword):longword;
begin
 result:=PopulationCount((x and (-x))-1);
//result:=32-CountLeadingZeros((not x) and (x-1));
end;

function CountTrailingOnes(x:longword):longword;
begin
 result:=CountTrailingZeros(not x);
//result:=32-CountLeadingZeros(x and ((not x)-1));
end;

function NumberOfOnes(x:longword):longword;
begin
 result:=PopulationCount(x);
end;

function NumberOfZeros(x:longword):longword;
begin
 result:=PopulationCount(not x);
end;

function NumberOfBits(x:longword):longword;
begin
 result:=32-CountLeadingZeros(x);
end;

function Log2Ceil(x:longword):longword;
begin
 result:=32-CountLeadingZeros(x-1);
end;

function NextOfPowerTwo(x:longword):longword;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 result:=x+1;
end;

function IsPowerTwo(x:longword):boolean;
begin
 result:=(x and (x-1))=0;
end;

function GrayCode(x:longword):longword;
begin
 result:=x xor (x shr 1);
end;

function FindLeastSignificantBit(x:longword):longword;
begin
 result:=x and (-x);
end;

function FindLeastSignificantBitPossition(x:longword):longword;
begin
 result:=CountTrailingZeros(x and (-x));
end;

function FindMostSignificantBitPosition(x:longword):longword;
begin
 result:=31-CountLeadingZeros(x);
end;

function FindMostSignificantBit(x:longword):longword;
begin
 result:=1 shl FindMostSignificantBitPosition(x);
end;

function BitReverse(x:longword):longword;
begin
 x:=((x and $aaaaaaaa) shr 1) or ((x and $55555555) shl 1);
 x:=((x and $cccccccc) shr 2) or ((x and $33333333) shl 2);
 x:=((x and $f0f0f0f0) shr 4) or ((x and $0f0f0f0f) shl 4);
 x:=((x and $ff00ff00) shr 8) or ((x and $00ff00ff) shl 8);
 result:=(x shr 16) or (x shl 16);
end;

function RotateLeft(x,s:longword):longword;
begin
 s:=s and 31;
 result:=(x shr (32-s)) or (x shl s);
end;

function RotateRight(x,s:longword):longword;
begin
 s:=s and 31;
 result:=(x shl (32-s)) or (x shr s);
end;

procedure GetMemAligned(var p;Size:longint);
{$ifdef HasFastMM4}
begin
 GetMem(pointer(p),Size);
 FillChar(pointer(p)^,Size,#0);
end;
{$else}
const Align=16;
var Original,Aligned:pointer;
    Mask:ptruint;
begin
{if (Align and (Align-1))<>0 then begin
  Align:=NextOfPowerTwo(Align);
 end;}
 Mask:=Align-1;
 inc(Size,((Align shl 1)+sizeof(pointer)));
 GetMem(Original,Size);
 FillChar(Original^,Size,#0);
 Aligned:=pointer(ptruint(ptruint(Original)+sizeof(pointer)));
 if (Align>1) and ((ptruint(Aligned) and Mask)<>0) then begin
  inc(ptruint(Aligned),ptruint(ptruint(Align)-(ptruint(Aligned) and Mask)));
 end;
 pointer(pointer(ptruint(ptruint(Aligned)-sizeof(pointer)))^):=Original;
 pointer(pointer(@p)^):=Aligned;
end;
{$endif}

procedure FreeMemAligned(const p);
{$ifdef HasFastMM4}
begin
 FreeMem(pointer(p));
end;
{$else}
var pp:pointer;
begin
 pp:=pointer(pointer(@p)^);
 if assigned(pp) then begin
  pp:=pointer(pointer(ptruint(ptruint(pp)-sizeof(pointer)))^);
  FreeMem(pp);
 end;
end;
{$endif}

function ComparePAnsiChar(a,b:pansichar):boolean; register;
var ac,bc:ansichar;
begin
 result:=true;
 if assigned(a) and assigned(b) then begin
  while (a^<>#0) and (b^<>#0) do begin
   ac:=a^;
   bc:=b^;
   if ac in ['A'..'Z'] then begin
    inc(ac,ord('a')-ord('A'));
   end;
   if bc in ['A'..'Z'] then begin
    inc(bc,ord('a')-ord('A'));
   end;
   if ac<>bc then begin
    result:=false;
    break;
   end;
   inc(a);
   inc(b);
  end;
  if a^<>b^ then begin
   result:=false;
  end;
 end;
end;

function LinkTRI(RawCode:pointer;RawCodeSize:longint;var CodeSize:longint;var EntryPoint:pointer;GetExternalPointer:TGetExternalPointer;SetPublicPointer:TSetPublicPointer):pointer;
{$ifndef fpc}
type ptruint=longword;
{$endif}
var ImageCodeSize,ImageSize,i,Position,Len:longint;
    ImageRelocations:longint;
    ImagePublics:longint;
    r,p:pansichar;
    t,Bits:byte;
    Relative:boolean;
    ExternalName,LibName,LibImportName,PublicName:pansichar;
    ExternalPointer,LibImportPointer:pointer;
begin
 result:=nil;
 EntryPoint:=nil;
 if assigned(RawCode) and (RawCodeSize>0) then begin
  if not ((pansichar(RawCode)[0]='T') and (pansichar(RawCode)[1]='R') and (pansichar(RawCode)[2]='I') and (pansichar(RawCode)[3]=#00)) then begin
   exit;
  end;
  ImageCodeSize:=longint(pointer(@pansichar(RawCode)[4])^);
  ImageSize:=longint(pointer(@pansichar(RawCode)[8])^);
  ImageRelocations:=longint(pointer(@pansichar(RawCode)[12])^);
  ImagePublics:=longint(pointer(@pansichar(RawCode)[16])^);
  r:=pointer(@pansichar(RawCode)[longint(pointer(@pansichar(RawCode)[20])^)]);
  p:=pointer(@pansichar(RawCode)[longint(pointer(@pansichar(RawCode)[24])^)]);
  CodeSize:=ImageSize;
  result:=VirtualAlloc(nil,ImageSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
  EntryPoint:=result;
  fillchar(result^,ImageSize,#0);
  move(pointer(@pansichar(RawCode)[28])^,result^,ImageCodeSize);
  for i:=1 to ImageRelocations do begin
   t:=byte(pointer(r)^);
   inc(r);
   case t of
    1:begin
     // Relocation
     Bits:=byte(pointer(r)^);
     inc(r);
     Relative:=byte(pointer(r)^)<>0;
     inc(r);
     Position:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     if not Relative then begin
      case Bits of
       8:begin                                          
        inc(byte(pointer(@pansichar(result)[Position])^),ptruint(result));
       end;
       16:begin
        inc(word(pointer(@pansichar(result)[Position])^),ptruint(result));
       end;
       32:begin
        inc(longword(pointer(@pansichar(result)[Position])^),ptruint(result));
       end;
       64:begin
        inc(int64(pointer(@pansichar(result)[Position])^),ptruint(result));
       end;
      end;
     end;
    end;
    2:begin
     // External
     Bits:=byte(pointer(r)^);
     inc(r);
     Relative:=byte(pointer(r)^)<>0;
     inc(r);
     Position:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     Len:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     ExternalName:=pointer(r);
     inc(r,Len);
     if assigned(@GetExternalPointer) then begin
      ExternalPointer:=GetExternalPointer(ExternalName);
     end else begin
      ExternalPointer:=nil;
     end;
     if assigned(ExternalPointer) then begin
      if Relative then begin
       case Bits of
        8:begin
         inc(byte(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer)-ptruint(result));
        end;
        16:begin
         inc(word(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer)-ptruint(result));
        end;
        32:begin
         inc(longword(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer)-ptruint(result));
        end;
        64:begin
         inc(int64(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer)-ptruint(result));
        end;
       end;
      end else begin
       case Bits of
        8:begin
         inc(byte(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer));
        end;
        16:begin
         inc(word(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer));
        end;
        32:begin
         inc(longword(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer));
        end;
        64:begin
         inc(int64(pointer(@pansichar(result)[Position])^),ptruint(ExternalPointer));
        end;
       end;
      end;
     end;
    end;
    3:begin
     // Import
     Bits:=byte(pointer(r)^);
     inc(r);
     Relative:=byte(pointer(r)^)<>0;
     inc(r);
     Position:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     Len:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     LibName:=r;
     inc(r,Len);
     Len:=longint(pointer(r)^);
     inc(r,sizeof(longint));
     LibImportName:=r;
     inc(r,Len);
     LibImportPointer:=GetProcAddress(LoadLibraryA(LibName),LibImportName);
     if Relative then begin
      case Bits of
       8:begin
        inc(byte(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer)-ptruint(result));
       end;
       16:begin
        inc(word(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer)-ptruint(result));
       end;
       32:begin
        inc(longword(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer)-ptruint(result));
       end;
       64:begin
        inc(int64(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer)-ptruint(result));
       end;
      end;
     end else begin
      case Bits of
       8:begin
        inc(byte(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer));
       end;
       16:begin
        inc(word(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer));
       end;
       32:begin
        inc(longword(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer));
       end;
       64:begin
        inc(int64(pointer(@pansichar(result)[Position])^),ptruint(LibImportPointer));
       end;
      end;
     end;
    end;
   end;
  end;
  // Publics
  for i:=1 to ImagePublics do begin
   Len:=longint(pointer(p)^);
   inc(p,sizeof(longint));
   PublicName:=p;
   inc(p,Len);
   Position:=longint(pointer(p)^);
   inc(p,sizeof(longint));
   if assigned(@SetPublicPointer) then begin
    SetPublicPointer(PublicName,pointer(@pansichar(result)[Position]));
   end;
  end;
 end;
end;

{$ifdef cpuamd64}                                              
function InterlockedCompareExchange128Ex(Target,NewValue,Comperand:pointer):boolean; assembler; register;
asm
 push rbx
{$ifdef win64}
 push rdi
 push rsi
 mov rdi,rcx
 mov rsi,rdx
 mov rdx,qword ptr [r8+4]
 mov rax,qword ptr [r8+0]
{$else}
 mov rax,qword ptr [rdx+0]
 mov rdx,qword ptr [rdx+4]
{$endif}
 mov rcx,qword ptr [rsi+4]
 mov rbx,qword ptr [rsi+0]
 lock cmpxchg16b [rdi]
 setz al
{$ifdef win64}
 pop rsi
 pop rdi
{$endif}
 pop rbx
end;
{$endif}

{$ifdef cpu386}
{$ifndef ver130}
function InterlockedCompareExchange64Ex(Target,NewValue,Comperand:pointer):boolean; assembler; register;
asm
 push ebx
 push edi
 push esi
 mov edi,eax
 mov esi,edx
 mov edx,dword ptr [ecx+4]
 mov eax,dword ptr [ecx+0]
 mov ecx,dword ptr [esi+4]
 mov ebx,dword ptr [esi+0]
 lock cmpxchg8b [edi]
 setz al
 pop esi
 pop edi
 pop ebx
end;

function InterlockedCompareExchange64(var Target:int64;NewValue:int64;Comperand:int64):int64; assembler; register;
asm
 push ebx
 push edi
 mov edi,eax
 mov edx,dword ptr [Comperand+4]
 mov eax,dword ptr [Comperand+0]
 mov ecx,dword ptr [NewValue+4]
 mov ebx,dword ptr [NewValue+0]
 lock cmpxchg8b [edi]
 pop edi
 pop ebx
end;
{$endif}
{$endif}

{$ifndef fpc}
{$ifdef cpu386}
function InterlockedDecrement(var Target:longint):longint; assembler; register;
asm
 mov edx,$ffffffff
 xchg eax,edx
 lock xadd dword ptr [edx],eax
 dec eax
end;

function InterlockedIncrement(var Target:longint):longint; assembler; register;
asm
 mov edx,1
 xchg eax,edx
 lock xadd dword ptr [edx],eax
 inc eax
end;

function InterlockedExchange(var Target:longint;Source:longint):longint; assembler; register;
asm
 lock xchg dword ptr [eax],edx
 mov eax,edx
end;

function InterlockedExchangeAdd(var Target:longint;Source:longint):longint; assembler; register;
asm
 xchg edx,eax
 lock xadd dword ptr [edx],eax
end;

function InterlockedCompareExchange(var Target:longint;NewValue,Comperand:longint):longint; assembler; register;
asm
 xchg ecx,eax
 lock cmpxchg dword ptr [ecx],edx
end;
{$else}
function InterlockedDecrement(var Target:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=Windows.InterlockedDecrement(Target);
end;

function InterlockedIncrement(var Target:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=Windows.InterlockedIncrement(Target);
end;

function InterlockedExchange(var Target:longint;Source:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=Windows.InterlockedExchange(Target,Source);
end;

function InterlockedExchangeAdd(var Target:longint;Source:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=Windows.InterlockedExchangeAdd(Target,Source);
end;

function InterlockedCompareExchange(var Target:longint;NewValue,Comperand:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=Windows.InterlockedCompareExchange(Target,NewValue,Comperand);
end;
{$endif}
{$else}
function InterlockedDecrement(var Target:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=System.InterlockedDecrement(Target);
end;

function InterlockedIncrement(var Target:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=System.InterlockedIncrement(Target);
end;

function InterlockedExchange(var Target:longint;Source:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=System.InterlockedExchange(Target,Source);
end;

function InterlockedExchangeAdd(var Target:longint;Source:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=System.InterlockedExchangeAdd(Target,Source);
end;

function InterlockedCompareExchange(var Target:longint;NewValue,Comperand:longint):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=System.InterlockedCompareExchange(Target,NewValue,Comperand);
end;
{$endif}

function SynthLockCreate:pointer;
begin
 GetMem(result,sizeof(TRTLCriticalSection));
{$ifdef fpc}
 InitCriticalSection(TRTLCriticalSection(result^));
{$else}
 InitializeCriticalSection(TRTLCriticalSection(result^));
{$endif}
end;

procedure SynthLockDestroy(var Lock:pointer);
begin
 if assigned(Lock) then begin
{$ifdef fpc}
  DoneCriticalSection(TRTLCriticalSection(Lock^));
{$else}
  DeleteCriticalSection(TRTLCriticalSection(Lock^));
{$endif}
  FreeMem(Lock);
  Lock:=nil;
 end;
end;

procedure SynthLockEnter(Lock:pointer);
begin
 if assigned(Lock) then begin
  EnterCriticalSection(TRTLCriticalSection(Lock^));
 end;
end;

procedure SynthLockLeave(Lock:pointer);
begin
 if assigned(Lock) then begin
  LeaveCriticalSection(TRTLCriticalSection(Lock^));
 end;
end;

procedure SynthKillDenormal(var Value:single); {$ifdef cpu386}register;{$endif}
begin
 longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthPadSynthGenerateHarmonics(var PadSynth:TSynthSamplePadSynth);
var HarmonicsCurvePow,BalanceFactor:single;
    i:longint;
begin
 HarmonicsCurvePow:=power(Clip(PadSynth.CurveSteepness*fCI255,0.01,1)*2,5);
 for i:=0 to PadSynth.NumHarmonics-1 do begin
  if PadSynth.ExtendedBalance then begin
   if (i and 1)<>0 then begin
    BalanceFactor:=1+(PadSynth.Balance*fCI64);
   end else begin
    BalanceFactor:=1-(PadSynth.Balance*fCI64);
   end;
  end else begin
   if (i and 1)<>0 then begin
    BalanceFactor:=(PadSynth.Balance*fCI64);
   end else begin
    BalanceFactor:=1-(PadSynth.Balance*fCI64);
   end;
  end;
  case PadSynth.CurveMode of
   0:begin
    PadSynth.Harmonics[i]:=power(1-(i/PadSynth.NumHarmonics),HarmonicsCurvePow)*BalanceFactor;
   end;
   1:begin
    PadSynth.Harmonics[i]:=power(1/sqrt(i+1),HarmonicsCurvePow)*BalanceFactor;
   end;
   2:begin
    PadSynth.Harmonics[i]:=power(1/(i+1),HarmonicsCurvePow)*BalanceFactor;
   end;
   3:begin
    if i=(PadSynth.NumHarmonics-1) then begin
     PadSynth.Harmonics[i]:=0;
    end else begin
     PadSynth.Harmonics[i]:=power(1-(i/(PadSynth.NumHarmonics-1)),HarmonicsCurvePow)*BalanceFactor;
    end;
   end;
   4:begin
    if i=0 then begin
     PadSynth.Harmonics[i]:=0;
    end else begin
     PadSynth.Harmonics[i]:=power(1/sqrt(i),HarmonicsCurvePow)*BalanceFactor;
    end;
   end;
   else begin
    if i=0 then begin
     PadSynth.Harmonics[i]:=0;
    end else begin
     PadSynth.Harmonics[i]:=power(1/i,HarmonicsCurvePow)*BalanceFactor;
    end;
   end;
  end;
  SynthKillDenormal(PadSynth.Harmonics[i]);
 end;
end;

procedure SynthResizeEnvelope(Envelope:PSynthEnvelope;Count:longint);
var Nodes:PSynthEnvelopeNodes;
    i:longint;
begin
 GetMemAligned(Nodes,Count*sizeof(TSynthEnvelopeNode));
 if assigned(Envelope^.Nodes) then begin
  i:=Envelope^.NodesCount;
  if Count<i then begin
   i:=Count;
  end;
  if i>0 then begin
   Move(Envelope^.Nodes^,Nodes^,i*sizeof(TSynthEnvelopeNode));
  end;
  FreeMemAligned(Envelope^.Nodes);
 end;
 Envelope^.Nodes:=Nodes;
 Envelope^.NodesAllocated:=Count;
end;

procedure GetMemZero(var DestPointer;Size:longint);
var DestPointerPointer:pointer absolute DestPointer;
begin
 if assigned(DestPointerPointer) then begin
  FreeMemAligned(DestPointerPointer);
 end;
 GetMemAligned(DestPointerPointer,Size);
//FillChar(DestPointerPointer^,Size,#0);
end;

function SoftTRUNCEx(FloatValue:single):longint;
var FloatValueCasted:longword absolute FloatValue;
    Exponent,Sig:longword;
    Value,Shift:longint;
begin
 result:=0;
 Exponent:=(FloatValueCasted and $7fffffff) shr 23;
 if $9e>Exponent then begin
  Shift:=Exponent-$96;
  Sig:=(FloatValueCasted and $7fffff) or $00800000;
  if 0<=Shift then begin
   Value:=Sig shl (Shift and 31);
  end else begin
   if Exponent<$7e then begin
    exit;
   end;
   Value:=Sig shr (32-Shift);
  end;
  if (FloatValueCasted and $80000000)<>0 then begin
   result:=-Value;
  end else begin
   result:=Value;
  end;
 end;
end;

function SoftTRUNC(FloatValue:single):longint;
type plongword=^longword;
const MaskMantissa=(1 shl 23)-1;
var Exponent,Mantissa,Sig,SigExtra,Signed,IsDenormalized:longword;
    Value,Shift:longint;
begin
 Exponent:=(plongword(@FloatValue)^ and $7fffffff) shr 23;
 Mantissa:=plongword(@FloatValue)^and MaskMantissa;
 Shift:=Exponent-$96;
 Sig:=Mantissa or $00800000;
 SigExtra:=Sig shl (Shift and 31);
 IsDenormalized:=0-ord(0<=Shift);
 Value:=(((-ord(Exponent>=$7e)) and (Sig shr (32-Shift))) and not IsDenormalized) or
        (SigExtra and IsDenormalized);
 Signed:=0-ord((plongword(@FloatValue)^ and $80000000)<>0);
 result:=(((0-Value) and Signed) or (Value and not Signed)) and (0-ord($9e>Exponent));
end;

function SoftTRUNCDSP(FloatValue:single):longint;
type plongword=^longword;
const MaskMantissa=(1 shl 23)-1;
var Exponent,Mantissa,Sig,Signed:longword;
    Value,Shift:longint;
begin
 Exponent:=(plongword(@FloatValue)^ and $7fffffff) shr 23;
 Mantissa:=plongword(@FloatValue)^and MaskMantissa;
 Shift:=Exponent-$96;
 Sig:=Mantissa or $00800000;
 Value:=((-ord(Exponent>=$7e)) and (Sig shr (32-Shift)));
 Signed:=0-ord((plongword(@FloatValue)^ and $80000000)<>0);
 result:=((0-Value) and Signed) or (Value and not Signed);
end;

function LOG10(X:single):single;
const DivLN10:single=0.4342944819;
begin
 result:=LN(X)*DivLN10;
end;

function i0(x:double):double;
const epsilon=1e-6;
var u,halfx,t:double;
    n:longint;
begin
 result:=1;
 u:=1;
 n:=1;
 halfx:=x*0.5;
 repeat
  t:=halfx/n;
  inc(n);
  u:=u*sqr(t);
  result:=result+u;
 until not (u>=(epsilon*result));
end;

procedure Tauss88NoiseInit(var States:TSynthTauss88NoiseStates;Seed:longword=0);
begin
 States[0]:=1243598713 xor Seed;
 States[1]:=3093459404 xor Seed;
 States[2]:=1821928721 xor Seed;
 if States[0]<2 then begin
  States[0]:=1243598713;
 end;
 if States[1]<8 then begin
  States[1]:=3093459404;
 end;
 if States[2]<16 then begin
  States[2]:=1821928721;
 end;
end;

function Tauss88Noise(var States:TSynthTauss88NoiseStates):longword;
begin
 States[0]:=(((States[0] and 4294967294) shl 12) xor (((States[0] shl 13) xor States[0]) shr 19));
 States[1]:=(((States[1] and 4294967288) shl 4) xor (((States[1] shl 2) xor States[1]) shr 25));
 States[2]:=(((States[2] and 4294967280) shl 17) xor (((States[2] shl 3) xor States[2]) shr 11));
 result:=States[0] xor States[1] xor States[2];
end;

function WhiteNoise(var Seed:longword):single;
begin
 Seed:=(Seed*1664525)+1013904223;
 longword(pointer(@result)^):=((Seed shr 9) and $7fffff) or $40000000;
 result:=result-3;
end;

{const minvalue:single=1e-18;
var r1,r2:single;
begin
 repeat
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@r1)^):=((Seed shr 9) and $7fffff) or $40000000;
  r1:=r1-3;
  r1:=(r1+1)*0.5;
  longword(pointer(@r1)^):=longword(pointer(@r1)^) and $7fffffff;
 until longword(pointer(@r1)^)>=longword(pointer(@minvalue)^);
 Seed:=(Seed*1664525)+1013904223;
 longword(pointer(@r2)^):=((Seed shr 9) and $7fffff) or $40000000;
 r2:=r2-3;
 r2:=(r2+1)*0.5;
 longword(pointer(@r2)^):=longword(pointer(@r2)^) and $7fffffff;
 result:=Clip((FastSQRT(-2.0*ln(r1))*sin((2.0*pi*r2)+(pi*0.5)))*0.25,-1.0,1.0);
end;}

function MIDITimeCentsToMilliseconds(TimeCents:longint):longint;
begin
 if longword(TimeCents)=$80000000 then begin
  result:=0;
 end else begin
  result:=SoftTRUNC(1000*power(2,TimeCents/(1200*(1 shl 16))));
  if result<-32767 then begin
   result:=-32767;
  end else if result>32767 then begin
   result:=32767;
  end;
 end;
end;

function MIDIRelativeGainToLinear(Gain:longint):longint;
begin
 result:=SoftTRUNC((1 shl 16)*power(10,Gain/(200*(1 shl 16))));
end;

function MIDIRelativeLinearToGain(Gain:longint):longint;
begin
 if Gain<=0 then begin
  result:=-960*(1 shl 16);
 end else begin
  result:=SoftTRUNC((200*(1 shl 16))*LOG10(Gain/(1 shl 16)));
 end;
end;

function MIDIToLinearVolume(MIDIVolume:longword):longword;
begin
 if MIDIVolume>127 then MIDIVolume:=127;
 result:=((MIDIVolume*MIDIVolume) shl 16) div (127*127);
end;

function MIDIToLinearVolumeFloat(MIDIVolume:longword):single;
const VolDiv=1/(127*127);
begin
 if MIDIVolume>127 then MIDIVolume:=127;
 result:=(MIDIVolume*MIDIVolume)*VolDiv;
end;

function SynthEnvelopeGetValue(Envelope:PSynthEnvelope;Time:double):single;
 function CosineInterpolate(x,y1,y2:single):single;
 begin
  result:=y1+((y2-y1)*((1.0-cos(x*pi))*0.5));
 end;
 function CubicInterpolate(x,y0,y1,y2,y3:single):single;
 var xx,v:single;
 begin
  xx:=x*x;
  v:=((y3-y2)-y0)+y1;
  result:=(v*x*xx)+(((y0-y1)-v)*xx)+((y2-y0)*x)+y1;
 end;
 function CatmullRomInterpolate(t,x0,y0,x1,y1,x2,y2,x3,y3:single):single;
 var n,m0,m1,t2,t3:single;
 begin
  n:=x2-x1;
  m0:=n*((y2-y0)/(x2-x0));
  m1:=n*((y3-y1)/(x3-x1));
  t2:=t*t;
  t3:=t2*t;
  result:=((((2.0*t3)-(3.0*t2))+1.0)*y1)+
          (((3.0*t2)-(2.0*t3))*y2)+
          (((t3-(2.0*t2))+t)*m0)+
          ((t3-t2)*m1);
 end;
const fd255=1/255;
var Counter,NodesPoint,x0,x1,x2,x3,Interpolation:longint;
    x,y0,y1,y2,y3:double;
begin
{$ifdef VSTi}
 try
{$endif}
  if assigned(Envelope) and (Envelope^.NodesCount<>0) then begin
   NodesPoint:=Envelope^.NodesCount-1;
   for Counter:=0 to Envelope^.NodesCount-2 do begin
    if Time<=Envelope^.Nodes^[Counter].Time then begin
     NodesPoint:=Counter;
     break;
    end;
   end;
   x2:=Envelope^.Nodes^[NodesPoint].Time;
   y2:=Envelope^.Nodes^[NodesPoint].Value*fd255;
   Interpolation:=Envelope^.Nodes^[NodesPoint].Interpolation;
   if NodesPoint>0 then begin
    x1:=Envelope^.Nodes^[NodesPoint-1].Time;
    y1:=Envelope^.Nodes^[NodesPoint-1].Value*fd255;
   end else begin
    x1:=x2;
    y1:=y2;
   end;
   if Time<=x1 then begin
    result:=y1;
   end else if x2<=Time then begin
    result:=y2;
   end else if x1<x2 then begin
    if NodesPoint>1 then begin
     x0:=Envelope^.Nodes^[NodesPoint-2].Time;
     y0:=Envelope^.Nodes^[NodesPoint-2].Value*fd255;
    end else begin
     x0:=x1-1;
     y0:=Envelope^.NegValue*fd255;
    end;
    if (NodesPoint+1)<Envelope^.NodesCount then begin
     x3:=Envelope^.Nodes^[NodesPoint+1].Time;
     y3:=Envelope^.Nodes^[NodesPoint+1].Value*fd255;
    end else begin
     x3:=x2+1;
     y3:=Envelope^.PosValue*fd255;
    end;
    x:=(Time-x1)/(x2-x1);
    case Interpolation of
     1:begin
      result:=y1+((y2-y1)*x);
     end;
     2:begin
      result:=CosineInterpolate(x,y1,y2);
     end;
     3:begin
      result:=CubicInterpolate(x,y0,y1,y2,y3);
     end;
     4:begin
      result:=CatmullRomInterpolate(x,x0,y0,x1,y1,x2,y2,x3,y3);
     end;
     else begin
      if Time<x2 then begin
       result:=y1;
      end else begin
       result:=y2;
      end;
     end;
    end;
   end else begin
    result:=y1;
   end;
  end else begin
   result:=0;
  end;
{$ifdef VSTi}
 except
  result:=0;
 end;
{$endif}
end;

procedure SynthEnvelopeSort(Envelope:PSynthEnvelope;NodeNumber:pointer=nil);
var TempNode:TSynthEnvelopeNode;
    i,j:longint;
begin
 if not assigned(Envelope) then begin
  exit;
 end;
 for i:=1 to Envelope^.NodesCount-1 do begin
  if Envelope^.Nodes^[i-1].Time>Envelope^.Nodes^[i].Time then begin
   TempNode:=Envelope^.Nodes^[i];
   j:=i-1;
   while (j>=0) and (Envelope^.Nodes^[j].Time>TempNode.Time) do begin
    Envelope^.Nodes^[j+1]:=Envelope^.Nodes^[j];
    if assigned(NodeNumber) and (j=longint(NodeNumber^)) then begin
     longint(NodeNumber^):=j+1;
    end;
    dec(j);
   end;
   Envelope^.Nodes^[j+1]:=TempNode;
   if assigned(NodeNumber) and (i=longint(NodeNumber^)) then begin
    longint(NodeNumber^):=j+1;
   end;
  end;
 end;
 i:=0;
 while i<Envelope^.NodesCount-1 do begin
  if Envelope^.Nodes^[i].Time>Envelope^.Nodes^[i+1].Time then begin
   TempNode:=Envelope^.Nodes^[i];
   Envelope^.Nodes^[i]:=Envelope^.Nodes^[i+1];
   Envelope^.Nodes^[i+1]:=TempNode;
   if assigned(NodeNumber) then begin
    if i=longint(NodeNumber^) then begin
     longint(NodeNumber^):=i+1;
    end else if (i+1)=longint(NodeNumber^) then begin
     longint(NodeNumber^):=i;
    end;
   end;
   if i>0 then begin
    dec(i);
   end else begin
    inc(i);
   end;
  end else begin
   inc(i);
  end;
 end;
end;

procedure SynthPluckedStringDelayLineInit(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine;Counter,SubCounter,Index:longint);
begin
 FillChar(Instance,sizeof(TSynthPluckedStringDelayLine),#0);
 Instance.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,Index];
end;

procedure SynthPluckedStringDelayLineInitSINCArray(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine);
var FracValue,SincValue,WindowValue,WindowFactor,WindowParameter,
    OtherPosition,HalfPoints,Position:double;
    Counter,Points,ThePoints:longint;
begin
 Points:=PS_INTERPOLATION_WIDTH;
 ThePoints:=Points;
 HalfPoints:=Points*0.5;
 WindowFactor:=(2*PIValue)/ThePoints;
 FracValue:=Instance.LenFrac-0.5;
 for Counter:=0 to Points-1 do begin
  OtherPosition:=Counter-FracValue;
  Position:=OtherPosition-HalfPoints;
  if abs(Position)<EPSILON then begin
   SincValue:=FS_SINC_CUTOFF;
  end else begin
   SincValue:=sin(FS_SINC_CUTOFF*Position*PIValue)/(Position*PIValue);
  end;
  WindowParameter:=OtherPosition*WindowFactor;
  WindowValue:=0.42-(0.50*cos(WindowParameter))+(0.08*cos(2.0*WindowParameter));
  Instance.InterpolationArray[Counter]:=SincValue*WindowValue;
 end;
end;

procedure SynthPluckedStringDelayLineSetDelay(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine;Samples:single;Reset:boolean;Mode:longint);
var Alpha:single;
begin
 if Reset then begin
  Instance.Position:=0;
  fillchar(Instance.AllPassHistories,sizeof(TSynthPluckedStringAllPassHistories),#0);
 end;
 if (abs(Instance.OldSamples-Samples)>=EPSILON) or Reset then begin
  Instance.OldSamples:=Samples;
  Instance.Len:=SoftTRUNC(Samples);
  Instance.LenFrac:=frac(Samples);
  Instance.Mode:=Mode;
  case Instance.Mode of
   psdlmNEAREST:begin
   end;
   psdlmLINEAR:begin
    if abs(Instance.LenFrac)<EPSILON then begin
     Instance.Mode:=psdlmNEAREST;
    end;
   end;
   psdlmLAGRANGE:begin
    if abs(Instance.LenFrac)<EPSILON then begin
     Instance.Mode:=psdlmNEAREST;
    end else begin
     Instance.InterpolationArray[0]:=0.5*(sqr(Instance.LenFrac)-Instance.LenFrac);
     Instance.InterpolationArray[1]:=1.0-sqr(Instance.LenFrac);
     Instance.InterpolationArray[2]:=0.5*(sqr(Instance.LenFrac)+Instance.LenFrac);
    end;
   end;
   psdlmCUBIC:begin
    if abs(Instance.LenFrac)<EPSILON then begin
     Instance.Mode:=psdlmNEAREST;
    end else begin
     Instance.InterpolationArray[0]:=(-0.5*Instance.LenFrac*Instance.LenFrac*Instance.LenFrac)+(1.0*Instance.LenFrac*Instance.LenFrac)-(0.5*Instance.LenFrac);
     Instance.InterpolationArray[1]:=(1.5*Instance.LenFrac*Instance.LenFrac*Instance.LenFrac)-(2.5*Instance.LenFrac*Instance.LenFrac)+1.0;
     Instance.InterpolationArray[2]:=(-1.5*Instance.LenFrac*Instance.LenFrac*Instance.LenFrac)+(2.0*Instance.LenFrac*Instance.LenFrac)+(0.5*Instance.LenFrac);
     Instance.InterpolationArray[3]:=(0.5*Instance.LenFrac*Instance.LenFrac*Instance.LenFrac)-(0.5*Instance.LenFrac*Instance.LenFrac);
    end;
   end;
   psdlmSINC:begin
    if abs(Instance.LenFrac)<EPSILON then begin
     Instance.Mode:=psdlmNEAREST;
    end else begin
     SynthPluckedStringDelayLineInitSINCArray(Track,Instance);
    end;
   end;
   psdlmALLPASSACCESS:begin
    if abs(Instance.LenFrac)<EPSILON then begin
     Instance.Mode:=psdlmNEAREST;
    end else begin
     Alpha:=1.0+Instance.Len-Samples;
     if Alpha<0.5 then begin
      inc(Instance.Len);
      Alpha:=Alpha+1;
     end;
     Instance.AllPassCoef:=(1.0-Alpha)/(1.0+Alpha);
    end;
   end;
   psdlmALLPASSLOGIC:begin
   end;
   psdlmAFTERLAST..255:begin
   end;
  end;
  if Instance.Len<0 then begin
   Instance.Len:=0;
  end else if Instance.Len>=(Track^.InternalSampleRate div 4) then begin
   Instance.Len:=(Track^.InternalSampleRate div 4)-1;
  end;
 end;
end;

function SynthPluckedStringDelayAdjustPosition(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine;Position:longint):longint;
begin
 while (Instance.Len>0) and (Position<0) do begin
  inc(Position,Instance.Len);
 end;
 while (Instance.Len>0) and (Position>=Instance.Len) do begin
  dec(Position,Instance.Len);
 end;
 if Position<0 then begin
  Position:=0;
  end else if Instance.Len>=(Track^.InternalSampleRate div 4) then begin
   Instance.Len:=(Track^.InternalSampleRate div 4)-1;
 end;
 result:=Position;
end;

procedure SynthPluckedStringDelayLineUpdate(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine;Sample:single);
begin
 Instance.Position:=SynthPluckedStringDelayAdjustPosition(Track,Instance,Instance.Position);
 Instance.Buffer[Instance.Position]:=Sample;
 inc(Instance.Position);
 if Instance.Position>=Instance.Len then begin
  Instance.Position:=0;
 end;
end;

function SynthPluckedStringDelayLineGet(Track:PSynthTrack;var Instance:TSynthPluckedStringDelayLine;Pos:longint;var AllPassHistory:TSynthPluckedStringAllPassHistory):single;
var x:single;
begin
 Pos:=SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+Instance.Position);
 case Instance.Mode of
  psdlmNEAREST:begin
   result:=Instance.Buffer[Pos];
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmLINEAR:begin
   x:=Instance.Buffer[Pos];
   result:=x+((Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+1)]-x)*Instance.LenFrac);
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmLAGRANGE:begin
   result:=(Instance.InterpolationArray[0]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos-1)])+
           (Instance.InterpolationArray[1]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos)])+
           (Instance.InterpolationArray[2]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+1)]);
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmCUBIC:begin
   result:=(Instance.InterpolationArray[0]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos-1)])+
           (Instance.InterpolationArray[1]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos)])+
           (Instance.InterpolationArray[2]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+1)])+
           (Instance.InterpolationArray[3]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+2)]);
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmSINC:begin
   result:=(Instance.InterpolationArray[0]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos-2)])+
           (Instance.InterpolationArray[1]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos-1)])+
           (Instance.InterpolationArray[2]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos)])+
           (Instance.InterpolationArray[3]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+1)])+
           (Instance.InterpolationArray[4]*Instance.Buffer[SynthPluckedStringDelayAdjustPosition(Track,Instance,Pos+2)]);
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmALLPASSACCESS:begin
   x:=Instance.Buffer[Pos];
   result:=AllPassHistory.x1+(Instance.AllPassCoef*x)-(Instance.AllPassCoef*AllPassHistory.y1);
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   AllPassHistory.y1:=result;
   AllPassHistory.x1:=x;
  end;
  psdlmALLPASSLOGIC:begin
   result:=Instance.Buffer[Pos];
   longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
  psdlmAFTERLAST..255:begin
   result:=0;
  end;
 end;
end;

procedure SynthPluckedStringInit(Track:PSynthTrack;var Instance:TSynthPluckedString);
begin
 Instance.UpperRail.Position:=0;
 Instance.UpperRail.Len:=0;
 Instance.UpperRail.LenFrac:=0;
 Instance.UpperRail.Mode:=psdlmALLPASSLOGIC;
 Instance.LowerRail.Position:=0;
 Instance.LowerRail.Len:=0;
 Instance.LowerRail.LenFrac:=0;
 Instance.LowerRail.Mode:=psdlmALLPASSLOGIC;
 Instance.State:=0.0;
 Instance.Location:=0;
 Instance.Seed:=Track^.Seed;
 Track^.Seed:=(Track^.Seed*1664525)+1013904223;
 Instance.ReflectionFactor:=0.5;
 Instance.AllPassInLoop:=false;
 Instance.AllPassCoef:=0;
 Instance.AllPassLast:=0;
end;

function SynthPluckedStringBridgeReflection(Track:PSynthTrack;var Instance:TSynthPluckedString;Sample:single):single;
begin
 Instance.State:=Instance.State+((Sample-Instance.State)*Instance.ReflectionFactor);
 longword(pointer(@Instance.State)^):=longword(pointer(@Instance.State)^) and longword($ffffffff+longword(((((longword(pointer(@Instance.State)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 result:=Instance.State;
end;

function SynthPluckedStringProcess(Track:PSynthTrack;var Instance:TSynthPluckedString;Width:longint;Input:single):single;
var yup,ylp,q:single;
begin
 result:=SynthPluckedStringDelayLineGet(Track,Instance.UpperRail,Instance.Location,Instance.UpperRail.AllPassHistories[0])+
         SynthPluckedStringDelayLineGet(Track,Instance.LowerRail,Instance.LowerRail.Len-Instance.Location,Instance.LowerRail.AllPassHistories[0]);
 yup:=-SynthPluckedStringDelayLineGet(Track,Instance.UpperRail,Instance.UpperRail.Len-(1+Width),Instance.UpperRail.AllPassHistories[1]);
 ylp:=-SynthPluckedStringBridgeReflection(Track,Instance,SynthPluckedStringDelayLineGet(Track,Instance.LowerRail,Width,Instance.LowerRail.AllPassHistories[1]));
 if Instance.UpperRail.Mode=psdlmALLPASSLOGIC then begin
  q:=ylp+(Instance.AllPassCoef*Instance.AllPassLast);
  longword(pointer(@q)^):=longword(pointer(@q)^) and longword($ffffffff+longword(((((longword(pointer(@q)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  ylp:=(-Instance.AllPassCoef*q)+Instance.AllPassLast;
  Instance.AllPassLast:=q;
 end;
 SynthPluckedStringDelayLineUpdate(Track,Instance.UpperRail,ylp+Input);
 SynthPluckedStringDelayLineUpdate(Track,Instance.LowerRail,yup);
end;

procedure SynthPluckedStringNoteOn(Track:PSynthTrack;var Instance:TSynthPluckedString;Pitch,Pick,PickUp:single;Reset:boolean;Mode:longint);
var i,j:longint;
    f,RailLength,us,ds,k,df:single;
    DoIt:boolean;
begin
 DoIt:=false;
 case Mode of
  psdlmALLPASSLOGIC:begin
   RailLength:=(Track^.InternalSampleRate/Pitch)-1.0;
   df:=frac(RailLength);
   if df<EPSILON then begin
    df:=1.0+EPSILON;
    RailLength:=RailLength-1.0;
   end;
   RailLength:=RailLength*0.5;
  end;
  else begin
   RailLength:=(Track^.InternalSampleRate*0.5)/Pitch;
   df:=0.0;
  end;
 end;
 if RailLength>=(Track^.InternalSampleRate div 4) then begin
  RailLength:=(Track^.InternalSampleRate div 4)-1;
 end;
 SynthPluckedStringDelayLineSetDelay(Track,Instance.UpperRail,RailLength,Reset,Mode);
 SynthPluckedStringDelayLineSetDelay(Track,Instance.LowerRail,RailLength,Reset,Mode);
 if Reset then begin
  Instance.Seed:=($1337c0d3 xor longword(pointer(@Pitch)^))*($deadbeef-longword(pointer(@Pick)^))*($c001babe xor longword(pointer(@PickUp)^));
  j:=SoftTRUNC((RailLength*Pick)+0.5);
  if j<1 then begin
   j:=1;
  end else if j>=(Instance.UpperRail.Len-1) then begin
   j:=Instance.UpperRail.Len-2;
  end;
  us:=0.25/j;
  ds:=0.25/(Instance.UpperRail.Len-(j+1));
  for i:=0 to j-1 do begin
   Instance.UpperRail.Buffer[i]:=i*us;
   Instance.LowerRail.Buffer[i]:=i*us;
  end;
  for i:=j to Instance.UpperRail.Len-1 do begin
   Instance.UpperRail.Buffer[i]:=(Instance.UpperRail.Len-(i+1))*ds;
   Instance.LowerRail.Buffer[i]:=(Instance.LowerRail.Len-(i+1))*ds;
  end;
  for i:=0 to Instance.UpperRail.Len-1 do begin
   Instance.Seed:=(Instance.Seed*1664525)+1013904223;
   longword(pointer(@f)^):=((Instance.Seed shr 9) and $7fffff) or $40000000;
   f:=f-3;
   Instance.UpperRail.Buffer[i]:=Instance.UpperRail.Buffer[i]+(f*0.25);
  end;
  for i:=0 to Instance.UpperRail.Len-1 do begin
   Instance.Seed:=(Instance.Seed*1664525)+1013904223;
   longword(pointer(@f)^):=((Instance.Seed shr 9) and $7fffff) or $40000000;
   f:=f-3;
   Instance.LowerRail.Buffer[i]:=Instance.LowerRail.Buffer[i]+(f*0.25);
  end;
  Instance.OldLen:=Instance.UpperRail.Len;
  DoIt:=true;
 end else if Instance.OldLen<>Instance.UpperRail.Len then begin
  if Instance.OldLen<Instance.UpperRail.Len then begin
   DoIt:=true;
   j:=0;
   for i:=Instance.OldLen to Instance.UpperRail.Len-1 do begin
    Instance.LowerRail.Buffer[i]:=Instance.LowerRail.Buffer[j];
    Instance.UpperRail.Buffer[i]:=Instance.UpperRail.Buffer[j];
    inc(j);
    if j>=Instance.OldLen then begin
     j:=0;
    end;
   end;
  end;
  Instance.OldLen:=Instance.UpperRail.Len;
 end;
 Instance.Location:=SoftTRUNC(PickUp*RailLength);
 if DoIt and (Mode=psdlmALLPASSLOGIC) then begin
  k:=(Pitch*2*pi*Track^.InternalSampleRateFactor)*Track^.InternalSampleRateFactor;
  Instance.AllPassCoef:=-(sin((k-(k*df))*0.5)/sin((k+(k*df))*0.5));
  longword(pointer(@Instance.AllPassCoef)^):=longword(pointer(@Instance.AllPassCoef)^) and longword($ffffffff+longword(((((longword(pointer(@Instance.AllPassCoef)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end;
 if Reset then begin
  Instance.AllPassLast:=0;
 end;
end;

function SynthADPCMIMADecompressSample(var ADPCMIMAState:TSynthADPCMIMAState;nibble:byte):longint;
begin
 inc(ADPCMIMAState.PrevSample,(ADPCMIMAStepTable[ADPCMIMAState.StepIndex]*ADPCMIMADifferenceLookUpTable[nibble and $f]) div 8);
 if ADPCMIMAState.PrevSample<-32768 then begin
  ADPCMIMAState.PrevSample:=-32768;
 end else if ADPCMIMAState.PrevSample>32767 then begin
  ADPCMIMAState.PrevSample:=32767;
 end;
 ADPCMIMAState.StepIndex:=ADPCMIMAState.StepIndex+ADPCMIMAIndexTable[nibble];
 if ADPCMIMAState.StepIndex<0 then begin
  ADPCMIMAState.StepIndex:=0;
 end else if ADPCMIMAState.StepIndex>88 then begin
  ADPCMIMAState.StepIndex:=88;
 end;
 result:=ADPCMIMAState.PrevSample;
end;

{$ifdef VSTi}
function SynthADPCMIMACompressSample(var ADPCMIMAState:TSynthADPCMIMAState;sample:smallint):byte;
{$ifndef BR808EXEMUSPLAYER}
var Delta,nibble:longint;
begin
 Delta:=sample-ADPCMIMAState.PrevSample;
 nibble:=(abs(delta)*4) div ADPCMIMAStepTable[ADPCMIMAState.StepIndex];
 if nibble>7 then begin
  nibble:=7;
 end;
 if delta<0 then begin
  nibble:=nibble or 8;
 end;
 ADPCMIMAState.PrevSample:=ADPCMIMAState.PrevSample+((ADPCMIMAStepTable[ADPCMIMAState.StepIndex]*ADPCMIMADifferenceLookUpTable[nibble and $f]) div 8);
 if ADPCMIMAState.PrevSample<-32768 then begin
  ADPCMIMAState.PrevSample:=-32768;
 end else if ADPCMIMAState.PrevSample>32767 then begin
  ADPCMIMAState.PrevSample:=32767;
 end;
 ADPCMIMAState.StepIndex:=ADPCMIMAState.StepIndex+ADPCMIMAIndexTable[nibble];
 if ADPCMIMAState.StepIndex<0 then begin
  ADPCMIMAState.StepIndex:=0;
 end else if ADPCMIMAState.StepIndex>88 then begin
  ADPCMIMAState.StepIndex:=88;
 end;
 result:=nibble;
end;
{$else}
begin
end;
{$endif}
{$endif}

procedure SynthCheckBuffer(Buffer:pointer;Samples:longint); {$ifdef cpu386}register;{$endif}
var SampleCounter:longint;
begin
 for SampleCounter:=1 to Samples do begin
  if psingle(Buffer)^>1 then begin
   psingle(Buffer)^:=0;
  end;
  inc(plongword(Buffer));
 end;
end;

{$ifndef csdk}
procedure SynthCleanBuffer(Buffer:pointer;Samples:longint); {$ifdef cpu386}assembler; register;{$endif}
{$ifdef cpu386}
asm
 mov ecx,edx
 test ecx,ecx
 jz @Done
  mov edx,eax
  push ecx
   shr ecx,2
   test ecx,ecx
   jz @SubDoneA
    @LoopA:
     mov eax,dword ptr [edx]
     and eax,$7f800000
     add eax,$00800000
     and eax,$7f800000
     sub eax,$01000000
     shr eax,31
     dec eax
     and dword ptr [edx],eax
     add edx,4
     mov eax,dword ptr [edx]
     and eax,$7f800000
     add eax,$00800000
     and eax,$7f800000
     sub eax,$01000000
     shr eax,31
     dec eax
     and dword ptr [edx],eax
     add edx,4
     mov eax,dword ptr [edx]
     and eax,$7f800000
     add eax,$00800000
     and eax,$7f800000
     sub eax,$01000000
     shr eax,31
     dec eax
     and dword ptr [edx],eax
     add edx,4
     mov eax,dword ptr [edx]
     and eax,$7f800000
     add eax,$00800000
     and eax,$7f800000
     sub eax,$01000000
     shr eax,31
     dec eax
     and dword ptr [edx],eax
     add edx,4
     dec ecx
    jnz @LoopA
   @SubDoneA:
  pop ecx
  and ecx,3
  test ecx,ecx
  jz @SubDoneB
   @LoopB:
    mov eax,dword ptr [edx]
    and eax,$7f800000
    add eax,$00800000
    and eax,$7f800000
    sub eax,$01000000
    shr eax,31
    dec eax
    and dword ptr [edx],eax
    add edx,4
    dec ecx
   jnz @LoopB
  @SubDoneB:
 @Done:
end;
{$else}
var SampleCounter:longint;
begin
 for SampleCounter:=1 to Samples shr 2 do begin
  longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(plongword(Buffer));
  longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(plongword(Buffer));
  longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(plongword(Buffer));
  longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(plongword(Buffer));
 end;
 for SampleCounter:=1 to Samples and 3 do begin
  longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(plongword(Buffer));
 end;
end;
{$endif}
{$endif}

{$ifdef UseSSE}
procedure SynthFillFloatSSE(DstBuffer:PSynthFloatValue;Value:single;Count:longint); assembler; register;
asm
 mov eax,dword ptr DstBuffer

 mov ecx,dword ptr Count
 test ecx,ecx
 jz @Done

  movss xmm0,dword ptr Value
  shufps xmm0,xmm0,0

  test eax,15
  jnz @Unaligned
   @Aligned:

    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:
       movaps [eax],xmm0
       movaps [eax+16],xmm0
       movaps [eax+32],xmm0
       movaps [eax+48],xmm0
       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:
     movups [eax],xmm0
     movups [eax+16],xmm0
     movups [eax+32],xmm0
     movups [eax+48],xmm0
     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthFillFloat(DstBuffer:PSynthFloatValue;Value:single;Count:longint);
var Counter:longint;
begin
 for Counter:=1 to Count shr 2 do begin
  DstBuffer^:=Value;
  inc(DstBuffer);
  DstBuffer^:=Value;
  inc(DstBuffer);
  DstBuffer^:=Value;
  inc(DstBuffer);
  DstBuffer^:=Value;
  inc(DstBuffer);
 end;
 for Counter:=1 to Count and 3 do begin
  DstBuffer^:=Value;
  inc(DstBuffer);
 end;
end;

{$ifdef UseSSE}
procedure SynthFloatBufferMulFloatSSE(DstBuffer:PSynthFloatValue;Value:single;Count:longint); assembler; register;
asm
 mov eax,dword ptr DstBuffer

 mov ecx,dword ptr Count
 test ecx,ecx
 jz @Done

  movss xmm4,dword ptr Value
  shufps xmm4,xmm4,0

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       mulps xmm0,xmm4

       movaps xmm1,[eax+16]
       mulps xmm1,xmm4

       movaps xmm2,[eax+32]
       mulps xmm2,xmm4

       movaps xmm3,[eax+48]
       mulps xmm3,xmm4

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       mulps xmm0,xmm4
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthFloatBufferMulFloat(DstBuffer:PSynthFloatValue;Value:single;Count:longint);
var Counter:longint;
begin
 for Counter:=1 to Count shr 2 do begin
  DstBuffer^:=DstBuffer^*Value;
  inc(DstBuffer);
  DstBuffer^:=DstBuffer^*Value;
  inc(DstBuffer);
  DstBuffer^:=DstBuffer^*Value;
  inc(DstBuffer);
  DstBuffer^:=DstBuffer^*Value;
  inc(DstBuffer);
 end;
 for Counter:=1 to Count and 3 do begin
  DstBuffer^:=DstBuffer^*Value;
  inc(DstBuffer);
 end;
end;

{$ifdef UseSSE}
procedure SynthSampleBufferMulFloatSSE(DstBuffer:PSynthBufferSample;Value:single;Count:longint); assembler; register;
asm
 mov eax,dword ptr DstBuffer

 mov ecx,dword ptr Count
 test ecx,ecx
 jz @Done

  add ecx,ecx
  
  movss xmm4,dword ptr Value
  shufps xmm4,xmm4,0

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       mulps xmm0,xmm4

       movaps xmm1,[eax+16]
       mulps xmm1,xmm4

       movaps xmm2,[eax+32]
       mulps xmm2,xmm4

       movaps xmm3,[eax+48]
       mulps xmm3,xmm4

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       mulps xmm0,xmm4
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthSampleBufferMulFloat(DstBuffer:PSynthBufferSample;Value:single;Count:longint);
var Counter:longint;
begin
 for Counter:=1 to Count shr 2 do begin
  DstBuffer^.Left:=DstBuffer^.Left*Value;
  DstBuffer^.Right:=DstBuffer^.Right*Value;
  inc(DstBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*Value;
  DstBuffer^.Right:=DstBuffer^.Right*Value;
  inc(DstBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*Value;
  DstBuffer^.Right:=DstBuffer^.Right*Value;
  inc(DstBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*Value;
  DstBuffer^.Right:=DstBuffer^.Right*Value;
  inc(DstBuffer);
 end;
 for Counter:=1 to Count and 3 do begin
  DstBuffer^.Left:=DstBuffer^.Left*Value;
  DstBuffer^.Right:=DstBuffer^.Right*Value;
  inc(DstBuffer);
 end;
end;

{$ifdef UseSSE}
procedure SynthFloatBufferMulFloatBufferSSE(DstBuffer,SrcBuffer:PSynthFloatValue;Count:longint); assembler; register;
asm
 mov eax,dword ptr DstBuffer
 mov edx,dword ptr SrcBuffer

 mov ecx,dword ptr Count
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        mulps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        mulps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthFloatBufferMulFloatBuffer(DstBuffer,SrcBuffer:PSynthFloatValue;Count:longint); {$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Count shr 2 do begin
  DstBuffer^:=DstBuffer^*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^:=DstBuffer^*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^:=DstBuffer^*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^:=DstBuffer^*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
 end;
 for Counter:=1 to Count and 3 do begin
  DstBuffer^:=DstBuffer^*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
 end;
end;

{$ifdef UseSSE}
procedure SynthSampleBufferMulFloatBufferSSE(DstBuffer:PSynthBufferSample;SrcBuffer:PSynthFloatValue;Count:longint); assembler; register;
asm
 mov eax,dword ptr DstBuffer
 mov edx,dword ptr SrcBuffer

 mov ecx,dword ptr Count
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       movlps xmm4,[edx]
       shufps xmm4,xmm4,$50
       mulps xmm0,xmm4

       movaps xmm1,[eax+16]
       movlps xmm4,[edx+8]
       shufps xmm4,xmm4,$50
       mulps xmm1,xmm4

       movaps xmm2,[eax+32]
       movlps xmm4,[edx+16]
       shufps xmm4,xmm4,$50
       mulps xmm2,xmm4

       movaps xmm3,[eax+48]
       movlps xmm4,[edx+24]
       shufps xmm4,xmm4,$50
       mulps xmm3,xmm4

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       add edx,32
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       movlps xmm4,[edx]
       shufps xmm4,xmm4,$50
       mulps xmm0,xmm4
       movaps [eax],xmm0
       add eax,16
       add edx,8
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @GoNormalLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movlps xmm4,[edx]
     shufps xmm4,xmm4,$50
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     movlps xmm4,[edx+8]
     shufps xmm4,xmm4,$50
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     movlps xmm4,[edx+16]
     shufps xmm4,xmm4,$50
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     movlps xmm4,[edx+24]
     shufps xmm4,xmm4,$50
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,32
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movlps xmm4,[edx]
     shufps xmm4,xmm4,$50
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,8
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @GoNormalLoop:
  push ecx
   shr ecx,1
   jz @SkipNormalLoop
    @NormalLoop:
     movss xmm2,dword ptr [edx]
     movss xmm0,dword ptr [eax]
     movss xmm1,dword ptr [eax+4]
     mulss xmm0,xmm2
     mulss xmm1,xmm2
     movss dword ptr [eax],xmm0
     movss dword ptr [eax+4],xmm1
     add eax,8
     add edx,4
     dec ecx
    jnz @NormalLoop
   @SkipNormalLoop:
  pop ecx

 @Done:
end;
{$endif}

procedure SynthSampleBufferMulFloatBuffer(DstBuffer:PSynthBufferSample;SrcBuffer:PSynthFloatValue;Count:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Count shr 2 do begin
  DstBuffer^.Left:=DstBuffer^.Left*SrcBuffer^;
  DstBuffer^.Right:=DstBuffer^.Right*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*SrcBuffer^;
  DstBuffer^.Right:=DstBuffer^.Right*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*SrcBuffer^;
  DstBuffer^.Right:=DstBuffer^.Right*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
  DstBuffer^.Left:=DstBuffer^.Left*SrcBuffer^;
  DstBuffer^.Right:=DstBuffer^.Right*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
 end;
 for Counter:=1 to Count and 3 do begin
  DstBuffer^.Left:=DstBuffer^.Left*SrcBuffer^;
  DstBuffer^.Right:=DstBuffer^.Right*SrcBuffer^;
  inc(DstBuffer);
  inc(SrcBuffer);
 end;
end;

{$ifdef VSTi}
{$ifdef BR808SPEECH}
procedure SynthSpeechConvertSpeechText(Track:PSynthTrack;InstrumentNumber,SpeechTextNumber:longint;InputText:string);
var SpeechSegmentList:PSynthSpeechSegmentList;
    Counter:longint;
begin
 if (InstrumentNumber in [0..MaxInstruments-1]) and (SpeechTextNumber in [0..MaxSpeechTexts-1]) then begin
  SpeechSegmentList:=@Track^.SpeechSegmentLists[InstrumentNumber,SpeechTextNumber];
  if SpeechConvertPhonemsToSegmentList(SpeechSegmentList^,SpeechConvertTextToPhonems(InputText)) then begin
   for Counter:=0 to NumberOfChannels-1 do begin
    if Track^.Channels[Counter].SpeechInstance.SegmentList.List=SpeechSegmentList then begin
     Track^.Channels[Counter].SpeechInstance.SegmentList.Position:=-1;
     Track^.Channels[Counter].SpeechInstance.FrameRemain:=0;
     Track^.Channels[Counter].SpeechInstance.TimeRemain:=0;
    end;
   end;
  end;
 end;
end;
{$endif}
{$endif}

{$ifdef BR808SPEECH}
procedure SynthSpeechInitResonator(Track:PSynthTrack;var SpeechInstance:TSynthSpeechInstanceData;var Resonator:TSynthSpeechResonator;F,BW,Gain:single;Cascade:longint);
var r,l:double;
begin
 // Attempt to be clever and automatically adjust resonator presence based
 // on sample rate - it does not work very well.
 if ((2*f)-bw)<=Track^.InternalSampleRate then begin
  if (2*(f+bw))>Track^.InternalSampleRate then begin
   // This is a little dubious - keep lower skirt in place and
   // move centre frequency so upper skirt hits Nyquist freq
   l:=f-bw;
   f:=((Track^.InternalSampleRate*0.5)+l)*0.5;
   bw:=f-l;
  end;
  r:=exp(-PI*BW*Track^.InternalSampleRateFactor);
  Resonator.C:=-sqr(r);
  Resonator.B:=r*2*cos(F*(2*PI*Track^.InternalSampleRateFactor));
  Resonator.A:=(1-Resonator.B-Resonator.C)*Gain;
 end else begin
  // lower skirt of resonator exceeds Nyquist limit - make it a no-op,
  // i.e. pass if cascade, zero if parallel
  Resonator.A:=Cascade;
  Resonator.B:=0;
  Resonator.C:=0;
 end;
 longword(pointer(@Resonator.A)^):=longword(pointer(@Resonator.A)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@Resonator.B)^):=longword(pointer(@Resonator.B)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@Resonator.C)^):=longword(pointer(@Resonator.C)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.C)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthSpeechInitAntiResonator(Track:PSynthTrack;var SpeechInstance:TSynthSpeechInstanceData;var Resonator:TSynthSpeechResonator;F,BW,Gain:single;Cascade:longint);
begin
 SynthSpeechInitResonator(Track,SpeechInstance,Resonator,F,BW,Gain,Cascade);
 Resonator.A:=1/Resonator.A;
 Resonator.B:=Resonator.B*(-Resonator.A);
 Resonator.C:=Resonator.C*(-Resonator.A);
 longword(pointer(@Resonator.A)^):=longword(pointer(@Resonator.A)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@Resonator.B)^):=longword(pointer(@Resonator.B)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@Resonator.C)^):=longword(pointer(@Resonator.C)^) and longword($ffffffff+longword(((((longword(pointer(@Resonator.C)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthSpeechCopyResonator(var TargetResonator:TSynthSpeechResonator;const SourceResonator:TSynthSpeechResonator);
begin
 TargetResonator.A:=SourceResonator.A;
 TargetResonator.B:=SourceResonator.B;
 TargetResonator.C:=SourceResonator.C;
end;

function SynthSpeechResonatorIIR(Track:PSynthTrack;var SpeechInstance:TSynthSpeechInstanceData;var Resonator:TSynthSpeechResonator;inV:single):single; {12 dB bi-quad}
begin
 result:=(Resonator.A*inV)+(Resonator.B*Resonator.P1)+(Resonator.C*Resonator.P2);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 Resonator.P2:=Resonator.P1;
 Resonator.P1:=result;
end;

function SynthSpeechConvDB(var SpeechInstance:TSynthSpeechInstanceData;dB:single):single;
const fci6=1.0/6.0;
begin
 result:=power(2.0,(dB-(255-SpeechInstance.Gain))*fci6);
end;

procedure SynthSpeechSetTransform(var SpeechInstance:TSynthSpeechInstanceData;var Slope:TSynthSpeechTransform;SegmentA,SegmentB:PSynthSpeechSegment;Ext:longint);
var Counter:longint;
begin
 for Counter:=0 to NumberOfSegmentParameters-1 do begin
  if Ext<>0 then begin
   Slope[Counter].Time:=SegmentA^.Parameters[Counter].Extern*(SpeechInstance.Speed+SpeechInstance.CurrentSegmentItem.DurationTimeFactor);
  end else begin
   Slope[Counter].Time:=SegmentA^.Parameters[Counter].Intern*(SpeechInstance.Speed+SpeechInstance.CurrentSegmentItem.DurationTimeFactor);
  end;
  if Slope[Counter].Time<>0 then begin
   Slope[Counter].Value:=SegmentA^.Parameters[Counter].Fixed+(SegmentA^.Parameters[Counter].Prop*SegmentB^.Parameters[Counter].Steady)*0.01;
  end else begin
   Slope[Counter].Value:=SegmentB^.Parameters[Counter].Steady;
  end;
 end;
end;

function SynthSpeechFilter(var Filter:TSynthSpeechFilter;Value:single):single;
begin
 Filter.V:=(Filter.A*Value)+(Filter.B*Filter.V);
 longword(pointer(@Filter.V)^):=longword(pointer(@Filter.V)^) and longword($ffffffff+longword(((((longword(pointer(@Filter.V)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 result:=Filter.V;
end;

function SynthSpeechLinear(A,B:single;Time,Duration:longint):single;
begin
 if Time<=0 then begin
  result:=A;
 end else if Time>=Duration then begin
  result:=B;
 end else begin
  result:=A+((B-A)*(Time/Duration));
 end;
end;

function SynthSpeechInterpolate(var StartSlope,EndSlope:TSynthSpeechSlope;Middle:single;Time,Duration:longint):single;
var Steady,F,SP,EP:single;
begin
 Steady:=Duration-(StartSlope.Time+EndSlope.Time);
 if Steady>=0 then begin
  if Time<StartSlope.Time then begin
   result:=SynthSpeechLinear(StartSlope.Value,Middle,Time,StartSlope.Time);
  end else begin
   Time:=Time-StartSlope.Time;
   if Time<=Steady then begin
    result:=Middle;
   end else begin
    result:=SynthSpeechLinear(Middle,EndSlope.Value,SoftTRUNC(Time-Steady),EndSlope.Time);
   end;
  end;
 end else begin
  if Duration<>0 then begin
   F:=1-(Time/Duration);
  end else begin
   F:=1;
  end;
  SP:=SynthSpeechLinear(StartSlope.Value,Middle,Time,StartSlope.Time);
  EP:=SynthSpeechLinear(EndSlope.Value,Middle,Duration-Time,EndSlope.Time);
  result:=(F*SP)+((1-F)*EP);
 end;
end;

procedure SynthSpeechGetNextSegment(var SpeechInstance:TSynthSpeechInstanceData); {$ifdef FPC}inline;{$endif}
begin
 with SpeechInstance do begin
  LastSegmentItem:=CurrentSegmentItem;  
  CurrentSegmentItem:=NewSegmentItem;
  if assigned(SegmentList.List) and ((SegmentList.Position<0) or (SegmentList.Position>=SegmentList.List^.ItemCount)) then begin
   SegmentList.Position:=0;
  end;
  if assigned(SegmentList.List) and (SegmentList.Position<SegmentList.List^.ItemCount) then begin
   NewSegmentItem:=SegmentList.List^.Items[SegmentList.Position];
   inc(SegmentList.Position);
  end else begin
   FillChar(NewSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
   NewSegmentItem.SegmentIndex:=ssiEND;
  end;
  LastSegment:=CurrentSegment;
  CurrentSegment:=NewSegment;
  NewSegment:=@SpeechSegmentsArray[NewSegmentItem.SegmentIndex];
  WaitForEvent:=CurrentSegmentItem.WaitForEvent;
  if (WaitForEvent<>wfeNONE) and (CurrentSegment=@SpeechSegmentsArray[ssiEND]) then begin
   Duration:=CurrentSegmentItem.DurationTimeFactor+SpeechInstance.Speed;
  end else begin
   Duration:=CurrentSegment^.Duration*(SpeechInstance.Speed+CurrentSegmentItem.DurationTimeFactor);
  end;
 end;
end;

procedure SynthSpeechNextSegment(var SpeechInstance:TSynthSpeechInstanceData); {$ifdef FPC}inline;{$endif}
begin
 with SpeechInstance do begin
  if Active then begin
   SynthSpeechGetNextSegment(SpeechInstance);
  end;
  if CurrentSegment^.Rank>LastSegment^.Rank then begin
   SynthSpeechSetTransform(SpeechInstance,StartSegmentValues,CurrentSegment,LastSegment,0);
  end else begin
   SynthSpeechSetTransform(SpeechInstance,StartSegmentValues,LastSegment,CurrentSegment,1);
  end;
  if NewSegment^.Rank>CurrentSegment^.Rank then begin
   SynthSpeechSetTransform(SpeechInstance,EndSegmentValues,NewSegment,CurrentSegment,1);
  end else begin
   SynthSpeechSetTransform(SpeechInstance,EndSegmentValues,CurrentSegment,NewSegment,0);
  end;
  Time:=0;
  TimeRemain:=Duration;
 end;
end;

procedure SynthSpeechCheckOnNewFrame(Track:PSynthTrack;var SpeechInstance:TSynthSpeechInstanceData;Remain{$ifdef textdebug},DebugOfs{$endif}:longint); {$ifdef FPC}inline;{$endif}
var Counter:longint;
    p:single;
begin
 with SpeechInstance do begin
  if (FrameRemain<=0) or (SegmentList.Position<0) then begin
   if (WaitForEvent<>wfeNONE) and (TimeRemain<=0) then begin
    FrameRemain:=Remain;
   end else begin
    if (TimeRemain<=0) or (SegmentList.Position<0) then begin
     WaitForEvent:=wfeNONE;
{$ifdef textdebug}
     if not Track^.DebugWait then begin
      writeln(Track^.TextDebug,Track^.TimeDebug+DebugOfs:20);
     end;
{$endif}
     SynthSpeechNextSegment(SpeechInstance);
    end else begin
     dec(TimeRemain);
     inc(Time);
    end;
    if Active then begin
     FrameRemain:=SoftTRUNC(((FrameLength*Track^.InternalSampleRate)*0.001)+0.5);
    end else begin
     FrameRemain:=Remain;
    end;
   end;
   if FrameRemain<>0 then begin
    Factor:=1/FrameRemain;
   end else begin
    Factor:=0;
   end;
   for Counter:=0 to NumberOfSegmentParameters-1 do begin
    TimeParameters[Counter]:=SynthSpeechFilter(Filter[Counter],SynthSpeechInterpolate(StartSegmentValues[Counter],EndSegmentValues[Counter],CurrentSegment.Parameters[Counter].Steady,Time,Duration));
   end;
   for Counter:=0 to 2 do begin
    Frame[fF1+Counter]:=TimeParameters[SPF1+Counter];
    Frame[fB1+Counter]:=TimeParameters[SPB1+Counter];
   end;
   Frame[fF4]:=F4;
   Frame[fF5]:=F5;
   Frame[fF6]:=F6;
   Frame[fB4]:=B4;
   Frame[fB5]:=B5;
   Frame[fB6]:=B6;
   Frame[fA1]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA1]+AdjustAMP)*0.4;   // -7.96 dB
   Frame[fA2]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA2]+AdjustAMP)*0.15;  // -16.5 dB
   Frame[fA3]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA3]+AdjustAMP)*0.06;  // -24.4 dB
   Frame[fA4]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA4]+AdjustAMP)*0.04;  // -28.0 dB
   Frame[fA5]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA5]+AdjustAMP)*0.022; // -33.2 dB
   Frame[fA6]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPA6]+AdjustAMP)*0.03;  // -30.5 dB
   Frame[fCascadeVoicing]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPAV]-7);
   Frame[fParallelVoicing]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPAV]);
   Frame[fAspiration]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPASP])*0.05;
   Frame[fByPass]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPAB])*0.05;
   Frame[fFrication]:=SynthSpeechConvDB(SpeechInstance,TimeParameters[SPAF])*0.25;
   Frame[fFN]:=TimeParameters[SPFN];
   p:=power(2,Color*fci64);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[0],Frame[fF1]*p,Frame[fB1],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[1],Frame[fF2]*p,Frame[fB2],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[2],Frame[fF3]*p,Frame[fB3],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[3],Frame[fF4]*p,Frame[fB4],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[4],Frame[fF5]*p,Frame[fB5],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].CascadeResonator[5],Frame[fF6]*p,Frame[fB6],1,1);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[0],Frame[fF1]*p,Frame[fB1],Frame[fA1],0);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[1],Frame[fF2]*p,Frame[fB2],Frame[fA2],0);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[2],Frame[fF3]*p,Frame[fB3],Frame[fA3],0);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[3],Frame[fF4]*p,Frame[fB4],Frame[fA4],0);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[4],Frame[fF5]*p,Frame[fB5],Frame[fA5],0);
   SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ParallelResonator[5],Frame[fF6]*p,Frame[fB6],Frame[fA6],0);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[0],Channel[0].CascadeResonator[0]);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[1],Channel[0].CascadeResonator[1]);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[2],Channel[0].CascadeResonator[2]);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[3],Channel[0].CascadeResonator[3]);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[4],Channel[0].CascadeResonator[4]);
   SynthSpeechCopyResonator(Channel[1].CascadeResonator[5],Channel[0].CascadeResonator[5]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[0],Channel[0].ParallelResonator[0]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[1],Channel[0].ParallelResonator[1]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[2],Channel[0].ParallelResonator[2]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[3],Channel[0].ParallelResonator[3]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[4],Channel[0].ParallelResonator[4]);
   SynthSpeechCopyResonator(Channel[1].ParallelResonator[5],Channel[0].ParallelResonator[5]);
  end;
 end;
end;

procedure SynthSpeechProcess(Track:PSynthTrack;var SpeechInstance:TSynthSpeechInstanceData;Buffer:PSynthBufferSample;BufferSamples:longint);
var SampleCounter,SampleCount,Remain,ChannelIndex,Processed:longint;
    Noise,Source,SourceCascade,SourceParallel,Output,Aspiration,Frication,
    NoiseFactor,CascadeFactor,ParallelFactor,AspirationFactor,
    FricationFactor:single;
    NoiseSeed:longword;
    WorkBuffer:PSynthBufferSample;
begin
 with SpeechInstance do begin
  SynthSpeechInitResonator(Track,SpeechInstance,Channel[0].ResonatorOut,0,Track^.InternalSampleRate*0.5,2,0);
  SynthSpeechInitResonator(Track,SpeechInstance,Channel[1].ResonatorOut,0,Track^.InternalSampleRate*0.5,2,0);

  NoiseFactor:=sqr(NoiseGain*fci255);
  CascadeFactor:=sqr(CascadeGain*fci255);
  ParallelFactor:=sqr(ParallelGain*fci255);
  AspirationFactor:=sqr(AspirationGain*fci255);
  FricationFactor:=sqr(FricationGain*fci255);

  Remain:=BufferSamples;
  Processed:=0;
  while Remain>0 do begin
   SynthSpeechCheckOnNewFrame(Track,SpeechInstance,Remain{$ifdef textdebug},Processed{$endif});

   SampleCount:=FrameRemain;
   if SampleCount=0 then SampleCount:=1;
   if SampleCount>Remain then SampleCount:=Remain;

   NoiseSeed:=SpeechInstance.Seed;
   for ChannelIndex:=0 to 1 do begin
    NoiseSeed:=SpeechInstance.Seed;
    WorkBuffer:=Buffer;
    inc(WorkBuffer,Processed);
    for SampleCounter:=1 to SampleCount do begin
     Noise:=WhiteNoise(NoiseSeed)+(0.75*LastNoise);
     LastNoise:=Noise;
     Aspiration:=Noise*Frame[fAspiration]*NoiseFactor*AspirationFactor;
     Frication:=Noise*Frame[fFrication]*NoiseFactor*FricationFactor;
     Source:=WorkBuffer^.Channel[ChannelIndex];
     longword(pointer(@Source)^):=longword(pointer(@Source)^) and longword($ffffffff+longword(((((longword(pointer(@Source)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     SourceCascade:=((Source*Frame[fCascadeVoicing])+Aspiration)*CascadeFactor;
     SourceParallel:=((Source*Frame[fParallelVoicing])+Aspiration+Frication)*ParallelFactor;
     with Channel[ChannelIndex] do begin
      Output:=(SourceParallel*Frame[fByPass])-((SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[1],SourceParallel)-
                                               (SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[2],SourceParallel)-
                                               (SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[3],SourceParallel)-
                                               (SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[4],SourceParallel)-
                                               (SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[5],SourceParallel)-
                                               (SynthSpeechResonatorIIR(Track,SpeechInstance,ParallelResonator[0],SourceParallel)-
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[1],
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[2],
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[3],
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[4],
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[5],
                                               SynthSpeechResonatorIIR(Track,SpeechInstance,CascadeResonator[0],SourceCascade)))))))))))));
      longword(pointer(@Output)^):=longword(pointer(@Output)^) and longword($ffffffff+longword(((((longword(pointer(@Output)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      Output:=SynthSpeechResonatorIIR(Track,SpeechInstance,ResonatorOut,Output);
      WorkBuffer^.Channel[ChannelIndex]:=Output;
     end;
     inc(WorkBuffer);
    end;
   end;
   SpeechInstance.Seed:=NoiseSeed;

   inc(Processed,SampleCount);
   dec(Remain,SampleCount);
   dec(FrameRemain,SampleCount);
  end;
 end;
end;

procedure SynthSpeechInit(var SpeechInstance:TSynthSpeechInstanceData);
var Counter:longint;
begin
 with SpeechInstance do begin
  FillChar(Channel[0].CascadeResonator,sizeof(TSynthSpeechResonators),#0);
  FillChar(Channel[1].CascadeResonator,sizeof(TSynthSpeechResonators),#0);
  FillChar(Channel[0].ParallelResonator,sizeof(TSynthSpeechResonators),#0);
  FillChar(Channel[1].ParallelResonator,sizeof(TSynthSpeechResonators),#0);
  TextNumber:=0;
  Frame:=DefaultFrameValues;
  LastNoise:=0;
  LastParGlotOut:=0;
  LastSegment:=@SpeechSegmentsArray[0];
  CurrentSegment:=@SpeechSegmentsArray[0];
  NewSegment:=@SpeechSegmentsArray[0];
  StartStress.Time:=40;
  StartStress.Value:=0;
  EndStress.Time:=40;
  EndStress.Value:=0;
  for Counter:=0 to NumberOfSegmentParameters-1 do begin
   Filter[Counter].V:=LastSegment^.Parameters[Counter].Steady;
   Filter[Counter].A:=FracValue;
   Filter[Counter].B:=1.0-FracValue;
  end;
  Factor:=1;
  FrameLength:=5;
  FrameRemain:=0;
  TimeRemain:=0;
  Speed:=1;
  WaitForEvent:=wfeNONE;
  DoStop:=0;
  FillChar(LastSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(CurrentSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(NewSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  SegmentList.List:=nil;
  SegmentList.Position:=0;
  Color:=0;
  NoiseGain:=32;
  Gain:=192;
  F4:=3250;
  F5:=3700;
  F6:=4990;
  B4:=200;
  B5:=200;
  B6:=500;
  CascadeGain:=10*2;
  ParallelGain:=118*2;
  AspirationGain:=127*2;
  FricationGain:=16*2;
 end;
end;

procedure SynthSpeechReset(var SpeechInstance:TSynthSpeechInstanceData);
begin
 with SpeechInstance do begin
  Seed:=$12345678;
  SegmentList.Position:=0;
  FillChar(LastSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(CurrentSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(NewSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  LastSegment:=@SpeechSegmentsArray[ssiEND];
  CurrentSegment:=@SpeechSegmentsArray[ssiEND];
  NewSegment:=@SpeechSegmentsArray[ssiEND];
  Frame:=DefaultFrameValues;
  FrameRemain:=0;
  TimeRemain:=0;
  DoStop:=0;
  Color:=0;
  NoiseGain:=32;
  Gain:=192;
  F4:=3250;
  F5:=3700;
  F6:=4990;
  B4:=200;
  B5:=200;
  B6:=500;
  CascadeGain:=20;
  ParallelGain:=118;
  AspirationGain:=255;
  FricationGain:=32;
 end;
end;

procedure SynthSpeechResetEx(var SpeechInstance:TSynthSpeechInstanceData);
begin
 with SpeechInstance do begin
  Seed:=$12345678;
  FillChar(LastSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(CurrentSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  FillChar(NewSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
  LastSegment:=@SpeechSegmentsArray[ssiEND];
  CurrentSegment:=@SpeechSegmentsArray[ssiEND];
  NewSegment:=@SpeechSegmentsArray[ssiEND];
  Frame:=DefaultFrameValues;
  FrameRemain:=0;
  TimeRemain:=0;
  DoStop:=0;
  Color:=0;
  NoiseGain:=32;
  Gain:=192;
  F4:=3250;
  F5:=3700;
  F6:=4990;
  B4:=200;
  B5:=200;
  B6:=500;
  CascadeGain:=20;
  ParallelGain:=118;
  AspirationGain:=255;
  FricationGain:=32;
 end;
end;
{$endif}

type TSynthInterpolateProc=function(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;

function SynthNearestInterpolate(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;
begin
 result:=y1;
end;

function SynthLinearInterpolate(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;
begin
 result:=(y1*(1-t))+(y2*t);
end;

function SynthCosineInterpolate(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;
var f:single;
begin
 f:=(1-sin((t+0.5)*pi))*0.5;
 result:=(y1*(1-f))+(y2*f);
end;

function SynthCubicInterpolate(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;
var f,v:single;
begin
 f:=t*t;
 v:=((y3-y2)-y0)+y1;
 result:=(v*t*f)+((y0-y1-v)*f)+((y2-y0)*t)+y1;
end;

function SynthCatmullRomInterpolate(t,x0,x1,x2,x3,y0,y1,y2,y3:single):single;
var n,m0,m1,t2,t3:single;
begin
 n:=x2-x1;
 if n=0 then begin
  result:=y1;
 end else begin
  m0:=n*((y2-y0)/(x2-x0));
  m1:=n*((y3-y1)/(x3-x1));
  t2:=t*t;
  t3:=t2*t;
  result:=((((2.0*t3)-(3.0*t2))+1.0)*y1)+
          (((3.0*t2)-(2.0*t3))*y2)+
          (((t3-(2.0*t2))+t)*m0)+
          ((t3-t2)*m1);
 end;
end;

const SynthInterpolateProcs:array[eimNEAREST..eimCATMULLROM] of TSynthInterpolateProc=(SynthNearestInterpolate,
                                                                                       SynthLinearInterpolate,
                                                                                       SynthCosineInterpolate,
                                                                                       SynthCubicInterpolate,
                                                                                       SynthCatmullRomInterpolate);

function SynthConvertGlideTimeByteToSamples(Track:PSynthTrack;Value:single):longint;
begin
 result:=SoftTRUNC((power(2,Value*fCI255)-1)*(Track^.InternalSampleRate*2{0.125}));
end;

function SynthConvertTimeByteToSamples(Track:PSynthTrack;Value:single):longint;
begin
 result:=SoftTRUNC(power(0.00005,1-(Value*fCI255))*(Track^.InternalSampleRate*20));
end;

function SynthSoftDistortion(InputValue,Gain,Dist:single):single;
begin
 InputValue:=InputValue*Dist;
 result:=InputValue*(((12*InputValue*InputValue)+144)*Gain)/((InputValue*InputValue*(InputValue*InputValue+60))+144);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthHardDistortion(InputValue,Gain,Dist:single):single;
begin
 result:=Clip(InputValue*Gain*Dist,-Gain,Gain);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthFastWaveshapeDistortion(InputValue,Gain:single):single;
begin
 InputValue:=InputValue*Gain;
 result:=(1.5*InputValue)-(0.5*InputValue*InputValue*InputValue);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthWaveshape1Distortion(InputValue,Gain,Dist:single):single;
begin
 InputValue:=InputValue*Gain;
 result:=(InputValue*(abs(InputValue)+Dist))/(sqr(InputValue)+((Dist-1)*abs(InputValue))+1.0);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthWaveshape2Distortion(InputValue,Gain,Dist:single):single;
begin
 InputValue:=InputValue*Gain;
 result:=((1+Dist)*InputValue)/(1.0+(Dist*abs(InputValue)));
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthGloubiBoulgaDistortion(InputValue,Gain:single):single;
var a,b:single;
begin
 InputValue:=(InputValue*Gain)*0.686306;
 a:=1.0+exp(sqrt(abs(InputValue))*(-0.75));
 b:=exp(InputValue);
 result:=((b-exp((-InputValue)*a))*b)/(sqr(b)+1.0);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthFoldBackDistortion(InputValue,Gain,Dist:single):single;
var Sign:longword;
begin
 if (plongword(@InputValue)^ and not $80000000)>=plongword(@Dist)^ then begin
  Sign:=plongword(@InputValue)^ and $80000000;
  plongword(@InputValue)^:=plongword(@InputValue)^ and not $80000000;
  InputValue:=Dist-(InputValue-Dist);
  plongword(@InputValue)^:=plongword(@InputValue)^ xor Sign;
 end;
 result:=InputValue;
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthSoftSaturation(InputValue,Gain,Threshold:single):single;
const F1:single=1;
var Sign:longword;
begin
 InputValue:=InputValue*Gain;
 longword(pointer(@InputValue)^):=longword(pointer(@InputValue)^) and longword($ffffffff+longword(((((longword(pointer(@InputValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 Sign:=plongword(@InputValue)^ and $80000000;
 plongword(@InputValue)^:=plongword(@InputValue)^ and not $80000000;
 if plongword(@InputValue)^>=plongword(@F1)^ then begin
  InputValue:=(Threshold+1)*0.5;
 end else if (plongword(@InputValue)^>=plongword(@Threshold)^) and (plongword(@Threshold)^<>plongword(@F1)^) then begin
  InputValue:=Threshold+((InputValue-Threshold)/(1+sqr((InputValue-Threshold)/(1-Threshold))));
 end;
 plongword(@InputValue)^:=plongword(@InputValue)^ or Sign;
 result:=InputValue;
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

function SynthDecimate(InputValue,Gain,PhaseIncrement:single;var Phase,SavedSample:single;Shift:single):single;
const F1:single=1;
begin
 Phase:=Phase+PhaseIncrement;
 if plongword(@Phase)^>=plongword(@F1)^ then begin
  Phase:=Phase-1;
  SavedSample:=InputValue*Gain;
  longword(pointer(@SavedSample)^):=longword(pointer(@SavedSample)^) and longword($ffffffff+longword(((((longword(pointer(@SavedSample)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end;
 if plongword(@Shift)^<>0 then begin
  result:=SoftTRUNC(SavedSample*Shift)/Shift;
  longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end else begin
  result:=SavedSample;
 end;
end;

function FastEXP(x:single):single; {$ifdef fpc}inline;{$endif}
{$ifdef fpc}
begin
 result:=exp(x);
end;
{$else}
const ln2=0.69314718055994530942;
      a:single=(1 shl 23)/ln2;
      b:single=(1 shl 23)*127;
      c:single=(65801.48*8)+0.5;
var xi:longint absolute x;
begin
 xi:=SoftTRUNC((a*x)+(b-c));
 result:=x;
end;
{$endif}

{$ifdef UseOwnMath}
function tan(const x:double):double;{$ifdef cpu386} assembler; stdcall; {$ifdef caninline}inline;{$endif}
asm
 fld qword ptr x
 fptan
 fstp st(0)
 fwait
end;
{$else}
begin
 result:=sin(x)/cos(x);
end;
{$endif}
{$endif}
                                  
function Syntharctan(const x:single):single;{$ifdef UseOwnMath} assembler; stdcall; {$ifdef caninline}inline;{$endif}
asm
 fld dword ptr x
 fld1
 fpatan
 fwait
end;
{begin
 result:=0.05030176425872175099*(-6.9888366207752135+x)*(3.14559995508649281E-7+x)*((2.84446368839622429+0.826399783297673451*x)+(x*x))/(1+(0.1471039133652469065841349249*x)+(0.644464067689154755092299698*x*x));
end;}
{$else}
begin
 result:=arctan(x);
end;
{$endif}

function Syntharctan2(const x,y:single):single;{$ifdef UseOwnMath} assembler; stdcall; {$ifdef caninline}inline;{$endif}
asm
 fld dword ptr y
 fld dword ptr x
 fpatan
 fwait
end;
{$else}
begin
 result:=arctan2(y,x);
end;
{$endif}

(*
function Syntharcsin(const x:single):single; assembler; stdcall; {$ifdef caninline}inline;{$endif}
asm
 fld dword ptr x
 fld st(0)
 fmul st(0),st(0)
 fld1
 fsubp st(1),st(0)
 fsqrt
 fpatan
 fwait
end;
*)

function Syntharcsin(const x:single):single; {$ifdef caninline}inline;{$endif}
begin
 result:=Syntharctan2(x,sqrt(1-sqr(x)));
end;

(*
function Syntharccos(const x:single):single; assembler; stdcall; {$ifdef caninline}inline;{$endif}
asm
 fld dword ptr x
 fld st(0)
 fmul st(1),st
 fld1
 fsubp st(1),st
 fsqrt
 fxch st(1)
 fpatan
 fwait
end;
*)

function Syntharccos(const x:single):single; {$ifdef caninline}inline;{$endif}
begin
 result:=Syntharctan2(sqrt(1-sqr(x)),x);
end;

function Synthfloor(const x:single):longint; {$ifdef caninline}inline;{$endif}
begin
 result:=SoftTRUNC(x);
 if frac(x)<0 then begin
  dec(result);
 end;
end;

type TSynthGetBufferValueFunc=procedure(var Buffer:PSynthFloatValue;var Dest); {$ifdef cpu386}register;{$endif}

procedure SynthGetBufferValueDoIt(var Buffer:PSynthFloatValue;var Dest); {$ifdef cpu386}register;{$endif}
begin
 plongword(@Dest)^:=plongword(Buffer)^;
 inc(Buffer);
end;

procedure SynthGetBufferValueSkip(var Buffer:PSynthFloatValue;var Dest); {$ifdef cpu386}register;{$endif}
begin
end;

const SynthGetBufferValueFuncs:array[boolean] of TSynthGetBufferValueFunc=(SynthGetBufferValueSkip,SynthGetBufferValueDoIt);

procedure SynthGetBufferValue(var Buffer:PSynthFloatValue;var Dest); {$ifdef cpu386}register;{$endif}
begin
 SynthGetBufferValueFuncs[assigned(Buffer)](Buffer,Dest);
end;

{$ifdef BR808LFO}
function SynthLFOSampleGetValue(Track:PSynthTrack;Sample:PSynthSample;Phase:single):single;
var SmpPos:int64;
    RealPos:longword;
    x,x2,x3,a,b,c,d:single;
begin
 if (Sample^.Header.Samples<>0) and assigned(Sample^.Data) and assigned(Sample^.WorkData) then begin
  SmpPos:=round64((frac(Phase)*Sample^.Header.PhaseSamples)*i32);
  if SmpPos<0 then begin
   SmpPos:=0;
  end else if SmpPos>(Sample^.Header.Samples-1)*i32 then begin
   SmpPos:=int64(Sample^.Header.Samples-1) shl 32;
  end;
  x:=(SmpPos and PositionMask)*PositionDivFactor;
  x2:=x*x;
  x3:=x2*x;
  a:=((-(0.5*x3))+(1.0*x2))-(0.5*x);
  b:=((1.5*x3)-(2.5*x2))+1.0;
  c:=((-(1.5*x3))+(2.0*x2))+(0.5*x);
  d:=(0.5*x3)-(0.5*x2);
  if Sample^.Header.Channels=2 then begin
   RealPos:=((SmpPos shr PositionShift) shl 1)+SampleFixUp;
   result:=(((a*psingles(Sample^.WorkData)^[RealPos-2])+
             (b*psingles(Sample^.WorkData)^[RealPos+0])+
             (c*psingles(Sample^.WorkData)^[RealPos+2])+
             (d*psingles(Sample^.WorkData)^[RealPos+4]))+
            ((a*psingles(Sample^.WorkData)^[RealPos-1])+
             (b*psingles(Sample^.WorkData)^[RealPos+1])+
             (c*psingles(Sample^.WorkData)^[RealPos+3])+
             (d*psingles(Sample^.WorkData)^[RealPos+5])))*0.5;
  end else begin
   RealPos:=(SmpPos shr PositionShift)+SampleFixUp;
   result:=(a*psingles(Sample^.WorkData)^[RealPos-1])+
           (b*psingles(Sample^.WorkData)^[RealPos+0])+
           (c*psingles(Sample^.WorkData)^[RealPos+1])+
           (d*psingles(Sample^.WorkData)^[RealPos+2]);
  end;
  longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end else begin
  result:=0;
 end;
end;
{$endif}

procedure SynthProcessOscillatorInit(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData);
begin
 OscillatorData^.Seed:=RandomInteger;
 OscillatorData^.PinkNoiseStates[0]:=0;
 OscillatorData^.PinkNoiseStates[1]:=0;
 OscillatorData^.PinkNoiseStates[2]:=0;
 OscillatorData^.PinkNoiseStates[2]:=0;
 OscillatorData^.PinkNoiseStates[4]:=0;
 OscillatorData^.NoiseMode:=0;
 OscillatorData^.NoiseLast:=0;
end;

procedure SynthProcessOscillatorKeyOn(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Carry,LegatoPedal:boolean);
var i:longint;
    f:single;
begin
 if not ((Oscillator^.Carry or LegatoPedal) and Carry) then begin
  if Oscillator^.RandomPhase then begin
   OscillatorData^.Phase:=(WhiteNoise(Track^.Seed)+1)*0.5;
   for i:=0 to Oscillator^.SuperOscCount-1 do begin
    OscillatorData^.SuperOscPhases[i]:=(WhiteNoise(Track^.Seed)+1)*0.5;
   end;
  end else begin
   if Oscillator^.SuperOscCount>0 then begin
    f:=1/Oscillator^.SuperOscCount;
   end else begin
    f:=1;
   end;
   OscillatorData^.Phase:=Oscillator^.PhaseStart*fCI256;
   for i:=0 to Oscillator^.SuperOscCount-1 do begin
    OscillatorData^.SuperOscPhases[i]:=OscillatorData^.Phase*(i*f);
   end;
  end;
  for i:=0 to Oscillator^.SuperOscCount-1 do begin
   OscillatorData^.SuperOscSVF[i,0]:=0;
   OscillatorData^.SuperOscSVF[i,1]:=0;
   OscillatorData^.SuperOscSVF[i,2]:=0;
  end;
  OscillatorData^.RampingPhase.Active:=false;
 end;
end;

procedure SynthProcessOscillatorKeyOff(Track:PSynthTrack;OscillatorData:PSynthInstrumentOscillatorData);
begin
end;

procedure SynthProcessADSRInit(Track:PSynthTrack;ADSR:PSynthInstrumentADSR;ADSRData:PSynthInstrumentADSRData;AttackFactor,DecayFactor,SustainFactor,ReleaseFactor,DecayLevelFactor{,AmplifyFactor}:PSynthFloatValue);
{$ifdef BR808ADSR}
const i255:longint=255;
var Counter:longint;
    Factor:single;
    FactorPointer:PSynthFloatValue;
{$endif}
begin
{$ifdef BR808ADSR}
 ADSRData^.Levels[esATTACK]:=1;
 if assigned(DecayLevelFactor) then begin
  Factor:=DecayLevelFactor^*sqr(ADSR^.TargetDecayLevel*fci255);
 end else begin
  Factor:=sqr(ADSR^.TargetDecayLevel*fci255);
 end;
 ADSRData^.Levels[esDECAY]:=Factor;
 ADSRData^.Levels[esSUSTAIN]:=Factor;
 ADSRData^.Levels[esRELEASE]:=0;
 for Counter:=esATTACK to esRELEASE do begin
  if true then begin //ADSRData^.Times[Counter]<>ADSR^.Times[Counter] THEN BEGIN
   ADSRData^.Times[Counter]:=ADSR^.Times[Counter];
   Factor:=ADSR^.Times[Counter];
   case Counter of
    esATTACK:FactorPointer:=AttackFactor;
    esDECAY:FactorPointer:=DecayFactor;
    esSUSTAIN:FactorPointer:=SustainFactor;
    esRELEASE:FactorPointer:=ReleaseFactor;
    else FactorPointer:=nil;
   end;
   if assigned(FactorPointer) then begin
    Factor:=FactorPointer^*i255;
   end;
   ADSRData^.Samples[Counter]:=SynthConvertTimeByteToSamples(Track,Factor);
  end;
 end;
{IF ASSIGNED(AmplifyFactor) THEN BEGIN
  Factor:=AmplifyFactor^;
 END ELSE BEGIN
  Factor:=sqr(ADSR^.Amplify*fCi255);
 END;}
 Factor:=sqr(ADSR^.Amplify*fci255);
 ADSRData^.Amplify:=Factor;
{$endif}
end;

procedure SynthProcessADSRKeyOn(Track:PSynthTrack;ADSR:PSynthInstrumentADSR;ADSRData:PSynthInstrumentADSRData;Carry,LegatoPedal:boolean);
begin
{$ifdef BR808ADSR}
 if not (Carry and (ADSR^.Carry or LegatoPedal) and not (ADSRData^.State in [esRELEASE,esNONE])) then begin
  ADSRData^.SampleRemain:=0;
  ADSRData^.State:=esATTACK;
  ADSRData^.OldState:=esNONE;
  ADSRData^.Value:=0;
 end;
{$endif}
end;

procedure SynthProcessADSRKeyOff(Track:PSynthTrack;ADSRData:PSynthInstrumentADSRData);
begin
{$ifdef BR808ADSR}
 if not (ADSRData^.State in [esRELEASE,esNONE]) then begin
  ADSRData^.SampleRemain:=0;
  ADSRData^.State:=esRELEASE;
 end;
{$endif}
end;

procedure SynthProcessADSR(Track:PSynthTrack;ADSR:PSynthInstrumentADSR;ADSRData:PSynthInstrumentADSRData;Buffer,AttackBuffer,DecayBuffer,SustainBuffer,ReleaseBuffer,DecayLevelBuffer,AmplifyBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808ADSR}
const Factor=1000;
      Factor32:word=Factor;
      FactorEx:single=1/Factor;
{$ifdef cpu386}
      StartValue:single=0.01;
      F0D5:single=0.5;
      F2:single=2;
{$endif}
var SampleCounter,SamplesCount,Count:longint;
    HoldSustain:boolean;
    AValue,NextLevel:single;
    BufferEx:PSynthFloatValue;
{$endif}
begin
{$ifdef BR808ADSR}
 // Reset sample counter
 SampleCounter:=0;

 // Save buffer pointer
 BufferEx:=Buffer;

 // Infinite loop until BREAK
 while true do begin

  // Are we at ADSR envelope end?
  if (ADSRData^.State>esRELEASE) or (ADSRData^.State=esNONE) then begin
   ADSRData^.State:=emNONE;
   ADSRData^.Value:=0;
   break;
  end;

  // Are we at buffer end?
  if SampleCounter>=Samples then begin
   break;
  end;

  if assigned(AttackBuffer) or assigned(DecayBuffer) or
     assigned(SustainBuffer) or assigned(ReleaseBuffer) or
     assigned(DecayLevelBuffer) or assigned(AmplifyBuffer) then begin
   SynthProcessADSRInit(Track,ADSR,ADSRData,AttackBuffer,DecayBuffer,SustainBuffer,ReleaseBuffer,DecayLevelBuffer{,AmplifyBuffer});
  end;

  // Check for ON sustain und save it for later re-use
  HoldSustain:=(ADSRData^.State=esSUSTAIN) and (ADSR^.Modes[ADSRData^.State]=emsON);

  // Check for a new ADSR part
  if ADSRData^.State<>ADSRData^.OldState then begin
   ADSRData^.OldState:=ADSRData^.State;

   if ADSRData^.State=esRELEASE then begin
    ADSRData^.OldState:=ADSRData^.State;
   end;

   // Check for active ADSR part
   if (ADSR^.Modes[ADSRData^.State]=emNONE) or ((ADSRData^.Samples[ADSRData^.State]=0) and not HoldSustain) then begin
    if ADSRData^.State=esATTACK then begin
     ADSRData^.Value:=1;
    end;
    inc(ADSRData^.State);
    continue;
   end;

   // Check for no ON sustain
   if not HoldSustain then begin

    // Check for sustain
    if ADSRData^.State=esSUSTAIN then begin

     // No change
     ADSRData^.CoefA:=1;
     ADSRData^.CoefB:=0;
     ADSRData^.CoefC:=ADSRData^.Value;
     ADSRData^.CoefX:=0;
     ADSRData^.Levels[ADSRData^.State]:=ADSRData^.Value;

    end else begin

     // Check start value
     if ADSRData^.State=esATTACK then begin
      if ADSR^.Modes[ADSRData^.State]=emLINEAR then begin
       ADSRData^.Value:=0;
      end else begin
       ADSRData^.Value:=0.01;
      end;
     end;

     // Calculate ADSR Coefs
     SamplesCount:=ADSRData^.Samples[ADSRData^.State];
     if SamplesCount=0 then SamplesCount:=1;
     NextLevel:=ADSRData^.Levels[ADSRData^.State];
     case ADSR^.Modes[ADSRData^.State] of
      emLINEAR:begin
       ADSRData^.CoefA:=1;
       ADSRData^.CoefB:=(NextLevel-ADSRData^.Value)/SamplesCount;
       ADSRData^.CoefC:=ADSRData^.Value;
       ADSRData^.CoefX:=0;
      end;
      emEXP:begin
       ADSRData^.CoefA:=power(Factor,1/SamplesCount);
       ADSRData^.CoefB:=0;
       ADSRData^.CoefC:=ADSRData^.Value;
       ADSRData^.CoefX:=FactorEx*(NextLevel-ADSRData^.Value);
      end;
      emLOG:begin
       ADSRData^.CoefA:=power(FactorEx,1/SamplesCount);
       ADSRData^.CoefB:=0;
       ADSRData^.CoefC:=NextLevel;
       ADSRData^.CoefX:=ADSRData^.Value-NextLevel;
      end;
     end;

    end;

    // Reset sample remain counter
    ADSRData^.SampleRemain:=ADSRData^.Samples[ADSRData^.State];

   end;
  end;

  // Check for ON sustain
  if HoldSustain then begin
   break;
  end;

  // Main Inner Loop
{$ifdef UseSSE}if SSEExt and Track^.UseSSE then begin
   asm
    push eax
    push ebx
    push ecx
    push edx
    push esi
    push edi

     mov eax,dword ptr ADSRData
     mov ecx,dword ptr SampleCounter
     mov edx,dword ptr Buffer
     mov esi,dword ptr ADSR

     movss xmm0,dword ptr [eax+TSynthInstrumentADSRData.CoefX]
     movss xmm1,dword ptr [eax+TSynthInstrumentADSRData.CoefA]
     movss xmm2,dword ptr [eax+TSynthInstrumentADSRData.CoefB]
     movss xmm3,dword ptr [eax+TSynthInstrumentADSRData.CoefC]
     movss xmm4,dword ptr [eax+TSynthInstrumentADSRData.Value]
     movss xmm6,dword ptr [eax+TSynthInstrumentADSRData.Amplify]

     mov ebx,dword ptr [eax+TSynthInstrumentADSRData.SampleRemain]
     movzx edi,byte ptr [esi+TSynthInstrumentADSR.Centerise]

     @Loop:
      cmp ecx,dword ptr Samples
      jge @Done

      mulss xmm0,xmm1 // CoefX:=CoefX*CoefA
      addss xmm0,xmm2 // CoefX:=CoefX+CoefB

      movss xmm4,xmm0 // Value:=CoefX
      addss xmm4,xmm3 // Value:=Value+CoefC

      movss xmm5,xmm4 // Temp:=Value

      test edi,edi
      jz @NoCenterise
       subss xmm5,dword ptr F0D5
       mulss xmm5,dword ptr F2
      @NoCenterise:

      mulss xmm5,xmm6 // Temp:=Temp*Amplify

      movss dword ptr [edx],xmm5

      inc dword ptr Count

      add edx,4
      inc ecx

      dec ebx
      jz @Next
      js @Next
     jmp @Loop
     @Next:
      movzx ebx,byte ptr [eax+TSynthInstrumentADSRData.State]
      movss xmm4,dword ptr [eax+TSynthInstrumentADSRData.Levels-4+ebx*4]
      inc byte ptr [eax+TSynthInstrumentADSRData.State]
     @Done:

     mov dword ptr [eax+TSynthInstrumentADSRData.SampleRemain],ebx

     movss dword ptr [eax+TSynthInstrumentADSRData.CoefX],xmm0
     movss dword ptr [eax+TSynthInstrumentADSRData.Value],xmm4

     mov dword ptr SampleCounter,ecx
     mov dword ptr Buffer,edx

    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
   end;
  end else{$endif} begin
   Count:=0;
   while SampleCounter<Samples do begin
    ADSRData^.CoefX:=(ADSRData^.CoefX*ADSRData^.CoefA)+ADSRData^.CoefB;
    longword(pointer(@ADSRData^.CoefX)^):=longword(pointer(@ADSRData^.CoefX)^) and longword($ffffffff+longword(((((longword(pointer(@ADSRData^.CoefX)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    ADSRData^.Value:=ADSRData^.CoefX+ADSRData^.CoefC;
    AValue:=ADSRData^.Value;
    if ADSR^.Centerise then begin
     AValue:=(AValue-0.5)*2;
    end;
    Buffer^:=AValue*ADSRData^.Amplify;
    longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(Buffer);
    inc(SampleCounter);
    inc(Count);
    dec(ADSRData^.SampleRemain);
    if ADSRData^.SampleRemain<=0 then begin
     ADSRData^.Value:=ADSRData^.Levels[ADSRData^.State];
     inc(ADSRData^.State);
     break;
    end;
   end;
  end;

  if assigned(AttackBuffer) then inc(AttackBuffer,Count);
  if assigned(DecayBuffer) then inc(DecayBuffer,Count);
  if assigned(SustainBuffer) then inc(SustainBuffer,Count);
  if assigned(ReleaseBuffer) then inc(ReleaseBuffer,Count);
  if assigned(DecayLevelBuffer) then inc(DecayLevelBuffer,Count);
//IF ASSIGNED(AmplifyBuffer) THEN INC(AmplifyBuffer,Count);
 end;

 // Fill until buffer end into the buffer the current value
 if SampleCounter<Samples then begin
  AValue:=ADSRData^.Value;
  if ADSR^.Centerise then begin
   AValue:=(AValue-0.5)*2;
  end;
  AValue:=AValue*ADSRData^.Amplify;
  longword(pointer(@AValue)^):=longword(pointer(@AValue)^) and longword($ffffffff+longword(((((longword(pointer(@AValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(Buffer,AValue,Samples-SampleCounter);
  end else{$endif} begin
   SynthFillFloat(Buffer,AValue,Samples-SampleCounter);
  end;
 end;
 if assigned(AmplifyBuffer) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFloatBufferMulFloatBufferSSE(BufferEx,AmplifyBuffer,Samples);
  end else{$endif} begin
   SynthFloatBufferMulFloatBuffer(BufferEx,AmplifyBuffer,Samples);
  end;
 end;
{$endif}
end;

{$ifdef UseSSE}
procedure SynthAmplifyFloatBufferWithVolumeSSE(Target:PSynthFloatValue;Samples,Volume:longint); assembler; register;
const fCI255:single=1/255;
asm
 cmp ecx,255
 jz @Done

  push ecx
  cvtsi2ss xmm4,dword ptr [esp]
  pop ecx

  mulss xmm4,dword ptr fCI255
  mulss xmm4,xmm4

  mov ecx,edx

  shufps xmm4,xmm4,0

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       mulps xmm0,xmm4

       movaps xmm1,[eax+16]
       mulps xmm1,xmm4

       movaps xmm2,[eax+32]
       mulps xmm2,xmm4

       movaps xmm3,[eax+48]
       mulps xmm3,xmm4

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       mulps xmm0,xmm4
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthAmplifyFloatBufferWithVolume(Target:PSynthFloatValue;Samples,Volume:longint);
var Counter:longint;
    VolumeFactor:single;
begin
 if Volume<>255 then begin
  VolumeFactor:=sqr(Volume*fCI255);
  for Counter:=1 to Samples do begin
   Target^:=Target^*VolumeFactor;
   longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Target);
  end;
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessOscillatorVolumeSSE(Target:PSynthBufferSample;Samples,Volume:longint); assembler; register;
const fCI255:single=1/255;
asm
 cmp ecx,255
 jz @Done

  push ecx
  cvtsi2ss xmm4,dword ptr [esp]
  pop ecx

  mulss xmm4,dword ptr fCI255
  mulss xmm4,xmm4

  lea ecx,[edx*2]

  shufps xmm4,xmm4,0

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       mulps xmm0,xmm4

       movaps xmm1,[eax+16]
       mulps xmm1,xmm4

       movaps xmm2,[eax+32]
       mulps xmm2,xmm4

       movaps xmm3,[eax+48]
       mulps xmm3,xmm4

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       mulps xmm0,xmm4
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessOscillatorVolume(Target:PSynthBufferSample;Samples,Volume:longint);
var Counter:longint;
    VolumeFactor:single;
begin
 if Volume<>255 then begin
  VolumeFactor:=sqr(Volume*fCI255);
  for Counter:=1 to Samples do begin
   Target^.Left:=Target^.Left*VolumeFactor;
   longword(pointer(@Target^.Left)^):=longword(pointer(@Target^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Target^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   Target^.Right:=Target^.Right*VolumeFactor;
   longword(pointer(@Target^.Right)^):=longword(pointer(@Target^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Target^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Target);
  end;
 end;
end;

procedure SynthProcessEnvelopeInit(Track:PSynthTrack;Envelope:PSynthInstrumentEnvelope;EnvelopeData:PSynthInstrumentEnvelopeData);
begin
{$ifdef BR808ENVELOPES}
{$endif}
end;

procedure SynthProcessEnvelopeKeyOn(Track:PSynthTrack;Envelope:PSynthInstrumentEnvelope;EnvelopeData:PSynthInstrumentEnvelopeData;Carry,LegatoPedal:boolean);
begin
{$ifdef BR808ENVELOPES}
 if not ((Envelope^.Carry or LegatoPedal) and Carry) then begin
  EnvelopeData^.KeyOff:=false;
  EnvelopeData^.EndOfEnvelope:=false;
  EnvelopeData^.SampleRemain:=-1;
  EnvelopeData^.SampleCounter:=-1;
  EnvelopeData^.CurrentNode:=0;
  EnvelopeData^.LastValue:=0;
 end;
{$endif}
end;

procedure SynthProcessEnvelopeKeyOff(Track:PSynthTrack;EnvelopeData:PSynthInstrumentEnvelopeData);
begin
{$ifdef BR808ENVELOPES}
 EnvelopeData^.KeyOff:=true;
{$endif}
end;

procedure SynthProcessEnvelope(Track:PSynthTrack;Envelope:PSynthInstrumentEnvelope;EnvelopeData:PSynthInstrumentEnvelopeData;OurEnvelope:PSynthEnvelope;Buffer,AmplifyBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808ENVELOPES}
var SamplesRemain:longint;
    BufferEx:PSynthFloatValue;
{$endif}
begin
{$ifdef BR808ENVELOPES}
 // Reset sample counter
 SamplesRemain:=Samples;

 // Save our buffer pointer
 BufferEx:=Buffer;

 // And now: Do the main work ;-)
 if not EnvelopeData^.EndOfEnvelope then begin
  while SamplesRemain>0 do begin
   while (SamplesRemain>0) and (EnvelopeData^.SampleRemain>0) do begin
    EnvelopeData^.LastValue:=SynthInterpolateProcs[EnvelopeData^.InterpolationMode](EnvelopeData^.SampleCounter*EnvelopeData^.X2MX1DF,EnvelopeData^.X0,EnvelopeData^.X1,EnvelopeData^.X2,EnvelopeData^.X3,EnvelopeData^.Y0,EnvelopeData^.Y1,EnvelopeData^.Y2,EnvelopeData^.Y3);
    if Envelope^.Centerise then begin
     EnvelopeData^.LastValue:=(EnvelopeData^.LastValue-0.5)*2;
    end;
    SynthKillDenormal(EnvelopeData^.LastValue);
    Buffer^:=EnvelopeData^.LastValue;
    inc(Buffer);
    dec(SamplesRemain);
    dec(EnvelopeData^.SampleRemain);
    inc(EnvelopeData^.SampleCounter);
   end;
   if EnvelopeData^.SampleRemain<=0 then begin
    if (OurEnvelope^.SustainLoopStart>=0) and (OurEnvelope^.SustainLoopEnd>=0) and
       (EnvelopeData^.CurrentNode>=OurEnvelope^.SustainLoopEnd) and not EnvelopeData^.KeyOff then begin
     EnvelopeData^.CurrentNode:=OurEnvelope^.SustainLoopStart;
    end;
    if (OurEnvelope^.LoopStart>=0) and (OurEnvelope^.LoopEnd>=0) and
                (EnvelopeData^.CurrentNode>=OurEnvelope^.LoopEnd) then begin
     EnvelopeData^.CurrentNode:=OurEnvelope^.LoopStart;
    end;
    inc(EnvelopeData^.CurrentNode);
    if EnvelopeData^.CurrentNode>=OurEnvelope^.NodesCount then begin
     EnvelopeData^.EndOfEnvelope:=true;
     break;
    end else begin
     EnvelopeData^.X2:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode].Time;
     EnvelopeData^.Y2:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode].Value*fCI255;
     EnvelopeData^.InterpolationMode:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode].Interpolation;
     if EnvelopeData^.CurrentNode>0 then begin
      EnvelopeData^.X1:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode-1].Time;
      EnvelopeData^.Y1:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode-1].Value*fCI255;
     end else begin
      EnvelopeData^.X1:=EnvelopeData^.X2;
      EnvelopeData^.Y1:=EnvelopeData^.Y2;
     end;
     if EnvelopeData^.CurrentNode>1 then begin
      EnvelopeData^.X0:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode-2].Time;
      EnvelopeData^.Y0:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode-2].Value*fCI255;
     end else begin
      EnvelopeData^.X0:=EnvelopeData^.X1-1;
      EnvelopeData^.Y0:=OurEnvelope^.NegValue*fCI255;
     end;
     if (EnvelopeData^.CurrentNode+1)<OurEnvelope^.NodesCount then begin
      EnvelopeData^.X3:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode+1].Time;
      EnvelopeData^.Y3:=OurEnvelope^.Nodes^[EnvelopeData^.CurrentNode+1].Value*fCI255;
     end else begin
      EnvelopeData^.X3:=EnvelopeData^.X2+1;
      EnvelopeData^.Y3:=OurEnvelope^.PosValue*fCI255;
     end;
    end;
    EnvelopeData^.X0:=(EnvelopeData^.X0*Track^.InternalSampleRate) div 1000;
    EnvelopeData^.X1:=(EnvelopeData^.X1*Track^.InternalSampleRate) div 1000;
    EnvelopeData^.X2:=(EnvelopeData^.X2*Track^.InternalSampleRate) div 1000;
    EnvelopeData^.X3:=(EnvelopeData^.X3*Track^.InternalSampleRate) div 1000;
    EnvelopeData^.SampleRemain:=EnvelopeData^.X2-EnvelopeData^.X1;
    EnvelopeData^.SampleCounter:=0;
    if EnvelopeData^.SampleRemain=0 then begin
     EnvelopeData^.EndOfEnvelope:=true;
     break;
    end else begin
     EnvelopeData^.X2MX1DF:=1/EnvelopeData^.SampleRemain;
    end;
   end;
  end;
 end;

 // Fill the rest of buffer with the last value
 if SamplesRemain>0 then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(Buffer,EnvelopeData^.LastValue,SamplesRemain);
  end else{$endif} begin
   SynthFillFloat(Buffer,EnvelopeData^.LastValue,SamplesRemain);
  end;
 end;

 // And finally, amplify it :-)
 if assigned(AmplifyBuffer) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFloatBufferMulFloatBufferSSE(BufferEx,AmplifyBuffer,Samples);
  end else{$endif} begin
   SynthFloatBufferMulFloatBuffer(BufferEx,AmplifyBuffer,Samples);
  end;
 end;
{$ifdef UseSSE}
 if SSEExt and Track^.UseSSE then begin
  SynthAmplifyFloatBufferWithVolumeSSE(BufferEx,Samples,Envelope^.Amplify);
 end else{$endif} begin
  SynthAmplifyFloatBufferWithVolume(BufferEx,Samples,Envelope^.Amplify);
 end;
{$endif}
end;

procedure SynthProcessLFOInit(Track:PSynthTrack;LFO:PSynthInstrumentLFO;LFOData:PSynthInstrumentLFOData);
{$ifdef BR808LFO}
const Div1024:single=1/10;
      Div100:single=1/100;
{$endif}
begin
{$ifdef BR808LFO}
 LFOData^.PhaseIncrement:=(power(0.0001,(255-LFO^.Rate)*fCI255)*100)*Track^.InternalSampleRateFactor;
 if LFO^.Sweep=0 then begin
  LFOData^.SweepIncrement:=0;
 end else begin
  LFOData^.SweepIncrement:=1/SynthConvertTimeByteToSamples(Track,LFO^.Sweep);
 end;
 LFOData^.Seed:=RandomInteger;
 LFOData^.Last:=WhiteNoise(LFOData^.Seed);
{$endif}
end;

procedure SynthProcessLFOKeyOn(Track:PSynthTrack;Channel:PSynthChannel;Voice:PSynthVoice;LFO:PSynthInstrumentLFO;LFOData:PSynthInstrumentLFOData;Carry,LegatoPedal:boolean);
begin
{$ifdef BR808LFO}
 if not ((LFO^.Carry or LegatoPedal) and Carry) then begin
  case LFO^.PhaseSync of
   lpsGLOBAL:begin
    LFOData^.Phase:=frac(Track^.GlobalLFOPhase+(LFO^.PhaseStart*fCI256));
   end;
   lpsCHANNEL:begin
    LFOData^.Phase:=frac(Channel^.ChannelLFOData.Phase+(LFO^.PhaseStart*fCI256));
   end;
   lpsVOICE:begin
    LFOData^.Phase:=LFO^.PhaseStart*fCI256;
   end;
   lpsRANDOM:begin
    LFOData^.Phase:=RandomFloat(LFOData^.Seed);
   end;
   else begin
    LFOData^.Phase:=LFO^.PhaseStart*fCI256;
   end;
  end;
  LFOData^.Sweep:=ord(LFO^.Sweep=0);
 end;
{$endif}
end;

procedure SynthProcessLFOKeyOff(Track:PSynthTrack;LFOData:PSynthInstrumentLFOData);
begin
{$ifdef BR808LFO}
{$endif}
end;

function SynthProcessLFO(Track:PSynthTrack;Voice:PSynthVoice;LFO:PSynthInstrumentLFO;LFOData:PSynthInstrumentLFOData;Buffer,PhaseIncrementBuffer,PhaseBuffer,DepthBuffer,MiddleBuffer:PSynthFloatValue;Samples:longint):boolean;{$ifdef cpu386}register;{$endif}
{$ifdef BR808LFO}
const F1:single=1;
var Counter:longint;
    Value,Depth,Middle,Phase:single;
{$endif}
begin
{$ifdef BR808LFO}
 if LFO^.WaveForm=lwfNONE then begin
  result:=false;
 end else begin
  result:=true;
  LFOData^.PhaseIncrement:=(power(0.0001,(255-LFO^.Rate)*fCI255)*100)*Track^.InternalSampleRateFactor;
  Depth:=LFO^.Depth*fCI255;
  Middle:=LFO^.Middle*fCI128*2;
  if assigned(PhaseBuffer) then begin
   LFOData^.Phase:=PhaseBuffer^;
  end;
  for Counter:=1 to Samples do begin
   case LFO^.WaveForm of
    lwfSINE:begin
     Value:=sin(LFOData^.Phase*(2*pi));
    end;
    lwfSAWUP,lwfSAWDOWN:begin
     Value:=((LFOData^.Phase-0.5)*2)*longint(1-((LFO^.WaveForm-lwfSAWUP) shl 1));
    end;
    lwfTRI:Value:=(abs(LFOData^.Phase-0.5)*4)-1;
    lwfSQUARE:begin
     Phase:=LFOData^.Phase-0.5;
     Value:=1-longint(longword(plongword(@Phase)^ shr 31) shl 1);
    end;
    lwfRANDOM:begin
     if LFO^.Rate=255 then begin
      LFOData^.Last:=WhiteNoise(LFOData^.Seed);
     end;
     Value:=LFOData^.Last;
    end;
    lwfSAMPLE:begin
     Value:=SynthLFOSampleGetValue(Track,@Track^.Samples[Voice^.Patch,LFO^.Sample],LFOData^.Phase);
    end;
    else begin
     Value:=0;
    end;
   end;
   if plongword(@LFOData^.Sweep)^<plongword(@F1)^ then begin
    LFOData^.Sweep:=LFOData^.Sweep+LFOData^.SweepIncrement;
   end else begin
    plongword(@LFOData^.Sweep)^:=plongword(@F1)^;
   end;
   Value:=Value+Middle+MiddleBuffer^;
   inc(MiddleBuffer);
   if LFO^.Amp then begin
    Value:=(Value*0.5)+0.5;
   end;
   Buffer^:=Value*LFOData^.Sweep*Depth*DepthBuffer^;
   longword(pointer(Buffer)^):=longword(pointer(Buffer)^) and longword($ffffffff+longword(((((longword(pointer(Buffer)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(DepthBuffer);
   if (LFO^.WaveForm=lwfRANDOM) and (LFO^.Rate<>255) then begin
    LFOData^.Phase:=LFOData^.Phase+(LFOData^.PhaseIncrement*PhaseIncrementBuffer^);
    while LFOData^.Phase>=1 do begin
     LFOData^.Last:=WhiteNoise(LFOData^.Seed);
     LFOData^.Phase:=LFOData^.Phase-1;
    end;
    LFOData^.Phase:=frac(LFOData^.Phase);
   end else begin
    LFOData^.Phase:=frac(LFOData^.Phase+(LFOData^.PhaseIncrement*PhaseIncrementBuffer^));
   end;
   inc(PhaseIncrementBuffer);
   inc(Buffer);
  end;
 end;
{$endif}
end;

procedure SynthProcessFilterInit(Track:PSynthTrack;Filter:PSynthInstrumentFilter;FilterData:PSynthInstrumentFilterData);
begin
{$ifdef BR808VOICEFILTER}
{$endif}
end;

procedure SynthProcessFilterKeyOn(Track:PSynthTrack;Filter:PSynthInstrumentFilter;FilterData:PSynthInstrumentFilterData;Carry,LegatoPedal:boolean);
begin
{$ifdef BR808FILTER}
 if not (Carry and (Filter^.Carry or LegatoPedal)) then begin
  FillChar(FilterData^,sizeof(TSynthInstrumentFilterData),#0);
 end;
{$endif}
end;

procedure SynthProcessFilterKeyOff(Track:PSynthTrack;FilterData:PSynthInstrumentFilterData);
begin
{$ifdef BR808FILTER}
{$endif}
end;

function SynthInitBIQUADFilterCalculateCutOff(Value,MinHz,MaxHz:single):single;
begin
 result:=Clip((Value*(MaxHz-MinHz))+MinHz,MinHz,MaxHz);
end;

function SynthInitBIQUADFilterCalculateResonance(Value:single):single;
begin
 result:=(sqr(sqr(Value))*150)+0.1;
end;

function SynthInitBIQUADFilterCalculateBandWidth(Value:single):single;
begin
 result:=(sqr(sqr(Value))*4)+0.1;
end;

procedure SynthInitBIQUADFilter(Track:PSynthTrack;Mode:longint;var BIQUADMemory:TSynthInstrumentFilterDataBIQUADMemory;const CutOff:single;Resonance:single;const Amplify,MinHz,MaxHz:single);{$ifdef cpu386}register;{$endif}
var Omega,Cosinus,Sinus,Alpha,Beta,BandWidth,A0F:double;
begin
 BIQUADMemory.VF:=CutOff;
 BIQUADMemory.VQ:=Resonance;
 BIQUADMemory.VA:=Amplify;
 Resonance:=Resonance+0.000001;
 Omega:=(2*PI*SynthInitBIQUADFilterCalculateCutOff(CutOff,MinHz,MaxHz))*Track^.InternalSampleRateFactor;
 Cosinus:=COS(Omega);
 Sinus:=SIN(Omega);
 if Mode in [fmBIQUADLOWPASS,fmBIQUADHIGHPASS,fmBIQUADBANDPASS,fmBIQUADNOTCH] then begin
  Alpha:=Sinus/SynthInitBIQUADFilterCalculateResonance(Resonance{*(CutOff+0.7)});
  Beta:=FastSQRT(Amplify+Amplify);
 end else begin
  BandWidth:=SynthInitBIQUADFilterCalculateBandWidth(Resonance);
  Alpha:=Sinus*sinh(((0.69314718055994530942*0.5)*BandWidth*Omega)/Sinus);
  if BandWidth<>0 then begin
   Beta:=(FastSQRT(Amplify+Amplify)/BandWidth)-sqr(Amplify);
  end else begin
   Beta:=FastSQRT(Amplify+Amplify);
  end;
 end;
 case Mode of
  fmBIQUADLOWPASS:begin
   BIQUADMemory.Gain:=Amplify;
   BIQUADMemory.B0:=(1-Cosinus)*0.5;
   BIQUADMemory.B1:=1-Cosinus;
   BIQUADMemory.B2:=(1-Cosinus)*0.5;
   BIQUADMemory.A0:=1+Alpha;
   BIQUADMemory.A1:=-(2*Cosinus);
   BIQUADMemory.A2:=1-Alpha;
  end;
  fmBIQUADHIGHPASS:begin
   BIQUADMemory.Gain:=Amplify;
   BIQUADMemory.B0:=(1+Cosinus)*0.5;
   BIQUADMemory.B1:=-(1+Cosinus);
   BIQUADMemory.B2:=(1+Cosinus)*0.5;
   BIQUADMemory.A0:=1+Alpha;
   BIQUADMemory.A1:=-(2*Cosinus);
   BIQUADMemory.A2:=1-Alpha;
  end;
  fmBIQUADBANDPASS:begin
   BIQUADMemory.Gain:=Amplify;
   BIQUADMemory.B0:=Alpha;
   BIQUADMemory.B1:=0;
   BIQUADMemory.B2:=-Alpha;
   BIQUADMemory.A0:=1+Alpha;
   BIQUADMemory.A1:=-(2*Cosinus);
   BIQUADMemory.A2:=1-Alpha;
  end;
  fmBIQUADNOTCH:begin
   BIQUADMemory.Gain:=Amplify;
   BIQUADMemory.B0:=1;
   BIQUADMemory.B1:=-(2*Cosinus);
   BIQUADMemory.B2:=1;
   BIQUADMemory.A0:=1+Alpha;
   BIQUADMemory.A1:=-(2*Cosinus);
   BIQUADMemory.A2:=1-Alpha;
  end;
  fmBIQUADPEAKINGBANDEQ:begin
   BIQUADMemory.Gain:=1;
   BIQUADMemory.B0:=1+(Alpha*Amplify);
   BIQUADMemory.B1:=-(2*Cosinus);
   BIQUADMemory.B2:=1-(Alpha*Amplify);
   BIQUADMemory.A0:=1+(Alpha/Amplify);
   BIQUADMemory.A1:=-(2*Cosinus);
   BIQUADMemory.A2:=1-(Alpha/Amplify);
  end;
  fmBIQUADLOWSHELF:begin
   BIQUADMemory.Gain:=1;
   BIQUADMemory.B0:=Amplify*(((Amplify+1)-((Amplify-1)*Cosinus))+(Beta*Sinus));
   BIQUADMemory.B1:=2*Amplify*((Amplify-1)-((Amplify+1)*Cosinus));
   BIQUADMemory.B2:=Amplify*(((Amplify+1)-((Amplify-1)*Cosinus))-(Beta*Sinus));
   BIQUADMemory.A0:=((Amplify+1)+((Amplify-1)*Cosinus))+(Beta*Sinus);
   BIQUADMemory.A1:=-(2*((Amplify-1)+((Amplify+1)*Cosinus)));
   BIQUADMemory.A2:=((Amplify+1)+((Amplify-1)*Cosinus))-(Beta*Sinus);
  end;
  fmBIQUADHIGHSHELF:begin
   BIQUADMemory.Gain:=1;
   BIQUADMemory.B0:=Amplify*(((Amplify+1)+(Amplify-1)*Cosinus)+(Beta*Sinus));
   BIQUADMemory.B1:=-(2*Amplify*((Amplify-1)+(Amplify+1)*Cosinus));
   BIQUADMemory.B2:=Amplify*(((Amplify+1)+(Amplify-1)*Cosinus)-(Beta*Sinus));
   BIQUADMemory.A0:=((Amplify+1)-((Amplify-1)*Cosinus))+(Beta*Sinus);
   BIQUADMemory.A1:=2*((Amplify-1)-((Amplify+1)*Cosinus));
   BIQUADMemory.A2:=((Amplify+1)-((Amplify-1)*Cosinus))-(Beta*Sinus);
  end;
 end;
 SynthKillDenormal(BIQUADMemory.A0);
 if BIQUADMemory.A0<>0 then begin
  A0F:=1/BIQUADMemory.A0;
  BIQUADMemory.A1:=-(BIQUADMemory.A1*A0F);
  BIQUADMemory.A2:=-(BIQUADMemory.A2*A0F);
  BIQUADMemory.B0:=BIQUADMemory.B0*A0F;
  BIQUADMemory.B1:=BIQUADMemory.B1*A0F;
  BIQUADMemory.B2:=BIQUADMemory.B2*A0F;
  SynthKillDenormal(BIQUADMemory.A1);
  SynthKillDenormal(BIQUADMemory.A2);
  SynthKillDenormal(BIQUADMemory.B0);
  SynthKillDenormal(BIQUADMemory.B1);
  SynthKillDenormal(BIQUADMemory.B2);
 end else begin
  BIQUADMemory.A1:=0;
  BIQUADMemory.A2:=0;
  BIQUADMemory.B0:=0;
  BIQUADMemory.B1:=0;
  BIQUADMemory.B2:=0;
 end;
 BIQUADMemory.MinHz:=MinHz;
 BIQUADMemory.MaxHz:=MaxHz;
 BIQUADMemory.Ready:=true;
end;

type PSynthFilterValues=^TSynthFilterValues;
     TSynthFilterValues=array[fmLOWPASS..fmALLPASS] of single;

const SynthFilterFormantCoefs:array[ffvA..ffvU,0..10] of double=((8.11044e-06,8.943665402,-36.83889529,92.01697887,-154.337906,181.6233289,-151.8651235,89.09614114,-35.10298511,8.388101016,-0.923313471),
                                                                 (4.36215e-06,8.90438318,-36.55179099,91.05750846,-152.422234,179.1170248,-149.6496211,87.78352223,-34.60687431,8.282228154,-0.914150747),
                                                                 (3.33819e-06,8.893102966,-36.49532826,90.96543286,-152.4545478,179.4835618,-150.315433,88.43409371,-34.98612086,8.407803364,-0.932568035),
                                                                 (1.13572e-06,8.994734087,-37.2084849,93.22900521,-156.6929844,184.596544,-154.3755513,90.49663749,-35.58964535,8.478996281,-0.929252233),
                                                                 (4.09431e-07,8.997322763,-37.20218544,93.11385476,-156.2530937,183.7080141,-153.2631681,89.59539726,-35.12454591,8.338655623,-0.910251753));

procedure SynthInitMoogFilter(Track:PSynthTrack;var Memory:TSynthInstrumentFilterDataMoogMemory;const CutOff,Resonance,MinHz,MaxHz:single);{$ifdef cpu386}register;{$endif}
var fc,q:single;
begin
 fc:=Clip(Clip((CutOff*(MaxHz-MinHz))+MinHz,MinHz,MaxHz)*Track^.InternalHalfSampleRateFactor,0,1);
 q:=1.0-fc;
 Memory.p:=fc+(0.8*fc*q);
 Memory.f:=(Memory.p+Memory.p)-1.0;
 Memory.q:=Clip(Resonance,0,1)*(1.0+(0.5*q*(1.0-q+(5.6*sqr(q)))));
 SynthKillDenormal(Memory.p);
 SynthKillDenormal(Memory.f);
 SynthKillDenormal(Memory.q);
end;

function SynthProcessMoogFilter(var Memory:TSynthInstrumentFilterDataMoogMemory;Input:single;const Channel,Mode:longint):single;{$ifdef cpu386}register;{$endif}
var b:PSynthInstrumentFilterDataMoogHistoryMemory;
    t:array[0..1] of single;
    o:array[fmMOOGLOWPASS..fmMOOGBANDPASS] of single;
begin
 b:=@Memory.b[Channel and 1];
 Input:=Input-(Memory.q*b^[4]);
 longword(pointer(@Input)^):=longword(pointer(@Input)^) and longword($ffffffff+longword(((((longword(pointer(@Input)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 t[0]:=b^[1];
 b^[1]:=((Input+b^[0])*Memory.p)-(b^[1]*Memory.f);
 t[1]:=b^[2];
 b^[2]:=((b^[1]+t[0])*Memory.p)-(b^[2]*Memory.f);
 t[0]:=b^[3];
 b^[3]:=((b^[2]+t[1])*Memory.p)-(b^[3]*Memory.f);
 b^[4]:=((b^[3]+t[0])*Memory.p)-(b^[4]*Memory.f);
 b^[4]:=b^[4]-(b^[4]*b^[4]*b^[4]*0.166667);
 b^[0]:=Input;
 longword(pointer(@b^[1])^):=longword(pointer(@b^[1])^) and longword($ffffffff+longword(((((longword(pointer(@b^[1])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@b^[2])^):=longword(pointer(@b^[2])^) and longword($ffffffff+longword(((((longword(pointer(@b^[2])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@b^[3])^):=longword(pointer(@b^[3])^) and longword($ffffffff+longword(((((longword(pointer(@b^[3])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@b^[4])^):=longword(pointer(@b^[4])^) and longword($ffffffff+longword(((((longword(pointer(@b^[4])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 o[fmMOOGLOWPASS]:=b[4];
 o[fmMOOGHIGHPASS]:=Input-b[4];
 o[fmMOOGBANDPASS]:=3.0*(b[3]-b[4]);
 result:=o[Mode];
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthProcessFilter(Track:PSynthTrack;Filter:PSynthInstrumentFilter;FilterData:PSynthInstrumentFilterData;InputBuffer,OutputBuffer:PSynthBufferSample;CutOffBuffer,ResonanceBuffer,VolumeBuffer,AmplifyBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808FILTER}
var Counter:longint;
    Values:array[0..1,boolean] of TSynthFilterValues;
    F,f1,f2,Q,V,A,FF,FQ,FV,FA,OldFF,FormantFadeValue1,FormantFadeValue2,
    OldValue,Value,MinHz,MaxHz,FR,FO,i0,i1,o0,o1:single;
    FormantIndex1,FormantIndex2:longint;
    ValuesEx:PSynthFilterValues;
 procedure RecalculateFormantValues;
 var V:single;
 begin
  plongword(@OldFF)^:=plongword(@FF)^;
  V:=FF*4;
  FormantFadeValue1:=frac(V);
  FormantFadeValue2:=1-FormantFadeValue1;
  FormantIndex1:=SoftTRUNC(V);
  FormantIndex2:=FormantIndex1+1;
  if FormantIndex1>4 then begin
   FormantIndex1:=4;
  end;
  if FormantIndex2>4 then begin
   FormantIndex2:=4;
  end;
 end;
{$endif}
begin
{$ifdef BR808FILTER}
 F:=Filter^.CutOff*fCI255;
 V:=sqr(Filter^.Volume*fCI255);
 MinHz:=Clip(Filter^.MinHz,0,Track^.InternalSampleRate*0.5);
 MaxHz:=Clip(Filter^.MaxHz,MinHz,Track^.InternalSampleRate*0.5);
 FR:=MaxHz-MinHz;
 FO:=MinHz;
 case Filter^.Mode of
  fmLOWPASS..fmALLPASS:begin
   f1:=Clip(2*SIN(PI*Filter^.MinHz*Track^.InternalSampleRateFactor),0,1);
   f2:=Clip(2*SIN(PI*Filter^.MaxHz*Track^.InternalSampleRateFactor),0,1);
   Q:=Clip((Filter^.Resonance*fCI255),0,1);
   Values[0,false,fmLOWPASS]:=FilterData^.SVFMemory[0,false].Low;
   Values[0,false,fmBANDPASS]:=FilterData^.SVFMemory[0,false].Band;
   Values[0,false,fmHIGHPASS]:=FilterData^.SVFMemory[0,false].High;
   Values[0,true,fmLOWPASS]:=FilterData^.SVFMemory[0,true].Low;
   Values[0,true,fmBANDPASS]:=FilterData^.SVFMemory[0,true].Band;
   Values[0,true,fmHIGHPASS]:=FilterData^.SVFMemory[0,true].High;
   Values[1,false,fmLOWPASS]:=FilterData^.SVFMemory[1,false].Low;
   Values[1,false,fmBANDPASS]:=FilterData^.SVFMemory[1,false].Band;
   Values[1,false,fmHIGHPASS]:=FilterData^.SVFMemory[1,false].High;
   Values[1,true,fmLOWPASS]:=FilterData^.SVFMemory[1,true].Low;
   Values[1,true,fmBANDPASS]:=FilterData^.SVFMemory[1,true].Band;
   Values[1,true,fmHIGHPASS]:=FilterData^.SVFMemory[1,true].High;
   SynthKillDenormal(Values[0,false,fmLOWPASS]);
   SynthKillDenormal(Values[0,false,fmBANDPASS]);
   SynthKillDenormal(Values[0,false,fmHIGHPASS]);
   SynthKillDenormal(Values[0,false,fmNOTCH]);
   SynthKillDenormal(Values[0,false,fmALLPASS]);
   SynthKillDenormal(Values[1,false,fmLOWPASS]);
   SynthKillDenormal(Values[1,false,fmBANDPASS]);
   SynthKillDenormal(Values[1,false,fmHIGHPASS]);
   SynthKillDenormal(Values[1,false,fmNOTCH]);
   SynthKillDenormal(Values[1,false,fmALLPASS]);
   if (CutOffBuffer=Track^.F1D0Buffer) and (ResonanceBuffer=Track^.F1D0Buffer) and
      (VolumeBuffer=Track^.F1D0Buffer) then begin
    FF:=Clip(2*SIN(PI*((sqr(f)*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
    FQ:=1-Clip(1-sqr(1-Q),0,1);
    if Filter^.Cascaded then begin
     for Counter:=1 to Samples do begin
      begin
       ValuesEx:=@Values[0,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Left*V)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       begin
        ValuesEx:=@Values[0,true];
        ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
        ValuesEx^[fmHIGHPASS]:=((Values[0,false,Filter^.Mode]-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
        ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
        longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
        ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
        OutputBuffer^.Left:=ValuesEx^[Filter^.Mode];
       end;
      end;
      begin
       ValuesEx:=@Values[1,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Right*V)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       begin
        ValuesEx:=@Values[1,true];
        ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
        ValuesEx^[fmHIGHPASS]:=((Values[1,false,Filter^.Mode]-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
        ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
        longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
        ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
        OutputBuffer^.Right:=ValuesEx^[Filter^.Mode];
       end;
      end;
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
      begin
       ValuesEx:=@Values[0,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Left*V)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       OutputBuffer^.Left:=ValuesEx^[Filter^.Mode];
      end;
      begin
       ValuesEx:=@Values[1,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Right*V)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       OutputBuffer^.Right:=ValuesEx^[Filter^.Mode];
      end;
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end;
   end else begin
    if Filter^.Cascaded then begin
     for Counter:=1 to Samples do begin
      FF:=Clip(2*SIN(PI*((sqr(f)*CutOffBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
      FQ:=1-Clip(1-sqr(1-(Q*ResonanceBuffer^)),0,1);
      FV:=V*VolumeBuffer^;
      begin
       ValuesEx:=@Values[0,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Left*FV)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       begin
        ValuesEx:=@Values[0,true];
        ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
        ValuesEx^[fmHIGHPASS]:=((Values[0,false,Filter^.Mode]-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
        ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
        longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
        ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
        OutputBuffer^.Left:=ValuesEx^[Filter^.Mode];
       end;
      end;
      begin
       ValuesEx:=@Values[1,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Right*FV)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       begin
        ValuesEx:=@Values[1,true];
        ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
        ValuesEx^[fmHIGHPASS]:=((Values[1,false,Filter^.Mode]-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
        ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
        longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
        ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
        ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
        OutputBuffer^.Right:=ValuesEx^[Filter^.Mode];
       end;
      end;
      inc(InputBuffer);
      inc(OutputBuffer);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
      FF:=Clip(2*SIN(PI*((sqr(f)*CutOffBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
      FQ:=1-Clip(1-sqr(1-(Q*ResonanceBuffer^)),0,1);
      FV:=V*VolumeBuffer^;
      begin
       ValuesEx:=@Values[0,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Left*FV)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       OutputBuffer^.Left:=ValuesEx^[Filter^.Mode];
      end;
      begin
       ValuesEx:=@Values[1,false];
       ValuesEx^[fmLOWPASS]:=ValuesEx^[fmLOWPASS]+(FF*ValuesEx^[fmBANDPASS]);
       ValuesEx^[fmHIGHPASS]:=(((InputBuffer^.Right*FV)-ValuesEx^[fmLOWPASS])-(FQ*ValuesEx^[fmBANDPASS]));
       ValuesEx^[fmBANDPASS]:=(FF*ValuesEx^[fmHIGHPASS])+ValuesEx^[fmBANDPASS];
       longword(pointer(@ValuesEx^[fmLOWPASS])^):=longword(pointer(@ValuesEx^[fmLOWPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmLOWPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       longword(pointer(@ValuesEx^[fmBANDPASS])^):=longword(pointer(@ValuesEx^[fmBANDPASS])^) and longword($ffffffff+longword(((((longword(pointer(@ValuesEx^[fmBANDPASS])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       ValuesEx^[fmNOTCH]:=ValuesEx^[fmHIGHPASS]+ValuesEx^[fmLOWPASS];
       ValuesEx^[fmALLPASS]:=ValuesEx^[fmNOTCH]+ValuesEx^[fmBANDPASS];
       OutputBuffer^.Right:=ValuesEx^[Filter^.Mode];
      end;
      inc(InputBuffer);
      inc(OutputBuffer);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
     end;
    end;
   end;
   FilterData^.SVFMemory[0,false].Low:=Values[0,false,fmLOWPASS];
   FilterData^.SVFMemory[0,false].Band:=Values[0,false,fmBANDPASS];
   FilterData^.SVFMemory[0,false].High:=Values[0,false,fmHIGHPASS];
   FilterData^.SVFMemory[0,true].Low:=Values[0,true,fmLOWPASS];
   FilterData^.SVFMemory[0,true].Band:=Values[0,true,fmBANDPASS];
   FilterData^.SVFMemory[0,true].High:=Values[0,true,fmHIGHPASS];
   FilterData^.SVFMemory[1,false].Low:=Values[1,false,fmLOWPASS];
   FilterData^.SVFMemory[1,false].Band:=Values[1,false,fmBANDPASS];
   FilterData^.SVFMemory[1,false].High:=Values[1,false,fmHIGHPASS];
   FilterData^.SVFMemory[1,true].Low:=Values[1,true,fmLOWPASS];
   FilterData^.SVFMemory[1,true].Band:=Values[1,true,fmBANDPASS];
   FilterData^.SVFMemory[1,true].High:=Values[1,true,fmHIGHPASS];
  end;
  fmBIQUADLOWPASS..fmBIQUADHIGHSHELF:begin
   Q:=Clip(Filter^.Resonance*fCI255,0,1);
   A:=power(10,Filter^.Amplify/40);
   if (CutOffBuffer=Track^.F1D0Buffer) and (ResonanceBuffer=Track^.F1D0Buffer) and
      (VolumeBuffer=Track^.F1D0Buffer) and (AmplifyBuffer=Track^.F1D0Buffer) then begin
    FF:=Clip(sqr(F),0.0,1);
    FQ:=Clip(Q,0,1);
    FV:=V;
    FA:=A;
    if FilterData^.BIQUADMemory.Ready then begin
     if (FilterData^.BIQUADMemory.VF<>FF) or
        (FilterData^.BIQUADMemory.VQ<>FQ) or
        (FilterData^.BIQUADMemory.VA<>FA) or
        (FilterData^.BIQUADMemory.MinHz<>MinHz) or
        (FilterData^.BIQUADMemory.MaxHz<>MaxHz) then begin
      FilterData^.BIQUADMemory.Ready:=false;
     end;
    end;
    if not FilterData^.BIQUADMemory.Ready then begin
     SynthInitBIQUADFilter(Track,Filter^.Mode,FilterData^.BIQUADMemory,FF,FQ,FA,MinHz,MaxHz);
    end;
    if Filter^.Cascaded then begin
     if FilterData^.BIQUADMemoryCascaded.Ready then begin
      if (FilterData^.BIQUADMemoryCascaded.VF<>FF) or
         (FilterData^.BIQUADMemoryCascaded.VQ<>FQ) or
         (FilterData^.BIQUADMemoryCascaded.VA<>FA) or
         (FilterData^.BIQUADMemoryCascaded.MinHz<>MinHz) or
         (FilterData^.BIQUADMemoryCascaded.MaxHz<>MaxHz) then begin
       FilterData^.BIQUADMemoryCascaded.Ready:=false;
      end;
     end;
     if not FilterData^.BIQUADMemoryCascaded.Ready then begin
      SynthInitBIQUADFilter(Track,Filter^.Mode,FilterData^.BIQUADMemoryCascaded,FF,FQ,FA,MinHz,MaxHz);
     end;
    end;
    if Filter^.Cascaded then begin
     for Counter:=1 to Samples do begin

      OldValue:=InputBuffer^.Left*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1L*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2L*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1L*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2L*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2L:=FilterData^.BIQUADMemory.HA1L;
      FilterData^.BIQUADMemory.HA1L:=Value;
      FilterData^.BIQUADMemory.HB2L:=FilterData^.BIQUADMemory.HB1L;
      FilterData^.BIQUADMemory.HB1L:=OldValue;
      OutputBuffer^.Left:=Value;

      OldValue:=OutputBuffer^.Left;
      Value:=(OldValue*FilterData^.BIQUADMemoryCascaded.B0)+(FilterData^.BIQUADMemoryCascaded.HB1L*FilterData^.BIQUADMemoryCascaded.B1)+(FilterData^.BIQUADMemoryCascaded.HB2L*FilterData^.BIQUADMemoryCascaded.B2)+(FilterData^.BIQUADMemoryCascaded.HA1L*FilterData^.BIQUADMemoryCascaded.A1)+(FilterData^.BIQUADMemoryCascaded.HA2L*FilterData^.BIQUADMemoryCascaded.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemoryCascaded.HA2L:=FilterData^.BIQUADMemoryCascaded.HA1L;
      FilterData^.BIQUADMemoryCascaded.HA1L:=Value;
      FilterData^.BIQUADMemoryCascaded.HB2L:=FilterData^.BIQUADMemoryCascaded.HB1L;
      FilterData^.BIQUADMemoryCascaded.HB1L:=OldValue;
      OutputBuffer^.Left:=Value;

      OldValue:=InputBuffer^.Right*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1R*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2R*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1R*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2R*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2R:=FilterData^.BIQUADMemory.HA1R;
      FilterData^.BIQUADMemory.HA1R:=Value;
      FilterData^.BIQUADMemory.HB2R:=FilterData^.BIQUADMemory.HB1R;
      FilterData^.BIQUADMemory.HB1R:=OldValue;
      OutputBuffer^.Right:=Value;

      OldValue:=OutputBuffer^.Right;
      Value:=(OldValue*FilterData^.BIQUADMemoryCascaded.B0)+(FilterData^.BIQUADMemoryCascaded.HB1R*FilterData^.BIQUADMemoryCascaded.B1)+(FilterData^.BIQUADMemoryCascaded.HB2R*FilterData^.BIQUADMemoryCascaded.B2)+(FilterData^.BIQUADMemoryCascaded.HA1R*FilterData^.BIQUADMemoryCascaded.A1)+(FilterData^.BIQUADMemoryCascaded.HA2R*FilterData^.BIQUADMemoryCascaded.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemoryCascaded.HA2R:=FilterData^.BIQUADMemoryCascaded.HA1R;
      FilterData^.BIQUADMemoryCascaded.HA1R:=Value;
      FilterData^.BIQUADMemoryCascaded.HB2R:=FilterData^.BIQUADMemoryCascaded.HB1R;
      FilterData^.BIQUADMemoryCascaded.HB1R:=OldValue;
      OutputBuffer^.Right:=Value;

      inc(FilterData^.BIQUADMemory.Samples);
      inc(FilterData^.BIQUADMemoryCascaded.Samples);

      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
     
      OldValue:=InputBuffer^.Left*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1L*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2L*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1L*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2L*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2L:=FilterData^.BIQUADMemory.HA1L;
      FilterData^.BIQUADMemory.HA1L:=Value;
      FilterData^.BIQUADMemory.HB2L:=FilterData^.BIQUADMemory.HB1L;
      FilterData^.BIQUADMemory.HB1L:=OldValue;
      OutputBuffer^.Left:=Value;

      OldValue:=InputBuffer^.Right*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1R*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2R*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1R*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2R*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2R:=FilterData^.BIQUADMemory.HA1R;
      FilterData^.BIQUADMemory.HA1R:=Value;
      FilterData^.BIQUADMemory.HB2R:=FilterData^.BIQUADMemory.HB1R;
      FilterData^.BIQUADMemory.HB1R:=OldValue;
      OutputBuffer^.Right:=Value;
      
      inc(FilterData^.BIQUADMemory.Samples);

      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end;
   end else begin
    if Filter^.Cascaded then begin
     for Counter:=1 to Samples do begin
      FF:=Clip(sqr(F)*CutOffBuffer^,0.0,1);
      FQ:=Clip(Q*ResonanceBuffer^,0,1);
      FV:=V*VolumeBuffer^;
      FA:=A*AmplifyBuffer^;

      if FilterData^.BIQUADMemory.Ready then begin
       if (FilterData^.BIQUADMemory.Samples>=longword(Track^.RampingSamples)) and
          ((FilterData^.BIQUADMemory.VF<>FF) or
           (FilterData^.BIQUADMemory.VQ<>FQ) or
           (FilterData^.BIQUADMemory.VA<>FA) or
           (FilterData^.BIQUADMemory.MinHz<>MinHz) or
           (FilterData^.BIQUADMemory.MaxHz<>MaxHz)) then begin
        FilterData^.BIQUADMemory.Ready:=false;
       end;
      end;
      if not FilterData^.BIQUADMemory.Ready then begin
       SynthInitBIQUADFilter(Track,Filter^.Mode,FilterData^.BIQUADMemory,FF,FQ,FA,MinHz,MaxHz);
      end;

      OldValue:=InputBuffer^.Left*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1L*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2L*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1L*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2L*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2L:=FilterData^.BIQUADMemory.HA1L;
      FilterData^.BIQUADMemory.HA1L:=Value;
      FilterData^.BIQUADMemory.HB2L:=FilterData^.BIQUADMemory.HB1L;
      FilterData^.BIQUADMemory.HB1L:=OldValue;
      OutputBuffer^.Left:=Value;

      OldValue:=InputBuffer^.Right*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1R*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2R*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1R*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2R*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2R:=FilterData^.BIQUADMemory.HA1R;
      FilterData^.BIQUADMemory.HA1R:=Value;
      FilterData^.BIQUADMemory.HB2R:=FilterData^.BIQUADMemory.HB1R;
      FilterData^.BIQUADMemory.HB1R:=OldValue;
      OutputBuffer^.Right:=Value;

      inc(FilterData^.BIQUADMemory.Samples);

      begin
       if FilterData^.BIQUADMemoryCascaded.Ready then begin
        if (FilterData^.BIQUADMemoryCascaded.Samples>=longword(Track^.RampingSamples)) and
           ((FilterData^.BIQUADMemoryCascaded.VF<>FF) or
            (FilterData^.BIQUADMemoryCascaded.VQ<>FQ) or
            (FilterData^.BIQUADMemoryCascaded.VA<>FA) or
            (FilterData^.BIQUADMemoryCascaded.MinHz<>MinHz) or
            (FilterData^.BIQUADMemoryCascaded.MaxHz<>MaxHz)) then begin
         FilterData^.BIQUADMemoryCascaded.Ready:=false;
        end;
       end;

       if not FilterData^.BIQUADMemoryCascaded.Ready then begin
        SynthInitBIQUADFilter(Track,Filter^.Mode,FilterData^.BIQUADMemoryCascaded,FF,FQ,FA,MinHz,MaxHz);
       end;

       OldValue:=OutputBuffer^.Left;
       Value:=(OldValue*FilterData^.BIQUADMemoryCascaded.B0)+(FilterData^.BIQUADMemoryCascaded.HB1L*FilterData^.BIQUADMemoryCascaded.B1)+(FilterData^.BIQUADMemoryCascaded.HB2L*FilterData^.BIQUADMemoryCascaded.B2)+(FilterData^.BIQUADMemoryCascaded.HA1L*FilterData^.BIQUADMemoryCascaded.A1)+(FilterData^.BIQUADMemoryCascaded.HA2L*FilterData^.BIQUADMemoryCascaded.A2);
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       FilterData^.BIQUADMemoryCascaded.HA2L:=FilterData^.BIQUADMemoryCascaded.HA1L;
       FilterData^.BIQUADMemoryCascaded.HA1L:=Value;
       FilterData^.BIQUADMemoryCascaded.HB2L:=FilterData^.BIQUADMemoryCascaded.HB1L;
       FilterData^.BIQUADMemoryCascaded.HB1L:=OldValue;
       OutputBuffer^.Left:=Value;

       OldValue:=OutputBuffer^.Right;
       Value:=(OldValue*FilterData^.BIQUADMemoryCascaded.B0)+(FilterData^.BIQUADMemoryCascaded.HB1R*FilterData^.BIQUADMemoryCascaded.B1)+(FilterData^.BIQUADMemoryCascaded.HB2R*FilterData^.BIQUADMemoryCascaded.B2)+(FilterData^.BIQUADMemoryCascaded.HA1R*FilterData^.BIQUADMemoryCascaded.A1)+(FilterData^.BIQUADMemoryCascaded.HA2R*FilterData^.BIQUADMemoryCascaded.A2);
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       FilterData^.BIQUADMemoryCascaded.HA2R:=FilterData^.BIQUADMemoryCascaded.HA1R;
       FilterData^.BIQUADMemoryCascaded.HA1R:=Value;
       FilterData^.BIQUADMemoryCascaded.HB2R:=FilterData^.BIQUADMemoryCascaded.HB1R;
       FilterData^.BIQUADMemoryCascaded.HB1R:=OldValue;
       OutputBuffer^.Right:=Value;

       inc(FilterData^.BIQUADMemoryCascaded.Samples);
      end;
      inc(InputBuffer);
      inc(OutputBuffer);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
      inc(AmplifyBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
      FF:=Clip(sqr(F)*CutOffBuffer^,0.0,1);
      FQ:=Clip(Q*ResonanceBuffer^,0,1);
      FV:=V*VolumeBuffer^;
      FA:=A*AmplifyBuffer^;

      if FilterData^.BIQUADMemory.Ready then begin
       if (FilterData^.BIQUADMemory.Samples>=longword(Track^.RampingSamples)) and
          ((FilterData^.BIQUADMemory.VF<>FF) or
           (FilterData^.BIQUADMemory.VQ<>FQ) or
           (FilterData^.BIQUADMemory.VA<>FA) or
           (FilterData^.BIQUADMemory.MinHz<>MinHz) or
           (FilterData^.BIQUADMemory.MaxHz<>MaxHz)) then begin
        FilterData^.BIQUADMemory.Ready:=false;
       end;
      end;
      if not FilterData^.BIQUADMemory.Ready then begin
       SynthInitBIQUADFilter(Track,Filter^.Mode,FilterData^.BIQUADMemory,FF,FQ,FA,MinHz,MaxHz);
      end;

      OldValue:=InputBuffer^.Left*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1L*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2L*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1L*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2L*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2L:=FilterData^.BIQUADMemory.HA1L;
      FilterData^.BIQUADMemory.HA1L:=Value;
      FilterData^.BIQUADMemory.HB2L:=FilterData^.BIQUADMemory.HB1L;
      FilterData^.BIQUADMemory.HB1L:=OldValue;
      OutputBuffer^.Left:=Value;

      OldValue:=InputBuffer^.Right*FV;
      Value:=(OldValue*FilterData^.BIQUADMemory.B0)+(FilterData^.BIQUADMemory.HB1R*FilterData^.BIQUADMemory.B1)+(FilterData^.BIQUADMemory.HB2R*FilterData^.BIQUADMemory.B2)+(FilterData^.BIQUADMemory.HA1R*FilterData^.BIQUADMemory.A1)+(FilterData^.BIQUADMemory.HA2R*FilterData^.BIQUADMemory.A2);
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.BIQUADMemory.HA2R:=FilterData^.BIQUADMemory.HA1R;
      FilterData^.BIQUADMemory.HA1R:=Value;
      FilterData^.BIQUADMemory.HB2R:=FilterData^.BIQUADMemory.HB1R;
      FilterData^.BIQUADMemory.HB1R:=OldValue;
      OutputBuffer^.Right:=Value;

      inc(FilterData^.BIQUADMemory.Samples);

      inc(InputBuffer);
      inc(OutputBuffer);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
      inc(AmplifyBuffer);
     end;
    end;
   end;
  end;
  fmFORMANT:begin
{$ifdef BR808FORMANTFILTER}
   OldFF:=-1;
   FF:=Clip(F*CutOffBuffer^,0,1);
   RecalculateFormantValues;
   if Filter^.Cascaded then begin
    for Counter:=1 to Samples do begin
     FF:=Clip(F*CutOffBuffer^,0,1);
     if plongword(@OldFF)^<>plongword(@FF)^ then begin
      RecalculateFormantValues;
     end;
     FV:=V*VolumeBuffer^;
     OutputBuffer^.Left:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*(InputBuffer^.Left*FV))+
                         (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemory[0,0])+
                         (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemory[0,1])+
                         (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemory[0,2])+
                         (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemory[0,3])+
                         (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemory[0,4])+
                         (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemory[0,5])+
                         (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemory[0,6])+
                         (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemory[0,7])+
                         (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemory[0,8])+
                         (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemory[0,9]);
     longword(pointer(@OutputBuffer^.Left)^):=longword(pointer(@OutputBuffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     FilterData^.FormantMemory[0,9]:=FilterData^.FormantMemory[0,8];
     FilterData^.FormantMemory[0,8]:=FilterData^.FormantMemory[0,7];
     FilterData^.FormantMemory[0,7]:=FilterData^.FormantMemory[0,6];
     FilterData^.FormantMemory[0,6]:=FilterData^.FormantMemory[0,5];
     FilterData^.FormantMemory[0,5]:=FilterData^.FormantMemory[0,4];
     FilterData^.FormantMemory[0,4]:=FilterData^.FormantMemory[0,3];
     FilterData^.FormantMemory[0,3]:=FilterData^.FormantMemory[0,2];
     FilterData^.FormantMemory[0,2]:=FilterData^.FormantMemory[0,1];
     FilterData^.FormantMemory[0,1]:=FilterData^.FormantMemory[0,0];
     FilterData^.FormantMemory[0,0]:=OutputBuffer^.Left;
     OutputBuffer^.Right:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*(InputBuffer^.Right*FV))+
                          (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemory[1,0])+
                          (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemory[1,1])+
                          (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemory[1,2])+
                          (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemory[1,3])+
                          (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemory[1,4])+
                          (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemory[1,5])+
                          (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemory[1,6])+
                          (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemory[1,7])+
                          (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemory[1,8])+
                          (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemory[1,9]);
     longword(pointer(@OutputBuffer^.Right)^):=longword(pointer(@OutputBuffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     FilterData^.FormantMemory[1,9]:=FilterData^.FormantMemory[1,8];
     FilterData^.FormantMemory[1,8]:=FilterData^.FormantMemory[1,7];
     FilterData^.FormantMemory[1,7]:=FilterData^.FormantMemory[1,6];
     FilterData^.FormantMemory[1,6]:=FilterData^.FormantMemory[1,5];
     FilterData^.FormantMemory[1,5]:=FilterData^.FormantMemory[1,4];
     FilterData^.FormantMemory[1,4]:=FilterData^.FormantMemory[1,3];
     FilterData^.FormantMemory[1,3]:=FilterData^.FormantMemory[1,2];
     FilterData^.FormantMemory[1,2]:=FilterData^.FormantMemory[1,1];
     FilterData^.FormantMemory[1,1]:=FilterData^.FormantMemory[1,0];
     FilterData^.FormantMemory[1,0]:=OutputBuffer^.Right;
     begin
      OutputBuffer^.Left:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*OutputBuffer^.Left)+
                          (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,0])+
                          (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,1])+
                          (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,2])+
                          (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,3])+
                          (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,4])+
                          (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,5])+
                          (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,6])+
                          (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,7])+
                          (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,8])+
                          (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[0,9]);
      longword(pointer(@OutputBuffer^.Left)^):=longword(pointer(@OutputBuffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.FormantMemoryCascaded[0,9]:=FilterData^.FormantMemoryCascaded[0,8];
      FilterData^.FormantMemoryCascaded[0,8]:=FilterData^.FormantMemoryCascaded[0,7];
      FilterData^.FormantMemoryCascaded[0,7]:=FilterData^.FormantMemoryCascaded[0,6];
      FilterData^.FormantMemoryCascaded[0,6]:=FilterData^.FormantMemoryCascaded[0,5];
      FilterData^.FormantMemoryCascaded[0,5]:=FilterData^.FormantMemoryCascaded[0,4];
      FilterData^.FormantMemoryCascaded[0,4]:=FilterData^.FormantMemoryCascaded[0,3];
      FilterData^.FormantMemoryCascaded[0,3]:=FilterData^.FormantMemoryCascaded[0,2];
      FilterData^.FormantMemoryCascaded[0,2]:=FilterData^.FormantMemoryCascaded[0,1];
      FilterData^.FormantMemoryCascaded[0,1]:=FilterData^.FormantMemoryCascaded[0,0];
      FilterData^.FormantMemoryCascaded[0,0]:=OutputBuffer^.Left;
      OutputBuffer^.Right:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*OutputBuffer^.Right)+
                           (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,0])+
                           (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,1])+
                           (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,2])+
                           (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,3])+
                           (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,4])+
                           (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,5])+
                           (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,6])+
                           (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,7])+
                           (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,8])+
                           (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemoryCascaded[1,9]);
      longword(pointer(@OutputBuffer^.Right)^):=longword(pointer(@OutputBuffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      FilterData^.FormantMemoryCascaded[1,9]:=FilterData^.FormantMemoryCascaded[1,8];
      FilterData^.FormantMemoryCascaded[1,8]:=FilterData^.FormantMemoryCascaded[1,7];
      FilterData^.FormantMemoryCascaded[1,7]:=FilterData^.FormantMemoryCascaded[1,6];
      FilterData^.FormantMemoryCascaded[1,6]:=FilterData^.FormantMemoryCascaded[1,5];
      FilterData^.FormantMemoryCascaded[1,5]:=FilterData^.FormantMemoryCascaded[1,4];
      FilterData^.FormantMemoryCascaded[1,4]:=FilterData^.FormantMemoryCascaded[1,3];
      FilterData^.FormantMemoryCascaded[1,3]:=FilterData^.FormantMemoryCascaded[1,2];
      FilterData^.FormantMemoryCascaded[1,2]:=FilterData^.FormantMemoryCascaded[1,1];
      FilterData^.FormantMemoryCascaded[1,1]:=FilterData^.FormantMemoryCascaded[1,0];
      FilterData^.FormantMemoryCascaded[1,0]:=OutputBuffer^.Right;
     end;
     inc(InputBuffer);
     inc(OutputBuffer);
     inc(CutOffBuffer);
     inc(VolumeBuffer);
    end;
   end else begin
    for Counter:=1 to Samples do begin
     FF:=Clip(F*CutOffBuffer^,0,1);
     if plongword(@OldFF)^<>plongword(@FF)^ then begin
      RecalculateFormantValues;
     end;
     FV:=V*VolumeBuffer^;
     OutputBuffer^.Left:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*(InputBuffer^.Left*FV))+
                         (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemory[0,0])+
                         (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemory[0,1])+
                         (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemory[0,2])+
                         (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemory[0,3])+
                         (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemory[0,4])+
                         (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemory[0,5])+
                         (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemory[0,6])+
                         (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemory[0,7])+
                         (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemory[0,8])+
                         (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemory[0,9]);
     longword(pointer(@OutputBuffer^.Left)^):=longword(pointer(@OutputBuffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     FilterData^.FormantMemory[0,9]:=FilterData^.FormantMemory[0,8];
     FilterData^.FormantMemory[0,8]:=FilterData^.FormantMemory[0,7];
     FilterData^.FormantMemory[0,7]:=FilterData^.FormantMemory[0,6];
     FilterData^.FormantMemory[0,6]:=FilterData^.FormantMemory[0,5];
     FilterData^.FormantMemory[0,5]:=FilterData^.FormantMemory[0,4];
     FilterData^.FormantMemory[0,4]:=FilterData^.FormantMemory[0,3];
     FilterData^.FormantMemory[0,3]:=FilterData^.FormantMemory[0,2];
     FilterData^.FormantMemory[0,2]:=FilterData^.FormantMemory[0,1];
     FilterData^.FormantMemory[0,1]:=FilterData^.FormantMemory[0,0];
     FilterData^.FormantMemory[0,0]:=OutputBuffer^.Left;
     OutputBuffer^.Right:=(((SynthFilterFormantCoefs[FormantIndex1,0]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,0]*FormantFadeValue1))*(InputBuffer^.Right*FV))+
                          (((SynthFilterFormantCoefs[FormantIndex1,1]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,1]*FormantFadeValue1))*FilterData^.FormantMemory[1,0])+
                          (((SynthFilterFormantCoefs[FormantIndex1,2]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,2]*FormantFadeValue1))*FilterData^.FormantMemory[1,1])+
                          (((SynthFilterFormantCoefs[FormantIndex1,3]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,3]*FormantFadeValue1))*FilterData^.FormantMemory[1,2])+
                          (((SynthFilterFormantCoefs[FormantIndex1,4]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,4]*FormantFadeValue1))*FilterData^.FormantMemory[1,3])+
                          (((SynthFilterFormantCoefs[FormantIndex1,5]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,5]*FormantFadeValue1))*FilterData^.FormantMemory[1,4])+
                          (((SynthFilterFormantCoefs[FormantIndex1,6]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,6]*FormantFadeValue1))*FilterData^.FormantMemory[1,5])+
                          (((SynthFilterFormantCoefs[FormantIndex1,7]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,7]*FormantFadeValue1))*FilterData^.FormantMemory[1,6])+
                          (((SynthFilterFormantCoefs[FormantIndex1,8]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,8]*FormantFadeValue1))*FilterData^.FormantMemory[1,7])+
                          (((SynthFilterFormantCoefs[FormantIndex1,9]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,9]*FormantFadeValue1))*FilterData^.FormantMemory[1,8])+
                          (((SynthFilterFormantCoefs[FormantIndex1,10]*FormantFadeValue2)+(SynthFilterFormantCoefs[FormantIndex2,10]*FormantFadeValue1))*FilterData^.FormantMemory[1,9]);
     longword(pointer(@OutputBuffer^.Right)^):=longword(pointer(@OutputBuffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     FilterData^.FormantMemory[1,9]:=FilterData^.FormantMemory[1,8];
     FilterData^.FormantMemory[1,8]:=FilterData^.FormantMemory[1,7];
     FilterData^.FormantMemory[1,7]:=FilterData^.FormantMemory[1,6];
     FilterData^.FormantMemory[1,6]:=FilterData^.FormantMemory[1,5];
     FilterData^.FormantMemory[1,5]:=FilterData^.FormantMemory[1,4];
     FilterData^.FormantMemory[1,4]:=FilterData^.FormantMemory[1,3];
     FilterData^.FormantMemory[1,3]:=FilterData^.FormantMemory[1,2];
     FilterData^.FormantMemory[1,2]:=FilterData^.FormantMemory[1,1];
     FilterData^.FormantMemory[1,1]:=FilterData^.FormantMemory[1,0];
     FilterData^.FormantMemory[1,0]:=OutputBuffer^.Right;
     inc(InputBuffer);
     inc(OutputBuffer);
     inc(CutOffBuffer);
     inc(VolumeBuffer);
    end;
   end;
{$endif}   
  end;
  fmOVERDRIVE:begin
{$ifdef BR808OVERRIDEFILTER}
   f1:=Clip(2*SIN(PI*Filter^.MinHz*Track^.InternalSampleRateFactor),0,1);
   f2:=Clip(2*SIN(PI*Filter^.MaxHz*Track^.InternalSampleRateFactor),0,1);
   Q:=Clip(Filter^.Resonance*fCI255,0,1);
   A:=power(10,Filter^.Amplify/40);
   if Filter^.Cascaded then begin
    for Counter:=1 to Samples do begin
     FF:=Clip(2*SIN(PI*((sqr(f)*CutOffBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
     FQ:=Clip(2*SIN(PI*((sqr(q)*ResonanceBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
     FV:=V*VolumeBuffer^;
     FA:=A*AmplifyBuffer^;

     i0:=InputBuffer^.Left*FA;
     if i0<0 then begin
      o0:=-FastSQRT(-i0);
     end else begin
      o0:=FastSQRT(i0);
     end;

     i1:=InputBuffer^.Right*FA;
     if i1<0 then begin
      o1:=-FastSQRT(-i1);
     end else begin
      o1:=FastSQRT(i1);
     end;

     FilterData^.OverdriveLeft:=FilterData^.OverdriveLeft+(ff*(((fq*(o0-i0))+i0)-FilterData^.OverdriveLeft));
     FilterData^.OverdriveRight:=FilterData^.OverdriveRight+(ff*(((fq*(o1-i1))+i1)-FilterData^.OverdriveRight));

     longword(pointer(@FilterData^.OverdriveLeft)^):=longword(pointer(@FilterData^.OverdriveLeft)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FilterData^.OverdriveRight)^):=longword(pointer(@FilterData^.OverdriveRight)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

     i0:=FilterData^.OverdriveLeft;
     if i0<0 then begin
      o0:=-FastSQRT(-i0);
     end else begin
      o0:=FastSQRT(i0);
     end;

     i1:=FilterData^.OverdriveRight;
     if i1<0 then begin
      o1:=-FastSQRT(-i1);
     end else begin
      o1:=FastSQRT(i1);
     end;

     FilterData^.OverdriveLeftCascaded:=FilterData^.OverdriveLeftCascaded+(ff*(((fq*(o0-i0))+i0)-FilterData^.OverdriveLeftCascaded));
     FilterData^.OverdriveRightCascaded:=FilterData^.OverdriveRightCascaded+(ff*(((fq*(o1-i1))+i1)-FilterData^.OverdriveRightCascaded));

     longword(pointer(@FilterData^.OverdriveLeftCascaded)^):=longword(pointer(@FilterData^.OverdriveLeftCascaded)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveLeftCascaded)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FilterData^.OverdriveRightCascaded)^):=longword(pointer(@FilterData^.OverdriveRightCascaded)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveRightCascaded)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

     OutputBuffer^.Left:=FilterData^.OverdriveLeftCascaded*FV;
     OutputBuffer^.Right:=FilterData^.OverdriveRightCascaded*FV;

     longword(pointer(@OutputBuffer^.Left)^):=longword(pointer(@OutputBuffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@OutputBuffer^.Right)^):=longword(pointer(@OutputBuffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

     inc(InputBuffer);
     inc(OutputBuffer);
     inc(CutOffBuffer);
     inc(ResonanceBuffer);
     inc(VolumeBuffer);
     inc(AmplifyBuffer);
    end;
   end else begin
    for Counter:=1 to Samples do begin
     FF:=Clip(2*SIN(PI*((sqr(f)*CutOffBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
     FQ:=Clip(2*SIN(PI*((sqr(q)*ResonanceBuffer^*FR)+FO)*Track^.InternalSampleRateFactor),f1,f2);
     FV:=V*VolumeBuffer^;
     FA:=A*AmplifyBuffer^;

     i0:=InputBuffer^.Left*FA;
     if i0<0 then begin
      o0:=-FastSQRT(-i0);
     end else begin
      o0:=FastSQRT(i0);
     end;

     i1:=InputBuffer^.Right*FA;
     if i1<0 then begin
      o1:=-FastSQRT(-i1);
     end else begin
      o1:=FastSQRT(i1);
     end;

     FilterData^.OverdriveLeft:=FilterData^.OverdriveLeft+(ff*(((fq*(o0-i0))+i0)-FilterData^.OverdriveLeft));
     FilterData^.OverdriveRight:=FilterData^.OverdriveRight+(ff*(((fq*(o1-i1))+i1)-FilterData^.OverdriveRight));

     longword(pointer(@FilterData^.OverdriveLeft)^):=longword(pointer(@FilterData^.OverdriveLeft)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FilterData^.OverdriveRight)^):=longword(pointer(@FilterData^.OverdriveRight)^) and longword($ffffffff+longword(((((longword(pointer(@FilterData^.OverdriveRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

     OutputBuffer^.Left:=FilterData^.OverdriveLeft*FV;
     OutputBuffer^.Right:=FilterData^.OverdriveRight*FV;

     longword(pointer(@OutputBuffer^.Left)^):=longword(pointer(@OutputBuffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@OutputBuffer^.Right)^):=longword(pointer(@OutputBuffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@OutputBuffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

     inc(InputBuffer);
     inc(OutputBuffer);
     inc(CutOffBuffer);
     inc(ResonanceBuffer);
     inc(VolumeBuffer);
     inc(AmplifyBuffer);
    end;
   end;
{$endif}
  end;
  fmMOOGLOWPASS..fmMOOGBANDPASS:begin
{$ifdef BR808MOOGFILTER}
   Q:=Clip(Filter^.Resonance*fCI255,0,1);
   if (CutOffBuffer=Track^.F1D0Buffer) and (ResonanceBuffer=Track^.F1D0Buffer) and
      (VolumeBuffer=Track^.F1D0Buffer) then begin
    SynthInitMoogFilter(Track,FilterData^.MoogMemory,sqr(f),q,MinHz,MaxHz);
    if Filter^.Cascaded then begin
     SynthInitMoogFilter(Track,FilterData^.MoogMemoryCascaded,sqr(f),q,MinHz,MaxHz);
     for Counter:=1 to Samples do begin
      OutputBuffer^.Left:=SynthProcessMoogFilter(FilterData^.MoogMemoryCascaded,SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Left*V,0,Filter^.Mode),0,Filter^.Mode);
      OutputBuffer^.Right:=SynthProcessMoogFilter(FilterData^.MoogMemoryCascaded,SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Right*V,1,Filter^.Mode),1,Filter^.Mode);
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
      OutputBuffer^.Left:=SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Left*V,0,Filter^.Mode);
      OutputBuffer^.Right:=SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Right*V,1,Filter^.Mode);
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end;
   end else begin
    if Filter^.Cascaded then begin
     for Counter:=1 to Samples do begin
      SynthInitMoogFilter(Track,FilterData^.MoogMemory,Clip(sqr(f)*CutOffBuffer^,0.0,1.0),Clip(q*ResonanceBuffer^,0,1.0),MinHz,MaxHz);
      SynthInitMoogFilter(Track,FilterData^.MoogMemoryCascaded,Clip(sqr(f)*CutOffBuffer^,0.0,1.0),Clip(q*ResonanceBuffer^,0,1.0),MinHz,MaxHz);
      OutputBuffer^.Left:=SynthProcessMoogFilter(FilterData^.MoogMemoryCascaded,SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Left*VolumeBuffer^*V,0,Filter^.Mode),0,Filter^.Mode);
      OutputBuffer^.Right:=SynthProcessMoogFilter(FilterData^.MoogMemoryCascaded,SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Right*VolumeBuffer^*V,1,Filter^.Mode),1,Filter^.Mode);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end else begin
     for Counter:=1 to Samples do begin
      SynthInitMoogFilter(Track,FilterData^.MoogMemory,Clip(sqr(f)*CutOffBuffer^,0.0,1.0),Clip(q*ResonanceBuffer^,0,1.0),MinHz,MaxHz);
      OutputBuffer^.Left:=SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Left*VolumeBuffer^*V,0,Filter^.Mode);
      OutputBuffer^.Right:=SynthProcessMoogFilter(FilterData^.MoogMemory,InputBuffer^.Right*VolumeBuffer^*V,1,Filter^.Mode);
      inc(CutOffBuffer);
      inc(ResonanceBuffer);
      inc(VolumeBuffer);
      inc(InputBuffer);
      inc(OutputBuffer);
     end;
    end;
   end;
{$endif}
  end;
 end;
{$endif}
end;

procedure SynthProcessChannelFilterInit(Track:PSynthTrack;Filter:PSynthInstrumentFilter;FilterData:PSynthInstrumentFilterData);
begin
{$ifdef BR808CHANNELFILTER}
 FillChar(FilterData^,sizeof(TSynthInstrumentFilterData),#0);
{$endif}
end;

procedure SynthProcessVoiceDistortionInit(Track:PSynthTrack;VoiceDistortion:PSynthInstrumentDistortion;VoiceDistortionData:PSynthInstrumentDistortionData);
begin
{$ifdef BR808VOICEDISTORTION}
{$endif}
end;

procedure SynthProcessVoiceDistortionKeyOn(Track:PSynthTrack;VoiceDistortion:PSynthInstrumentDistortion;VoiceDistortionData:PSynthInstrumentDistortionData;Carry,LegatoPedal:boolean);
begin
{$ifdef BR808VOICEDISTORTION}
 if not (Carry and (VoiceDistortion^.Carry or LegatoPedal)) then begin
  FillChar(VoiceDistortionData^,sizeof(TSynthInstrumentDistortionData),#0);
  VoiceDistortionData^.Phases[0]:=1;
  VoiceDistortionData^.Phases[1]:=1;
 end;
{$endif}
end;

procedure SynthProcessVoiceDistortionKeyOff(Track:PSynthTrack;VoiceDistortionData:PSynthInstrumentDistortionData);
begin
{$ifdef BR808VOICEDISTORTION}
{$endif}
end;

procedure SynthProcessDistortion(Track:PSynthTrack;Distortion:PSynthInstrumentDistortion;DistortionData:PSynthInstrumentDistortionData;Buffer:PSynthBufferSample;GainBuffer,DistBuffer,RateBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808VOICEDISTORTION}
const fC1:single=1;
var Counter:longint;
    G,D,R,P,AmplifyValue,ClipAtValue,t,tv,i0,i1,o0,o1,m,cf,sf:single;
{$endif}
begin
{$ifdef BR808VOICEDISTORTION}
 case Distortion^.Mode of
  dmSOFT:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthSoftDistortion(Buffer^.Left,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    Buffer^.Right:=SynthSoftDistortion(Buffer^.Right,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmHARD:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthHardDistortion(Buffer^.Left,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    Buffer^.Right:=SynthHardDistortion(Buffer^.Right,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmFASTWAVESHAPER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthFastWaveshapeDistortion(Buffer^.Left,sqr(G*GainBuffer^)*((sqr(D*DistBuffer^)*127)+1));
    Buffer^.Right:=SynthFastWaveshapeDistortion(Buffer^.Right,sqr(G*GainBuffer^)*((sqr(D*DistBuffer^)*127)+1));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmWAVESHAPER1:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthWaveshape1Distortion(Buffer^.Left,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    Buffer^.Right:=SynthWaveshape1Distortion(Buffer^.Right,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmWAVESHAPER2:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthWaveshape2Distortion(Buffer^.Left,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    Buffer^.Right:=SynthWaveshape2Distortion(Buffer^.Right,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmGLOUBIBOULGA:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthGloubiBoulgaDistortion(Buffer^.Left,sqr(G*GainBuffer^)*((sqr(D*DistBuffer^)*127)+1));
    Buffer^.Right:=SynthGloubiBoulgaDistortion(Buffer^.Right,sqr(G*GainBuffer^)*((sqr(D*DistBuffer^)*127)+1));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmFOLDBACK:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthFoldBackDistortion(Buffer^.Left,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    Buffer^.Right:=SynthFoldBackDistortion(Buffer^.Right,sqr(G*GainBuffer^),(sqr(D*DistBuffer^)*127)+1);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSATURATION:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthSoftSaturation(Buffer^.Left,sqr(G*GainBuffer^),D*DistBuffer^);
    Buffer^.Right:=SynthSoftSaturation(Buffer^.Right,sqr(G*GainBuffer^),D*DistBuffer^);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmDECIMATORCRUSHER:begin
   G:=Distortion^.Gain*fCI255;
   if (Distortion^.Dist shr 2)=31 then begin
    D:=0;
   end else begin
    D:=power(2,Distortion^.Dist*0.125);
   end;
   if Distortion^.Rate=0 then begin
    P:=1;
   end else begin
    P:=power(0.0001*(44100*Track^.InternalSampleRateFactor),Distortion^.Rate*fCI255);
   end;
   for Counter:=1 to Samples do begin
    Buffer^.Left:=SynthDecimate(Buffer^.Left,sqr(G*GainBuffer^),P*RateBuffer^,DistortionData^.Phases[0],DistortionData^.SavedSamples[0],D*DistBuffer^);
    Buffer^.Right:=SynthDecimate(Buffer^.Right,sqr(G*GainBuffer^),P*RateBuffer^,DistortionData^.Phases[1],DistortionData^.SavedSamples[1],D*DistBuffer^);
    inc(GainBuffer);
    inc(DistBuffer);
    inc(RateBuffer);
    inc(Buffer);
   end;
  end;
  dmBITCRUSHER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=power(2.0,(((D*DistBuffer^)*15)+FixDenormalValue)-FixDenormalValue);
    t:=1/ClipAtValue;
    Buffer^.Left:=SoftTRUNC(Buffer^.Left*AmplifyValue*ClipAtValue)*t;
    Buffer^.Right:=SoftTRUNC(Buffer^.Right*AmplifyValue*ClipAtValue)*t;
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmDECIMATOR:begin
   G:=Distortion^.Gain*fCI255;
   if Distortion^.Rate=0 then begin
    P:=1;
   end else begin
    P:=power(0.0001*(44100*Track^.InternalSampleRateFactor),Distortion^.Rate*fCI255);
   end;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    DistortionData^.Phases[0]:=DistortionData^.Phases[0]+(P*RateBuffer^);
    if plongword(@DistortionData^.Phases[0])^>=plongword(@fC1)^ then begin
     DistortionData^.Phases[0]:=DistortionData^.Phases[0]-1.0;
     DistortionData^.SavedSamples[0]:=Buffer^.Left*AmplifyValue;
     DistortionData^.SavedSamples[1]:=Buffer^.Right*AmplifyValue;
    end;
    Buffer^.Left:=DistortionData^.SavedSamples[0];
    Buffer^.Right:=DistortionData^.SavedSamples[1];
    inc(GainBuffer);
    inc(RateBuffer);
    inc(Buffer);
   end;
  end;
  dmOVERDRIVE:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   R:=Distortion^.Rate*fCI255;
   for Counter:=1 to Samples do begin
    i0:=Buffer^.Left;
    if i0<0 then begin
     o0:=-FastSQRT(-i0);
    end else begin
     o0:=FastSQRT(i0);
    end;

    i1:=Buffer^.Right;
    if i1<0 then begin
     o1:=-FastSQRT(-i1);
    end else begin
     o1:=FastSQRT(i1);
    end;

    tv:=2*sin(sqr(D*DistBuffer^)*pi*(22050*Track^.InternalSampleRateFactor));
    t:=2*sin(sqr(R*RateBuffer^)*pi*(22050*Track^.InternalSampleRateFactor));

    DistortionData^.OverdriveLeft:=DistortionData^.OverdriveLeft+(t*(((tv*(o0-i0))+i0)-DistortionData^.OverdriveLeft));
    DistortionData^.OverdriveRight:=DistortionData^.OverdriveRight+(t*(((tv*(o1-i1))+i1)-DistortionData^.OverdriveRight));

    longword(pointer(@DistortionData^.OverdriveLeft)^):=longword(pointer(@DistortionData^.OverdriveLeft)^) and longword($ffffffff+longword(((((longword(pointer(@DistortionData^.OverdriveLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@DistortionData^.OverdriveRight)^):=longword(pointer(@DistortionData^.OverdriveRight)^) and longword($ffffffff+longword(((((longword(pointer(@DistortionData^.OverdriveRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

    AmplifyValue:=sqr(G*GainBuffer^);

    Buffer^.Left:=DistortionData^.OverdriveLeft*AmplifyValue;
    Buffer^.Right:=DistortionData^.OverdriveRight*AmplifyValue;
    inc(GainBuffer);
    inc(DistBuffer);
    inc(RateBuffer);
    inc(Buffer);
   end;
  end;
  dmARCTANGENT:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   R:=Distortion^.Rate*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(power(10.0,(sqr(R*RateBuffer^)*((sqr(D*DistBuffer^)*127)+1))*3.0)-1.0)+0.001;
    t:=1.0/Syntharctan(ClipAtValue);
    Buffer^.Left:=Syntharctan(Buffer^.Left*AmplifyValue*ClipAtValue)*t;
    Buffer^.Right:=Syntharctan(Buffer^.Right*AmplifyValue*ClipAtValue)*t;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(RateBuffer);
    inc(Buffer);
   end;
  end;
  dmASYMMETRIC:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(D*DistBuffer^)*32.0)+0.0001;
    if ClipAtValue<1.0 then begin
     t:=1.0/(sin(ClipAtValue)+0.1);
    end else begin
     t:=1.0/1.1;
    end;
    Buffer^.Left:=sin(Buffer^.Left*AmplifyValue*((0.1+ClipAtValue)-(ClipAtValue*Buffer^.Left*AmplifyValue)))*t;
    Buffer^.Right:=sin(Buffer^.Right*AmplifyValue*((0.1+ClipAtValue)-(ClipAtValue*Buffer^.Right*AmplifyValue)))*t;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmASYMMETRIC2:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*30.0)+0.0001;
    if ClipAtValue<0.3 then begin
     tv:=1/ClipAtValue;
    end else begin
     tv:=1;
    end;
    t:=Buffer^.Left*AmplifyValue*ClipAtValue;
    if (t>-2.0) and (t<1) then begin
     Buffer^.Left:=t*(1.0-t)*(t+2.0)*tv;
    end else begin
     Buffer^.Left:=0.0;
    end;
    t:=Buffer^.Right*AmplifyValue*ClipAtValue;
    if (t>-2.0) and (t<1) then begin
     Buffer^.Right:=t*(1.0-t)*(t+2.0)*tv;
    end else begin
     Buffer^.Right:=0.0;
    end;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmPOWER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*20.0)+0.0001;
    t:=Buffer^.Left*AmplifyValue*ClipAtValue;
    if abs(t)<1.0 then begin
     t:=(t-power(t,3.0))*3.0;
     if ClipAtValue<1.0 then begin
      t:=t/ClipAtValue;
     end;
    end else begin
     t:=0;
    end;
    Buffer^.Left:=t;
    t:=Buffer^.Right*AmplifyValue*ClipAtValue;
    if abs(t)<1.0 then begin
     t:=(t-power(t,3.0))*3.0;
     if ClipAtValue<1.0 then begin
      t:=t/ClipAtValue;
     end;
    end else begin
     t:=0;
    end;
    Buffer^.Right:=t;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmPOWER2:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*20.0)+0.0001;
    tv:=1/ClipAtValue;
    t:=Buffer^.Left*AmplifyValue*ClipAtValue;
    Buffer^.Left:=(t-power(t,3.0))*3.0*tv;
    t:=Buffer^.Right*AmplifyValue*ClipAtValue;
    Buffer^.Right:=(t-power(t,3.0))*3.0*tv;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmPOWER3:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*32.0)+0.0001;
    if ClipAtValue<1.0 then begin
     tv:=1/(ClipAtValue*(1+ClipAtValue)*0.5);
    end else begin
     tv:=1;
    end;
    t:=Buffer^.Left*AmplifyValue*ClipAtValue;
    if (t>-1.0) and (t<1.618034) then begin
     t:=(t*(1.0-t))*tv;
    end else if t>0.0 then begin
     t:=-1.0;
    end else begin
     t:=-2.0;
    end;
    Buffer^.Left:=t;
    t:=Buffer^.Right*AmplifyValue*ClipAtValue;
    if (t>-1.0) and (t<1.618034) then begin
     t:=(t*(1.0-t))*tv;
    end else if t>0.0 then begin
     t:=-1.0;
    end else begin
     t:=-2.0;
    end;
    Buffer^.Right:=t;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSINE:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*32.0)+0.0001;
    if ClipAtValue<1.57 then begin
     tv:=sin(ClipAtValue);
    end else begin
     tv:=1;
    end;
    Buffer^.Left:=sin(Buffer^.Left*AmplifyValue*ClipAtValue)*tv;
    Buffer^.Right:=sin(Buffer^.Right*AmplifyValue*ClipAtValue)*tv;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSINUS:begin
   G:=Distortion^.Gain*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    Buffer^.Left:=sin(pi*Buffer^.Left*AmplifyValue);
    Buffer^.Right:=sin(pi*Buffer^.Right*AmplifyValue);
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(Buffer);
   end;
  end;
  dmQUANTISIZE:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(D*DistBuffer^))+0.000001;
    tv:=AmplifyValue/ClipAtValue;
    Buffer^.Left:=SynthFloor((Buffer^.Left*tv)+0.5)*ClipAtValue;
    Buffer^.Right:=SynthFloor((Buffer^.Right*tv)+0.5)*ClipAtValue;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmZIGZAG:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(sqr(sqr(D*DistBuffer^))*32.0)+0.0001;
    if ClipAtValue<1.0 then begin
     tv:=sin(ClipAtValue);
    end else begin
     tv:=1;
    end;
    Buffer^.Left:=Syntharcsin(sin(Buffer^.Left*AmplifyValue*ClipAtValue))*tv;
    Buffer^.Right:=Syntharcsin(sin(Buffer^.Right*AmplifyValue*ClipAtValue))*tv;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmLIMITER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(power(2.0,-sqr(D*DistBuffer^)*8.0)+FixDenormalValue)-FixDenormalValue;
    tv:=1/ClipAtValue;
    t:=Buffer^.Left*AmplifyValue;
    if abs(t)<ClipAtValue then begin
     Buffer^.Left:=t*tv;
    end else begin
     if t<0.0 then begin
      Buffer^.Left:=-1.0;
     end else begin
      Buffer^.Left:=1.0;
     end;
    end;
    t:=Buffer^.Right*AmplifyValue;
    if abs(t)<ClipAtValue then begin
     Buffer^.Right:=t*tv;
    end else begin
     if t<0.0 then begin
      Buffer^.Right:=-1.0;
     end else begin
      Buffer^.Right:=1.0;
     end;
    end;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmUPPERLIMITER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(power(2.0,-sqr(D*DistBuffer^)*8.0)+FixDenormalValue)-FixDenormalValue;
    t:=Buffer^.Left*AmplifyValue;
    if t<ClipAtValue then begin
     Buffer^.Left:=t;
    end else begin
     Buffer^.Left:=ClipAtValue;
    end;
    t:=Buffer^.Right*AmplifyValue;
    if t<ClipAtValue then begin
     Buffer^.Right:=t;
    end else begin
     Buffer^.Right:=ClipAtValue;
    end;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmLOWERLIMITER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(power(2.0,-sqr(D*DistBuffer^)*8.0)+FixDenormalValue)-FixDenormalValue;
    t:=Buffer^.Left*AmplifyValue;
    if t>-ClipAtValue then begin
     Buffer^.Left:=t;
    end else begin
     Buffer^.Left:=-ClipAtValue;
    end;
    t:=Buffer^.Right*AmplifyValue;
    if t>-ClipAtValue then begin
     Buffer^.Right:=t;
    end else begin
     Buffer^.Right:=-ClipAtValue;
    end;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmINVERSELIMITER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(((power(2.0,(D*DistBuffer^)*6.0)-1.0)/power(2.0,6.0))+FixDenormalValue)-FixDenormalValue;
    t:=Buffer^.Left*AmplifyValue;
    if t>ClipAtValue then begin
     Buffer^.Left:=t-ClipAtValue;
    end else if t<-ClipAtValue then begin
     Buffer^.Left:=ClipAtValue+t;
    end else begin
     Buffer^.Left:=0;
    end;
    t:=Buffer^.Right*AmplifyValue;
    if t>ClipAtValue then begin
     Buffer^.Right:=t-ClipAtValue;
    end else if t<-ClipAtValue then begin
     Buffer^.Right:=ClipAtValue+t;
    end else begin
     Buffer^.Right:=0;
    end;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmCLIP:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=((D*DistBuffer^)+FixDenormalValue)-FixDenormalValue;
    ClipAtValue:=power(5.0,sqr(ClipAtValue))-1.0;
    Buffer^.Left:=(Buffer^.Left*AmplifyValue*(ClipAtValue+0.5)*0.9999)-SynthFloor(0.5+(Buffer^.Left*AmplifyValue*(ClipAtValue+0.5)*0.9999));
    Buffer^.Right:=(Buffer^.Right*AmplifyValue*(ClipAtValue+0.5)*0.9999)-SynthFloor(0.5+(Buffer^.Right*AmplifyValue*(ClipAtValue+0.5)*0.9999));
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSIGMOID:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=((D*DistBuffer^)+FixDenormalValue)-FixDenormalValue;
    ClipAtValue:=(power(ClipAtValue,5.0)*80.0)+0.0001;
    if ClipAtValue>10 then begin
     tv:=2.0;
    end else begin
     tv:=1.0/(0.5-(1.0/(exp(ClipAtValue)+1.0)));
    end;
    t:=Clip(Buffer^.Left*AmplifyValue,-10,10);
    Buffer^.Left:=(0.5-(1.0/(exp(t)+1.0)))*Tv;
    t:=Clip(Buffer^.Right*AmplifyValue,-10,10);
    Buffer^.Right:=(0.5-(1.0/(exp(t)+1.0)))*Tv;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmDIFF:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=((D*DistBuffer^)+FixDenormalValue)-FixDenormalValue;
    tv:=Buffer^.Left*AmplifyValue;
    t:=Buffer^.Right*AmplifyValue;
    Buffer^.Left:=((t-tv)*ClipAtValue)+(tv*(1.0-ClipAtValue));
    Buffer^.Right:=((tv-t)*ClipAtValue)+(t*(1.0-ClipAtValue));
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSTEREOEXPANDER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=((sqr(D*DistBuffer^)*4)+FixDenormalValue)-FixDenormalValue;
    tv:=Buffer^.Left*AmplifyValue;
    t:=Buffer^.Right*AmplifyValue;
    m:=(t+tv)*0.5;
    Buffer^.Left:=m+((tv-m)*ClipAtValue);
    Buffer^.Right:=m+((t-m)*ClipAtValue);
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSTEREOENHANCER:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=((sqr(D*DistBuffer^)*4)+FixDenormalValue)-FixDenormalValue;
    tv:=Buffer^.Left*AmplifyValue;
    t:=Buffer^.Right*AmplifyValue;
    m:=(t+tv)*0.5;
    sf:=(tv-t)*ClipAtValue;
    Buffer^.Left:=m-sf;
    Buffer^.Right:=m+sf;
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
  dmSTEREOFIELDROTATION:begin
   G:=Distortion^.Gain*fCI255;
   D:=Distortion^.Dist*fCI255;
   for Counter:=1 to Samples do begin
    AmplifyValue:=sqr(G*GainBuffer^);
    ClipAtValue:=(((D*DistBuffer^)*pi2)+FixDenormalValue)-FixDenormalValue;
    cf:=cos(ClipAtValue);
    sf:=sin(ClipAtValue);
    tv:=Buffer^.Left*AmplifyValue;
    t:=Buffer^.Right*AmplifyValue;
    Buffer^.Left:=(tv*cf)-(t*sf);
    Buffer^.Right:=(tv*sf)+(t*cf);
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(GainBuffer);
    inc(DistBuffer);
    inc(Buffer);
   end;
  end;
 end;
{$endif}
end;

procedure SynthProcessChannelDistortionInit(Track:PSynthTrack;ChannelDistortion:PSynthInstrumentDistortion;ChannelDistortionData:PSynthInstrumentDistortionData);
begin
{$ifdef BR808CHANNELDISTORTION}
 FillChar(ChannelDistortionData^,sizeof(TSynthInstrumentDistortionData),#0);
 ChannelDistortionData^.Phases[0]:=1;
 ChannelDistortionData^.Phases[1]:=1;
{$endif}
end;

procedure SynthProcessDelayInit(Track:PSynthTrack;Delay:PSynthDelay;DelayData:PSynthDelayData);
begin
{$ifdef BR808DELAY}
 FillChar(DelayData^,sizeof(TSynthDelayData),#0);
{$endif}
end;

procedure SynthProcessDelay(Track:PSynthTrack;Delay:PSynthDelay;DelayData:PSynthDelayData;Buffer,DelayBuffer:PSynthBufferSample;TimeLeftBuffer,FeedBackLeftBuffer,TimeRightBuffer,FeedBackRightBuffer,WetBuffer,DryBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808DELAY}
var Counter,NewIndex:longint;
    FITL,FITR,FTR,FTL,FL,FR,FW,FD,Value,Alpha,FeedbackFactor:single;
{$endif}
begin
{$ifdef BR808DELAY}
 if Delay^.Active and not ((Delay^.TimeLeft=0) and (Delay^.TimeRight=0)) then begin
  if DelayData^.Fine<>Delay^.Fine then begin
   DelayData^.Fine:=Delay^.Fine;
   DelayData^.DelayLeft:=-1;
   DelayData^.DelayRight:=-1;
  end;
  if Delay^.Recursive then begin
   FeedbackFactor:=1;
  end else begin
   FeedbackFactor:=0;
  end;
  DelayData^.IndexLeft:=DelayData^.IndexLeft and Track^.DelayBufferMask;
  DelayData^.IndexRight:=DelayData^.IndexRight and Track^.DelayBufferMask;
  if Delay^.ClockSync then begin
   Value:=Track^.Global.Clock.BPM*Track^.Global.Clock.TPB;
   longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   if abs(Value)<1e-12 then begin
    Value:=1;
   end;
   FITL:=Clip(((60*Track^.InternalSampleRate)/Value)*Delay^.TimeLeft,0,Track^.InternalSampleRate*DelayBufferSeconds);
   FITR:=Clip(((60*Track^.InternalSampleRate)/Value)*Delay^.TimeRight,0,Track^.InternalSampleRate*DelayBufferSeconds);
   FTL:=FITL;
   FTR:=FITR;
   if FTL<1 then begin
    FTL:=1;
   end;
   if FTR<1 then begin
    FTR:=1;
   end;
   if DelayData^.DelayLeft<>FTL then begin
    DelayData^.DelayLeft:=FTL;

    DelayData^.LenLeft:=SoftTRUNC(FTL);

    if Delay^.Fine then begin
     Alpha:=(1.0+DelayData^.LenLeft)-FTL;
     if Alpha<0.5 then begin
      inc(DelayData^.LenLeft);
      Alpha:=Alpha+1;
     end;

     DelayData^.CoefLeft:=(1.0-Alpha)/(1.0+Alpha);
    end else begin
     DelayData^.CoefLeft:=0;
    end;
   end;
   if DelayData^.DelayRight<>FTR then begin
    DelayData^.DelayRight:=FTR;

    DelayData^.LenRight:=SoftTRUNC(FTR);

    if Delay^.Fine then begin
     Alpha:=(1.0+DelayData^.LenRight)-FTR;
     if Alpha<0.5 then begin
      inc(DelayData^.LenRight);
      Alpha:=Alpha+1;
     end;

     DelayData^.CoefRight:=(1.0-Alpha)/(1.0+Alpha);
    end else begin
     DelayData^.CoefRight:=0;
    end;
   end;
   if (FeedBackLeftBuffer=Track^.F1D0Buffer) and (FeedBackRightBuffer=Track^.F1D0Buffer) and (WetBuffer=Track^.F1D0Buffer) and (DryBuffer=Track^.F1D0Buffer) and (TimeLeftBuffer=Track^.ZeroBuffer) and (TimeRightBuffer=Track^.ZeroBuffer) then begin
    FL:=Delay^.FeedBackLeft*fCI128;
    FR:=Delay^.FeedBackRight*fCI128;
    FW:=Delay^.Wet*fCI255;
    FD:=Delay^.Dry*fCI255;
    longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    if Delay^.Fine then begin
     if DelayData^.LenLeft<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.y1Left:=(DelayData^.x1Left+(DelayData^.CoefLeft*Value))-(DelayData^.CoefLeft*DelayData^.y1Left);
       longword(pointer(@DelayData^.y1Left)^):=longword(pointer(@DelayData^.y1Left)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Left:=Value;
       Value:=DelayData^.y1Left*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft].Left:=Buffer^.Left+(Value*FeedbackFactor);
       Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
       longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
      dec(Buffer,Samples);
     end;
     if DelayData^.LenRight<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.y1Right:=(DelayData^.x1Right+(DelayData^.CoefRight*Value))-(DelayData^.CoefRight*DelayData^.y1Right);
       longword(pointer(@DelayData^.y1Right)^):=longword(pointer(@DelayData^.y1Right)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Right:=Value;
       Value:=DelayData^.y1Right*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight].Right:=Buffer^.Right+(Value*FeedbackFactor);
       Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
       longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
     end;
    end else begin
     if DelayData^.LenLeft<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft and Track^.DelayBufferMask].Left:=Buffer^.Left+(Value*FeedbackFactor);
       Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
       longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
      dec(Buffer,Samples);
     end;
     if DelayData^.LenRight<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight and Track^.DelayBufferMask].Right:=Buffer^.Right+(Value*FeedbackFactor);
       Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
       longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
     end;
    end;
   end else begin
    for Counter:=1 to Samples do begin
     if assigned(TimeLeftBuffer) then begin
      FTL:=Clip((TimeLeftBuffer^*Track^.InternalSampleRate)+FTL,0,Track^.InternalSampleRate*DelayBufferSeconds);
      inc(TimeLeftBuffer);
      if DelayData^.DelayLeft<>FTL then begin
       DelayData^.DelayLeft:=FTL;

       DelayData^.LenLeft:=SoftTRUNC(FTL);

       if Delay^.Fine then begin
        Alpha:=(1.0+DelayData^.LenLeft)-FTL;
        if Alpha<0.5 then begin
         inc(DelayData^.LenLeft);
         Alpha:=Alpha+1;
        end;

        DelayData^.CoefLeft:=(1.0-Alpha)/(1.0+Alpha);
       end else begin
        DelayData^.CoefLeft:=0;
       end;
      end;
     end;
     if assigned(TimeRightBuffer) then begin
      FTR:=Clip((TimeRightBuffer^*Track^.InternalSampleRate)+FTR,0,Track^.InternalSampleRate*DelayBufferSeconds);
      inc(TimeRightBuffer);
      if DelayData^.DelayRight<>FTR then begin
       DelayData^.DelayRight:=FTR;

       DelayData^.LenRight:=SoftTRUNC(FTR);

       if Delay^.Fine then begin
        Alpha:=(1.0+DelayData^.LenRight)-FTR;
        if Alpha<0.5 then begin
         inc(DelayData^.LenRight);
         Alpha:=Alpha+1;
        end;

        DelayData^.CoefRight:=(1.0-Alpha)/(1.0+Alpha);
       end else begin
        DelayData^.CoefRight:=0;
       end;
      end;
     end;
     FL:=Delay^.FeedBackLeft*fCI128*FeedBackLeftBuffer^;
     FR:=Delay^.FeedBackRight*fCI128*FeedBackRightBuffer^;
     FW:=Delay^.Wet*fCI255*WetBuffer^;
     FD:=Delay^.Dry*fCI255*DryBuffer^;
     longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     if DelayData^.LenLeft<>0 then begin
      Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      if Delay^.Fine then begin
       DelayData^.y1Left:=(DelayData^.x1Left+(DelayData^.CoefLeft*Value))-(DelayData^.CoefLeft*DelayData^.y1Left);
       longword(pointer(@DelayData^.y1Left)^):=longword(pointer(@DelayData^.y1Left)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Left:=Value;
       Value:=DelayData^.y1Left;
      end;
      Value:=Value*FL;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft].Left:=Buffer^.Left+(Value*FeedbackFactor);
      Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
      longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
     end;
     if DelayData^.LenRight<>0 then begin
      Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      if Delay^.Fine then begin
       DelayData^.y1Right:=(DelayData^.x1Right+(DelayData^.CoefRight*Value))-(DelayData^.CoefRight*DelayData^.y1Right);
       longword(pointer(@DelayData^.y1Right)^):=longword(pointer(@DelayData^.y1Right)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Right:=Value;
       Value:=DelayData^.y1Right;
      end;
      Value:=Value*FR;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight].Right:=Buffer^.Right+(Value*FeedbackFactor);
      Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
      longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
     end;
     inc(Buffer);
     inc(FeedBackLeftBuffer);
     inc(FeedBackRightBuffer);
     inc(WetBuffer);
     inc(DryBuffer);
    end;
   end;
  end else begin
   FITL:=Clip(sqr(Delay^.TimeLeft*fCI255)*Track^.InternalSampleRate*2,0,Track^.InternalSampleRate*2);
   FITR:=Clip(sqr(Delay^.TimeRight*fCI255)*Track^.InternalSampleRate*2,0,Track^.InternalSampleRate*2);
   FTL:=FITL;
   FTR:=FITR;
   if FTL<1 then begin
    FTL:=1;
   end;
   if FTR<1 then begin
    FTR:=1;
   end;
   if DelayData^.DelayLeft<>FTL then begin
    DelayData^.DelayLeft:=FTL;

    DelayData^.LenLeft:=SoftTRUNC(FTL);

    if Delay^.Fine then begin
     Alpha:=(1.0+DelayData^.LenLeft)-FTL;
     if Alpha<0.5 then begin
      inc(DelayData^.LenLeft);
      Alpha:=Alpha+1;
     end;

     DelayData^.CoefLeft:=(1.0-Alpha)/(1.0+Alpha);
    end else begin
     DelayData^.CoefLeft:=0;
    end;
   end;
   if DelayData^.DelayRight<>FTR then begin
    DelayData^.DelayRight:=FTR;

    DelayData^.LenRight:=SoftTRUNC(FTR);

    if Delay^.Fine then begin
     Alpha:=(1.0+DelayData^.LenRight)-FTR;
     if Alpha<0.5 then begin
      inc(DelayData^.LenRight);
      Alpha:=Alpha+1;
     end;

     DelayData^.CoefRight:=(1.0-Alpha)/(1.0+Alpha);
    end else begin
     DelayData^.CoefRight:=0;
    end;
   end;
   if (FeedBackLeftBuffer=Track^.F1D0Buffer) and (FeedBackRightBuffer=Track^.F1D0Buffer) and (WetBuffer=Track^.F1D0Buffer) and (DryBuffer=Track^.F1D0Buffer) and (TimeLeftBuffer=Track^.ZeroBuffer) and (TimeRightBuffer=Track^.ZeroBuffer) then begin
    FL:=Delay^.FeedBackLeft*fCI128;
    FR:=Delay^.FeedBackRight*fCI128;
    FW:=Delay^.Wet*fCI255;
    FD:=Delay^.Dry*fCI255;
    longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    if Delay^.Fine then begin
     if DelayData^.LenLeft<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.y1Left:=(DelayData^.x1Left+(DelayData^.CoefLeft*Value))-(DelayData^.CoefLeft*DelayData^.y1Left);
       longword(pointer(@DelayData^.y1Left)^):=longword(pointer(@DelayData^.y1Left)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Left:=Value;
       Value:=DelayData^.y1Left*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft].Left:=Buffer^.Left+(Value*FeedbackFactor);
       Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
       longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
      dec(Buffer,Samples);
     end;
     if DelayData^.LenRight<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.y1Right:=(DelayData^.x1Right+(DelayData^.CoefRight*Value))-(DelayData^.CoefRight*DelayData^.y1Right);
       longword(pointer(@DelayData^.y1Right)^):=longword(pointer(@DelayData^.y1Right)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Right:=Value;
       Value:=DelayData^.y1Right*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight].Right:=Buffer^.Right+(Value*FeedbackFactor);
       Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
       longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
     end;
    end else begin
     if DelayData^.LenLeft<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft].Left:=Buffer^.Left+(Value*FeedbackFactor);
       Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
       longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
      dec(Buffer,Samples);
     end;
     if DelayData^.LenRight<>0 then begin
      for Counter:=1 to Samples do begin
       Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight].Right:=Buffer^.Right+(Value*FeedbackFactor);
       Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
       longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
       inc(Buffer);
      end;
     end;
    end;
   end else begin
    for Counter:=1 to Samples do begin
     if assigned(TimeLeftBuffer) then begin
      FTL:=Clip((TimeLeftBuffer^*Track^.InternalSampleRate)+FTL,1,Track^.InternalSampleRate);
      inc(TimeLeftBuffer);
      if DelayData^.DelayLeft<>FTL then begin
       DelayData^.DelayLeft:=FTL;

       DelayData^.LenLeft:=SoftTRUNC(FTL);

       if Delay^.Fine then begin
        Alpha:=(1.0+DelayData^.LenLeft)-FTL;
        if Alpha<0.5 then begin
         inc(DelayData^.LenLeft);
         Alpha:=Alpha+1;
        end;

        DelayData^.CoefLeft:=(1.0-Alpha)/(1.0+Alpha);
       end else begin
        DelayData^.CoefLeft:=0;
       end;
      end;
     end;
     if assigned(TimeRightBuffer) then begin
      FTR:=Clip((TimeRightBuffer^*Track^.InternalSampleRate)+FTR,1,Track^.InternalSampleRate);
      inc(TimeRightBuffer);
      if DelayData^.DelayRight<>FTR then begin
       DelayData^.DelayRight:=FTR;

       DelayData^.LenRight:=SoftTRUNC(FTR);

       if Delay^.Fine then begin
        Alpha:=(1.0+DelayData^.LenRight)-FTR;
        if Alpha<0.5 then begin
         inc(DelayData^.LenRight);
         Alpha:=Alpha+1;
        end;

        DelayData^.CoefRight:=(1.0-Alpha)/(1.0+Alpha);
       end else begin
        DelayData^.CoefRight:=0;
       end;
      end;
     end;
     FL:=Delay^.FeedBackLeft*fCI128*FeedBackLeftBuffer^;
     FR:=Delay^.FeedBackRight*fCI128*FeedBackRightBuffer^;
     FW:=Delay^.Wet*fCI255*WetBuffer^;
     FD:=Delay^.Dry*fCI255*DryBuffer^;
     longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     if DelayData^.LenLeft<>0 then begin
      Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexLeft-DelayData^.LenLeft) and Track^.DelayBufferMask].Left;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      if Delay^.Fine then begin
       DelayData^.y1Left:=(DelayData^.x1Left+(DelayData^.CoefLeft*Value))-(DelayData^.CoefLeft*DelayData^.y1Left);
       longword(pointer(@DelayData^.y1Left)^):=longword(pointer(@DelayData^.y1Left)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Left:=Value;
       Value:=DelayData^.y1Left;
      end;
      Value:=Value*FL;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexLeft].Left:=Buffer^.Left+(Value*FeedbackFactor);
      Buffer^.Left:=(Buffer^.Left*FD)+(Value*FW);
      longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      DelayData^.IndexLeft:=(DelayData^.IndexLeft+1) and Track^.DelayBufferMask;
     end;
     if DelayData^.LenRight<>0 then begin
      Value:=PSynthBufferSamples(DelayBuffer)^[(DelayData^.IndexRight-DelayData^.LenRight) and Track^.DelayBufferMask].Right;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      if Delay^.Fine then begin
       DelayData^.y1Right:=(DelayData^.x1Right+(DelayData^.CoefRight*Value))-(DelayData^.CoefRight*DelayData^.y1Right);
       longword(pointer(@DelayData^.y1Right)^):=longword(pointer(@DelayData^.y1Right)^) and longword($ffffffff+longword(((((longword(pointer(@DelayData^.y1Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       DelayData^.x1Right:=Value;
       Value:=DelayData^.y1Right;
      end;
      Value:=Value*FR;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      PSynthBufferSamples(DelayBuffer)^[DelayData^.IndexRight].Right:=Buffer^.Right+(Value*FeedbackFactor);
      Buffer^.Right:=(Buffer^.Right*FD)+(Value*FW);
      longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      DelayData^.IndexRight:=(DelayData^.IndexRight+1) and Track^.DelayBufferMask;
     end;
     inc(Buffer);
     inc(FeedBackLeftBuffer);
     inc(FeedBackRightBuffer);
     inc(WetBuffer);
     inc(DryBuffer);
    end;
   end;
  end;
 end;
{$endif}
end;

procedure SynthProcessChorusFlangerInit(Track:PSynthTrack;ChorusFlanger:PSynthChorusFlanger;ChorusFlangerData:PSynthChorusFlangerData);
begin
{$ifdef BR808CHORUSFLANGER}
 FillChar(ChorusFlangerData^,sizeof(TSynthChorusFlangerData),#0);
{$endif}
end;

procedure SynthProcessChorusFlangerKeyOn(Track:PSynthTrack;ChorusFlanger:PSynthChorusFlanger;ChorusFlangerData:PSynthChorusFlangerData;Carry,LegatoPedal:boolean;LFOPhaseLeftBuffer,LFOPhaseRightBuffer:PSynthFloatValue);
begin
{$ifdef BR808CHORUSFLANGER}
 if not (Carry and (ChorusFlanger^.Carry or LegatoPedal)) then begin
  ChorusFlangerData^.LFOPhaseLeft:=ChorusFlanger^.LFOPhaseLeft*fCI256;
  ChorusFlangerData^.LFOPhaseRight:=ChorusFlanger^.LFOPhaseRight*fCI256;
  if assigned(LFOPhaseLeftBuffer) then begin
   ChorusFlangerData^.LFOPhaseLeft:=ChorusFlangerData^.LFOPhaseLeft*LFOPhaseLeftBuffer^;
  end;
  if assigned(LFOPhaseRightBuffer) then begin
   ChorusFlangerData^.LFOPhaseRight:=ChorusFlangerData^.LFOPhaseRight*LFOPhaseRightBuffer^;
  end;
 end;
{$endif}
end;

procedure SynthProcessChorusFlanger(Track:PSynthTrack;ChorusFlanger:PSynthChorusFlanger;ChorusFlangerData:PSynthChorusFlangerData;Buffer,ChorusFlangerBuffer:PSynthBufferSample;TimeLeftBuffer,FeedBackLeftBuffer,TimeRightBuffer,FeedBackRightBuffer,LFORateLeftBuffer,LFODepthLeftBuffer,LFORateRightBuffer,LFODepthRightBuffer,WetBuffer,DryBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808CHORUSFLANGER}
var Counter,TL,TR,NewIndex,possubsamples,possamples,ic,j,k,h,icm,icc,c,b:longint;
    FTL,FTR,FL,FR,FW,FD,Value,LFOPhaseIncrementLeft,LFOPhaseIncrementRight,
    LFODepthLeft,LFODepthRight,LFORateLeftFactor,LFODepthLeftFactor,
    LFORateRightFactor,LFODepthRightFactor,VolumeFactor,v,OutValue,pf:single;
    OutSampleEx:TSynthBufferSample;
{$endif}
begin
{$ifdef BR808CHORUSFLANGER}
 if ChorusFlanger^.Active and not ((ChorusFlanger^.TimeLeft=0) and (ChorusFlanger^.TimeRight=0)) then begin
  FTL:=Clip(sqr(ChorusFlanger^.TimeLeft*fCI255)*Track^.InternalSampleRate,0,Track^.InternalSampleRate);
  FTR:=Clip(sqr(ChorusFlanger^.TimeRight*fCI255)*Track^.InternalSampleRate,0,Track^.InternalSampleRate);
  TL:=SoftTRUNC(FTL);
  TR:=SoftTRUNC(FTR);
  LFOPhaseIncrementLeft:=(power(((ChorusFlanger^.LFORateLeft*fCI255)*0.99)+0.01,1.5)*100)*Track^.InternalSampleRateFactor;
  LFOPhaseIncrementRight:=(power(((ChorusFlanger^.LFORateRight*fCI255)*0.99)+0.01,1.5)*100)*Track^.InternalSampleRateFactor;
  longword(pointer(@LFOPhaseIncrementLeft)^):=longword(pointer(@LFOPhaseIncrementLeft)^) and longword($ffffffff+longword(((((longword(pointer(@LFOPhaseIncrementLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  longword(pointer(@LFOPhaseIncrementRight)^):=longword(pointer(@LFOPhaseIncrementRight)^) and longword($ffffffff+longword(((((longword(pointer(@LFOPhaseIncrementRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  LFODepthLeft:=ChorusFlanger^.LFODepthLeft*fCI255;
  LFODepthRight:=ChorusFlanger^.LFODepthRight*fCI255;
  longword(pointer(@LFODepthLeft)^):=longword(pointer(@LFODepthLeft)^) and longword($ffffffff+longword(((((longword(pointer(@LFODepthLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  longword(pointer(@LFODepthRight)^):=longword(pointer(@LFODepthRight)^) and longword($ffffffff+longword(((((longword(pointer(@LFODepthRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  ic:=3*Track^.ChorusSamples*CHORUS_INTERPOLATION_SUBSAMPLES;
  icm:=Track^.ChorusSamplesMask;
  icc:=Track^.ChorusSamples;
  c:=ChorusFlanger^.Count;
  if c<1 then begin
   c:=1;
  end;
  pf:=1/c;
  if (LFORateLeftBuffer=Track^.F1D0Buffer) and (LFODepthLeftBuffer=Track^.F1D0Buffer) and (LFORateRightBuffer=Track^.F1D0Buffer) and (LFODepthRightBuffer=Track^.F1D0Buffer) and (FeedBackLeftBuffer=Track^.F1D0Buffer) and (FeedBackRightBuffer=Track^.F1D0Buffer) and (WetBuffer=Track^.F1D0Buffer) and (DryBuffer=Track^.F1D0Buffer) and (TimeLeftBuffer=Track^.ZeroBuffer) and (TimeRightBuffer=Track^.ZeroBuffer) then begin
   FL:=ChorusFlanger^.FeedBackLeft*fCI128;
   FR:=ChorusFlanger^.FeedBackRight*fCI128;
   FW:=ChorusFlanger^.Wet*fCI255;
   FD:=ChorusFlanger^.Dry*fCI255;
   longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   if ChorusFlanger^.Fine then begin
    if TL<>0 then begin
     for Counter:=1 to Samples do begin
      OutValue:=0;
      for j:=0 to c-1 do begin
       b:=j*icc;
       v:=TL*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseLeft+(j*pf)))*LFODepthLeft)));
       possubsamples:=(CHORUS_INTERPOLATION_SUBSAMPLES*ChorusFlangerData^.IndexLeft)-(SoftTRUNC((v*CHORUS_INTERPOLATION_SUBSAMPLES)+0.5)-ic);
       possamples:=possubsamples div CHORUS_INTERPOLATION_SUBSAMPLES;
       possubsamples:=possubsamples and CHORUS_INTERPOLATION_SUBSAMPLES_MASK;
       Value:=0;
       for k:=0 to CHORUS_INTERPOLATION_SAMPLES-1 do begin
        Value:=Value+(PSynthBufferSamples(ChorusFlangerBuffer)^[b+(possamples and icm)].Left*Track^.ChorusSINCTable[k,possubsamples]);
        dec(possamples);
       end;
       Value:=Value*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       OutValue:=OutValue+Value;
       PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left:=Buffer^.Left+Value;
       longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      end;
      ChorusFlangerData^.IndexLeft:=(ChorusFlangerData^.IndexLeft+1) and icm;
      Buffer^.Left:=(Buffer^.Left*FD)+(OutValue*FW);
      longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      ChorusFlangerData^.LFOPhaseLeft:=frac(ChorusFlangerData^.LFOPhaseLeft+LFOPhaseIncrementLeft);
      longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(Buffer);
     end;
     dec(Buffer,Samples);
    end;
    if TR<>0 then begin
     for Counter:=1 to Samples do begin
      OutValue:=0;
      for j:=0 to c-1 do begin
       b:=j*icc;
       v:=TR*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseRight+(j*pf)))*LFODepthRight)));
       possubsamples:=(CHORUS_INTERPOLATION_SUBSAMPLES*ChorusFlangerData^.IndexRight)-(SoftTRUNC((v*CHORUS_INTERPOLATION_SUBSAMPLES)+0.5)-ic);
       possamples:=possubsamples div CHORUS_INTERPOLATION_SUBSAMPLES;
       possubsamples:=possubsamples and CHORUS_INTERPOLATION_SUBSAMPLES_MASK;
       Value:=0;
       for k:=0 to CHORUS_INTERPOLATION_SAMPLES-1 do begin
        Value:=Value+(PSynthBufferSamples(ChorusFlangerBuffer)^[b+(possamples and icm)].Right*Track^.ChorusSINCTable[k,possubsamples]);
        dec(possamples);
       end;
       Value:=Value*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       OutValue:=OutValue+Value;
       PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right:=Buffer^.Right+Value;
       longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      end;
      ChorusFlangerData^.IndexRight:=(ChorusFlangerData^.IndexRight+1) and icm;
      Buffer^.Right:=(Buffer^.Right*FD)+(OutValue*FW);
      longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      ChorusFlangerData^.LFOPhaseRight:=frac(ChorusFlangerData^.LFOPhaseRight+LFOPhaseIncrementRight);
      longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(Buffer);
     end;
    end;
   end else begin
    if TL<>0 then begin
     for Counter:=1 to Samples do begin
      OutValue:=0;
      for j:=0 to c-1 do begin
       b:=j*icc;
       v:=TL*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseLeft+(j*pf)))*LFODepthLeft)));
       Value:=PSynthBufferSamples(ChorusFlangerBuffer)^[b+(SoftTRUNC(ChorusFlangerData^.IndexLeft-v) and icm)].Left*FL;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       OutValue:=OutValue+Value;
       PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left:=Buffer^.Left+Value;
       longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      end;
      ChorusFlangerData^.IndexLeft:=(ChorusFlangerData^.IndexLeft+1) and icm;
      Buffer^.Left:=(Buffer^.Left*FD)+(OutValue*FW);
      longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      ChorusFlangerData^.LFOPhaseLeft:=frac(ChorusFlangerData^.LFOPhaseLeft+LFOPhaseIncrementLeft);
      longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(Buffer);
     end;
     dec(Buffer,Samples);
    end;
    if TR<>0 then begin
     for Counter:=1 to Samples do begin
      OutValue:=0;
      for j:=0 to c-1 do begin
       b:=j*icc;
       v:=TR*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseRight+(j*pf)))*LFODepthRight)));
       Value:=PSynthBufferSamples(ChorusFlangerBuffer)^[b+(SoftTRUNC(ChorusFlangerData^.IndexRight-v) and icm)].Left*FR;
       longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
       OutValue:=OutValue+Value;
       PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right:=Buffer^.Right+Value;
       longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      end;
      ChorusFlangerData^.IndexRight:=(ChorusFlangerData^.IndexRight+1) and icm;
      Buffer^.Right:=(Buffer^.Right*FD)+(OutValue*FW);
      longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      ChorusFlangerData^.LFOPhaseRight:=frac(ChorusFlangerData^.LFOPhaseRight+LFOPhaseIncrementRight);
      longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(Buffer);
     end;
    end;
   end;
  end else begin
   for Counter:=1 to Samples do begin
    if assigned(TimeLeftBuffer) then begin
     TL:=SoftTRUNC(Clip((TimeLeftBuffer^*Track^.InternalSampleRate)+FTL,0,Track^.InternalSampleRate));
     inc(TimeLeftBuffer);
    end;
    if assigned(TimeRightBuffer) then begin
     TR:=SoftTRUNC(Clip((TimeRightBuffer^*Track^.InternalSampleRate)+FTR,0,Track^.InternalSampleRate));
     inc(TimeRightBuffer);
    end;
    FL:=ChorusFlanger^.FeedBackLeft*fCI128*FeedBackLeftBuffer^;
    FR:=ChorusFlanger^.FeedBackRight*fCI128*FeedBackRightBuffer^;
    LFORateLeftFactor:=LFORateLeftBuffer^;
    LFODepthLeftFactor:=LFODepthLeftBuffer^;
    LFORateRightFactor:=LFORateRightBuffer^;
    LFODepthRightFactor:=LFODepthRightBuffer^;
    FW:=ChorusFlanger^.Wet*fCI255*WetBuffer^;
    FD:=ChorusFlanger^.Dry*fCI255*DryBuffer^;
    longword(pointer(@FL)^):=longword(pointer(@FL)^) and longword($ffffffff+longword(((((longword(pointer(@FL)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FR)^):=longword(pointer(@FR)^) and longword($ffffffff+longword(((((longword(pointer(@FR)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@LFORateLeftFactor)^):=longword(pointer(@LFORateLeftFactor)^) and longword($ffffffff+longword(((((longword(pointer(@LFORateLeftFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@LFODepthLeftFactor)^):=longword(pointer(@LFODepthLeftFactor)^) and longword($ffffffff+longword(((((longword(pointer(@LFODepthLeftFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@LFORateRightFactor)^):=longword(pointer(@LFORateRightFactor)^) and longword($ffffffff+longword(((((longword(pointer(@LFORateRightFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@LFODepthRightFactor)^):=longword(pointer(@LFODepthRightFactor)^) and longword($ffffffff+longword(((((longword(pointer(@LFODepthRightFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FW)^):=longword(pointer(@FW)^) and longword($ffffffff+longword(((((longword(pointer(@FW)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FD)^):=longword(pointer(@FD)^) and longword($ffffffff+longword(((((longword(pointer(@FD)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    if TL<>0 then begin
     OutValue:=0;
     for j:=0 to c-1 do begin
      b:=j*icc;
      v:=TL*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseLeft+(j*pf)))*(LFODepthLeft*LFODepthLeftFactor))));
      if ChorusFlanger^.Fine then begin
       possubsamples:=(CHORUS_INTERPOLATION_SUBSAMPLES*ChorusFlangerData^.IndexLeft)-(SoftTRUNC((v*CHORUS_INTERPOLATION_SUBSAMPLES)+0.5)-ic);
       possamples:=possubsamples div CHORUS_INTERPOLATION_SUBSAMPLES;
       possubsamples:=possubsamples and CHORUS_INTERPOLATION_SUBSAMPLES_MASK;
       Value:=0;
       for k:=0 to CHORUS_INTERPOLATION_SAMPLES-1 do begin
        Value:=Value+(PSynthBufferSamples(ChorusFlangerBuffer)^[b+(possamples and icm)].Left*Track^.ChorusSINCTable[k,possubsamples]);
        dec(possamples);
       end;
      end else begin
       Value:=PSynthBufferSamples(ChorusFlangerBuffer)^[b+(SoftTRUNC(ChorusFlangerData^.IndexLeft-v) and icm)].Left;
      end;
      Value:=Value*FL;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      OutValue:=OutValue+Value;
      PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left:=Buffer^.Left+Value;
      longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexLeft and icm)].Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     end;
     ChorusFlangerData^.IndexLeft:=(ChorusFlangerData^.IndexLeft+1) and icm;
     Buffer^.Left:=(Buffer^.Left*FD)+(OutValue*FW);
     longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    end;
    if TR<>0 then begin
     OutValue:=0;
     for j:=0 to c-1 do begin
      b:=j*icc;
      v:=TR*(1+((sin(2*PI*frac(ChorusFlangerData^.LFOPhaseRight+(j*pf)))*(LFODepthRight*LFODepthRightFactor))));
      if ChorusFlanger^.Fine then begin
       possubsamples:=(CHORUS_INTERPOLATION_SUBSAMPLES*ChorusFlangerData^.IndexRight)-(SoftTRUNC((v*CHORUS_INTERPOLATION_SUBSAMPLES)+0.5)-ic);
       possamples:=possubsamples div CHORUS_INTERPOLATION_SUBSAMPLES;
       possubsamples:=possubsamples and CHORUS_INTERPOLATION_SUBSAMPLES_MASK;
       Value:=0;
       for k:=0 to CHORUS_INTERPOLATION_SAMPLES-1 do begin
        Value:=Value+(PSynthBufferSamples(ChorusFlangerBuffer)^[b+(possamples and icm)].Right*Track^.ChorusSINCTable[k,possubsamples]);
        dec(possamples);
       end;
      end else begin
       Value:=PSynthBufferSamples(ChorusFlangerBuffer)^[b+(SoftTRUNC(ChorusFlangerData^.IndexRight-v) and icm)].Left;
      end;
      Value:=Value*FR;
      longword(pointer(@Value)^):=longword(pointer(@Value)^) and longword($ffffffff+longword(((((longword(pointer(@Value)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      OutValue:=OutValue+Value;
      PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right:=Buffer^.Right+Value;
      longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^):=longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and longword($ffffffff+longword(((((longword(pointer(@PSynthBufferSamples(ChorusFlangerBuffer)^[b+(ChorusFlangerData^.IndexRight and icm)].Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     end;
     ChorusFlangerData^.IndexRight:=(ChorusFlangerData^.IndexRight+1) and icm;
     Buffer^.Right:=(Buffer^.Right*FD)+(OutValue*FW);
     longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    end;
    ChorusFlangerData^.LFOPhaseLeft:=frac(ChorusFlangerData^.LFOPhaseLeft+(LFOPhaseIncrementLeft*LFORateLeftFactor));
    ChorusFlangerData^.LFOPhaseRight:=frac(ChorusFlangerData^.LFOPhaseRight+(LFOPhaseIncrementRight*LFORateRightFactor));
    longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^):=longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and longword($ffffffff+longword(((((longword(pointer(@ChorusFlangerData^.LFOPhaseRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(Buffer);
    inc(FeedBackLeftBuffer);
    inc(FeedBackRightBuffer);
    inc(LFORateLeftBuffer);
    inc(LFODepthLeftBuffer);
    inc(LFORateRightBuffer);
    inc(LFODepthRightBuffer);
    inc(WetBuffer);
    inc(DryBuffer);
   end;
  end;
 end;
{$endif}
end;

procedure SynthProcessEndFilter(Track:PSynthTrack;EndFilter:PSynthEndFilter;EndFilterData:PSynthEndFilterData;Buffer:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808ENDFILTER}
var Counter:longint;
    LowCut,HighCut:single;
{$endif}
begin
{$ifdef BR808ENDFILTER}
 if EndFilter^.Active then begin
  LowCut:=Clip(sin(sqr(EndFilter^.LowCut*fCI127)*44100*Track^.InternalSampleRateFactor*pi*0.5),0.0,1.0);
  HighCut:=Clip(sin(sqr(1-(EndFilter^.HighCut*fCI127))*44100*Track^.InternalSampleRateFactor*pi*0.5),0.0,1.0);
  longword(pointer(@LowCut)^):=longword(pointer(@LowCut)^) and longword($ffffffff+longword(((((longword(pointer(@LowCut)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  longword(pointer(@HighCut)^):=longword(pointer(@HighCut)^) and longword($ffffffff+longword(((((longword(pointer(@HighCut)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  for Counter:=1 to Samples do begin
   with EndFilterData^ do begin
    FDL[1]:=FDL[1]+(HighCut*(Buffer^.Left-FDL[1]));
    FDL[2]:=FDL[2]+(HighCut*(FDL[1]-FDL[2]));
    FDL[3]:=FDL[3]+(LowCut*(FDL[2]-FDL[3]));
    FDL[4]:=FDL[4]+(LowCut*(FDL[3]-FDL[4]));
    longword(pointer(@FDL[1])^):=longword(pointer(@FDL[1])^) and longword($ffffffff+longword(((((longword(pointer(@FDL[1])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDL[2])^):=longword(pointer(@FDL[2])^) and longword($ffffffff+longword(((((longword(pointer(@FDL[2])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDL[3])^):=longword(pointer(@FDL[3])^) and longword($ffffffff+longword(((((longword(pointer(@FDL[3])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDL[4])^):=longword(pointer(@FDL[4])^) and longword($ffffffff+longword(((((longword(pointer(@FDL[4])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    Buffer^.Left:=FDL[2]-FDL[4];
    longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    FDR[1]:=FDR[1]+(HighCut*(Buffer^.Right-FDR[1]));
    FDR[2]:=FDR[2]+(HighCut*(FDR[1]-FDR[2]));
    FDR[3]:=FDR[3]+(LowCut*(FDR[2]-FDR[3]));
    FDR[4]:=FDR[4]+(LowCut*(FDR[3]-FDR[4]));
    longword(pointer(@FDR[1])^):=longword(pointer(@FDR[1])^) and longword($ffffffff+longword(((((longword(pointer(@FDR[1])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDR[2])^):=longword(pointer(@FDR[2])^) and longword($ffffffff+longword(((((longword(pointer(@FDR[2])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDR[3])^):=longword(pointer(@FDR[3])^) and longword($ffffffff+longword(((((longword(pointer(@FDR[3])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@FDR[4])^):=longword(pointer(@FDR[4])^) and longword($ffffffff+longword(((((longword(pointer(@FDR[4])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    Buffer^.Right:=FDR[2]-FDR[4];
    longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   end;
   inc(Buffer);
  end;
 end;
{$endif}
end;

{$ifdef BR808COMPRESSOR}
type TSynthCompressorWindowProc=procedure(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}

procedure SynthCompressorWindowMonoEnvFollowPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:single;
begin
 Sample:=(Buffer^.Left+Buffer^.Right)*0.5;
 plongword(@Sample)^:=plongword(@Sample)^ and $7fffffff;
 if plongword(@CompressorData^.RMSPeakValueLeft)^<plongword(@Sample)^ then begin
  plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample)^;
 end else begin
  CompressorData^.RMSPeakValueLeft:=CompressorData^.RMSPeakValueLeft+((Sample-CompressorData^.RMSPeakValueLeft)*CompressorData^.WindowCoefFactor);
 end;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowMonoAveragePeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:single;
begin
 Sample:=(Buffer^.Left+Buffer^.Right)*0.5;
 plongword(@Sample)^:=plongword(@Sample)^ and $7fffffff;
 CompressorData^.RMSSumLeft:=(CompressorData^.RMSSumLeft-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left)+Sample;
 CompressorData^.RMSNewSumLeft:=CompressorData^.RMSNewSumLeft+Sample;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample;
 inc(CompressorData^.PeakBufferPosition);
 if CompressorData^.PeakBufferPosition>=CompressorData^.WindowSamples then begin
  CompressorData^.PeakBufferPosition:=0;
  CompressorData^.RMSSumLeft:=CompressorData^.RMSNewSumLeft;
  CompressorData^.RMSNewSumLeft:=0;
 end;
 CompressorData^.RMSPeakValueLeft:=CompressorData^.RMSSumLeft*CompressorData^.InvWindowSamples;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowMonoMinimumPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:single;
    Counter:longint;
begin
 Sample:=(Buffer^.Left+Buffer^.Right)*0.5;
 plongword(@Sample)^:=plongword(@Sample)^ and $7fffffff;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample;
 CompressorData^.RMSPeakValueLeft:=Sample;
 for Counter:=1 to CompressorData^.WindowSamples do begin
  Sample:=CompressorData^.PeakBuffer^[((CompressorData^.PeakBufferPosition-CompressorData^.WindowSamples)+Counter) and CompressorData^.WindowMask].Left;
  if plongword(@CompressorData^.RMSPeakValueLeft)^>plongword(@Sample)^ then begin
   plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample)^;
  end;
 end;
 CompressorData^.PeakBufferPosition:=(CompressorData^.PeakBufferPosition+1) and CompressorData^.WindowMask;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowMonoMaximumPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:single;
    Counter:longint;
begin
 Sample:=(Buffer^.Left+Buffer^.Right)*0.5;
 plongword(@Sample)^:=plongword(@Sample)^ and $7fffffff;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample;
 CompressorData^.RMSPeakValueLeft:=Sample;
 for Counter:=1 to CompressorData^.WindowSamples do begin
  Sample:=CompressorData^.PeakBuffer^[((CompressorData^.PeakBufferPosition-CompressorData^.WindowSamples)+Counter) and CompressorData^.WindowMask].Left;
  if plongword(@CompressorData^.RMSPeakValueLeft)^<plongword(@Sample)^ then begin
   plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample)^;
  end;
 end;
 CompressorData^.PeakBufferPosition:=(CompressorData^.PeakBufferPosition+1) and CompressorData^.WindowMask;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowMonoLowPassRMS(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
begin
 CompressorData^.RMSSumLeft:=CompressorData^.RMSSumLeft+((sqr((Buffer^.Left+Buffer^.Right)*0.5)-CompressorData^.RMSSumLeft)*CompressorData^.WindowCoefFactor);
 CompressorData^.RMSPeakValueLeft:=FastSQRT(CompressorData^.RMSSumLeft);
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowMonoAverageRMS(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:single;
begin
 Sample:=sqr((Buffer^.Left+Buffer^.Right)*0.5);
 CompressorData^.RMSSumLeft:=(CompressorData^.RMSSumLeft-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left)+Sample;
 CompressorData^.RMSNewSumLeft:=CompressorData^.RMSNewSumLeft+Sample;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample;
 inc(CompressorData^.PeakBufferPosition);
 if CompressorData^.PeakBufferPosition>=CompressorData^.WindowSamples then begin
  CompressorData^.PeakBufferPosition:=0;
  CompressorData^.RMSSumLeft:=CompressorData^.RMSNewSumLeft;
  CompressorData^.RMSNewSumLeft:=0;
 end;
 CompressorData^.RMSPeakValueLeft:=FastSQRT(CompressorData^.RMSSumLeft*CompressorData^.InvWindowSamples);
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^);
end;

procedure SynthCompressorWindowStereoEnvFollowPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:TSynthBufferSample;
begin
 plongword(@Sample.Left)^:=plongword(@Buffer^.Left)^ and $7fffffff;
 plongword(@Sample.Right)^:=plongword(@Buffer^.Right)^ and $7fffffff;
 if plongword(@CompressorData^.RMSPeakValueLeft)^<plongword(@Sample.Left)^ then begin
  plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample.Left)^;
 end else begin
  CompressorData^.RMSPeakValueLeft:=CompressorData^.RMSPeakValueLeft+((Sample.Left-CompressorData^.RMSPeakValueLeft)*CompressorData^.WindowCoefFactor);
 end;
 if plongword(@CompressorData^.RMSPeakValueRight)^<plongword(@Sample.Right)^ then begin
  plongword(@CompressorData^.RMSPeakValueRight)^:=plongword(@Sample.Right)^;
 end else begin
  CompressorData^.RMSPeakValueRight:=CompressorData^.RMSPeakValueRight+((Sample.Right-CompressorData^.RMSPeakValueRight)*CompressorData^.WindowCoefFactor);
 end;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthCompressorWindowStereoAveragePeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:TSynthBufferSample;
begin
 plongword(@Sample.Left)^:=plongword(@Buffer^.Left)^ and $7fffffff;
 plongword(@Sample.Right)^:=plongword(@Buffer^.Right)^ and $7fffffff;
 CompressorData^.RMSSumLeft:=(CompressorData^.RMSSumLeft-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left)+Sample.Left;
 CompressorData^.RMSNewSumLeft:=CompressorData^.RMSNewSumLeft+Sample.Left;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample.Left;
 CompressorData^.RMSSumRight:=(CompressorData^.RMSSumRight-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Right)+Sample.Right;
 CompressorData^.RMSNewSumRight:=CompressorData^.RMSNewSumRight+Sample.Right;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Right:=Sample.Right;
 inc(CompressorData^.PeakBufferPosition);
 if CompressorData^.PeakBufferPosition>=CompressorData^.WindowSamples then begin
  CompressorData^.PeakBufferPosition:=0;
  CompressorData^.RMSSumLeft:=CompressorData^.RMSNewSumLeft;
  CompressorData^.RMSSumRight:=CompressorData^.RMSNewSumRight;
  CompressorData^.RMSNewSumLeft:=0;
  CompressorData^.RMSNewSumRight:=0;
 end;
 CompressorData^.RMSPeakValueLeft:=CompressorData^.RMSSumLeft*CompressorData^.InvWindowSamples;
 CompressorData^.RMSPeakValueRight:=CompressorData^.RMSSumRight*CompressorData^.InvWindowSamples;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthCompressorWindowStereoMinimumPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:TSynthBufferSample;
    Counter:longint;
begin
 plongword(@Sample.Left)^:=plongword(@Buffer^.Left)^ and $7fffffff;
 plongword(@Sample.Right)^:=plongword(@Buffer^.Right)^ and $7fffffff;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition]:=Sample;
 CompressorData^.RMSPeakValueLeft:=Sample.Left;
 CompressorData^.RMSPeakValueRight:=Sample.Right;
 for Counter:=1 to CompressorData^.WindowSamples do begin
  Sample:=CompressorData^.PeakBuffer^[((CompressorData^.PeakBufferPosition-CompressorData^.WindowSamples)+Counter) and CompressorData^.WindowMask];
  if plongword(@CompressorData^.RMSPeakValueLeft)^>plongword(@Sample.Left)^ then begin
   plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample.Left)^;
  end;
  if plongword(@CompressorData^.RMSPeakValueRight)^>plongword(@Sample.Right)^ then begin
   plongword(@CompressorData^.RMSPeakValueRight)^:=plongword(@Sample.Right)^;
  end;
 end;
 CompressorData^.PeakBufferPosition:=(CompressorData^.PeakBufferPosition+1) and CompressorData^.WindowMask;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthCompressorWindowStereoMaximumPeak(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:TSynthBufferSample;
    Counter:longint;
begin
 plongword(@Sample.Left)^:=plongword(@Buffer^.Left)^ and $7fffffff;
 plongword(@Sample.Right)^:=plongword(@Buffer^.Right)^ and $7fffffff;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition]:=Sample;
 CompressorData^.RMSPeakValueLeft:=Sample.Left;
 CompressorData^.RMSPeakValueRight:=Sample.Right;
 for Counter:=1 to CompressorData^.WindowSamples do begin
  Sample:=CompressorData^.PeakBuffer^[((CompressorData^.PeakBufferPosition-CompressorData^.WindowSamples)+Counter) and CompressorData^.WindowMask];
  if plongword(@CompressorData^.RMSPeakValueLeft)^<plongword(@Sample.Left)^ then begin
   plongword(@CompressorData^.RMSPeakValueLeft)^:=plongword(@Sample.Left)^;
  end;
  if plongword(@CompressorData^.RMSPeakValueRight)^<plongword(@Sample.Right)^ then begin
   plongword(@CompressorData^.RMSPeakValueRight)^:=plongword(@Sample.Right)^;
  end;
 end;
 CompressorData^.PeakBufferPosition:=(CompressorData^.PeakBufferPosition+1) and CompressorData^.WindowMask;
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthCompressorWindowStereoLowPassRMS(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
begin
 CompressorData^.RMSSumLeft:=CompressorData^.RMSSumLeft+((sqr(Buffer^.Left)-CompressorData^.RMSSumLeft)*CompressorData^.WindowCoefFactor);
 CompressorData^.RMSSumRight:=CompressorData^.RMSSumRight+((sqr(Buffer^.Right)-CompressorData^.RMSSumRight)*CompressorData^.WindowCoefFactor);
 CompressorData^.RMSPeakValueLeft:=FastSQRT(CompressorData^.RMSSumLeft);
 CompressorData^.RMSPeakValueRight:=FastSQRT(CompressorData^.RMSSumRight);
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthCompressorWindowStereoAverageRMS(Buffer:PSynthBufferSample;CompressorData:PSynthCompressorData); {$ifdef cpu386}register;{$endif}
var Sample:TSynthBufferSample;
begin
 Sample.Left:=sqr(Buffer^.Left);
 Sample.Right:=sqr(Buffer^.Right);
 CompressorData^.RMSSumLeft:=(CompressorData^.RMSSumLeft-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left)+Sample.Left;
 CompressorData^.RMSNewSumLeft:=CompressorData^.RMSNewSumLeft+Sample.Left;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Left:=Sample.Left;
 CompressorData^.RMSSumRight:=(CompressorData^.RMSSumRight-CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Right)+Sample.Right;
 CompressorData^.RMSNewSumRight:=CompressorData^.RMSNewSumRight+Sample.Right;
 CompressorData^.PeakBuffer^[CompressorData^.PeakBufferPosition].Right:=Sample.Right;
 inc(CompressorData^.PeakBufferPosition);
 if CompressorData^.PeakBufferPosition>=CompressorData^.WindowSamples then begin
  CompressorData^.PeakBufferPosition:=0;
  CompressorData^.RMSSumLeft:=CompressorData^.RMSNewSumLeft;
  CompressorData^.RMSSumRight:=CompressorData^.RMSNewSumRight;
  CompressorData^.RMSNewSumLeft:=0;
  CompressorData^.RMSNewSumRight:=0;
 end;
 CompressorData^.RMSPeakValueLeft:=FastSQRT(CompressorData^.RMSSumLeft*CompressorData^.InvWindowSamples);
 CompressorData^.RMSPeakValueRight:=FastSQRT(CompressorData^.RMSSumRight*CompressorData^.InvWindowSamples);
 longword(pointer(@CompressorData^.RMSPeakValueLeft)^):=longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@CompressorData^.RMSPeakValueRight)^):=longword(pointer(@CompressorData^.RMSPeakValueRight)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.RMSPeakValueRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

var SynthCompressorWindowProcs:array[cmMonoEnvFollowPeak..cmStereoAverageRMS] of TSynthCompressorWindowProc=
     (SynthCompressorWindowMonoEnvFollowPeak,
      SynthCompressorWindowMonoAveragePeak,
      SynthCompressorWindowMonoMinimumPeak,
      SynthCompressorWindowMonoMaximumPeak,
      SynthCompressorWindowMonoLowPassRMS,
      SynthCompressorWindowMonoAverageRMS,
      SynthCompressorWindowStereoEnvFollowPeak,
      SynthCompressorWindowStereoAveragePeak,
      SynthCompressorWindowStereoMinimumPeak,
      SynthCompressorWindowStereoMaximumPeak,
      SynthCompressorWindowStereoLowPassRMS,
      SynthCompressorWindowStereoAverageRMS);
{$endif}

procedure SynthProcessCompressorInit(Track:PSynthTrack;Compressor:PSynthCompressor;CompressorData:PSynthCompressorData);{$ifdef cpu386}register;{$endif}
begin
{$ifdef BR808COMPRESSOR}
 FillChar(CompressorData^,sizeof(TSynthCompressorData),#0);
 CompressorData^.GainLeft:=1.0;
 CompressorData^.GainRight:=1.0;
{$endif}
end;

procedure SynthProcessCompressor(Track:PSynthTrack;Compressor:PSynthCompressor;CompressorData:PSynthCompressorData;Buffer,SideBuffer,CompressorBuffer:PSynthBufferSample;WindowBuffer,SoftHardKneeBuffer,ThresholdBuffer,RatioBuffer,AttackBuffer,ReleaseBuffer,OutGainBuffer:PSynthFloatValue;Samples,SampleRate:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808COMPRESSOR}
const MinValue:single=1E-8;
      FloorValue:single=0.001;
var Remain,WindowSamples,OldWindowSamples,MaxWindowSamples:longint;
    OutGain,Threshold,Attack,Release,Theta,Ratio,SoftHardKneeFactor,
    WindowValue,SoftHardKneeValue,ThresholdValue,RatioValue,AttackValue,
    ReleaseValue,OutGainValue,MinSoftHardKneeValue:single;
 procedure ProcessCompress(var RMSPeakValue,Envelope,Gain:single);
 var DestGain:single;
 begin
  longword(pointer(@Envelope)^):=longword(pointer(@Envelope)^) and (-((((longword(pointer(@Envelope)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@Envelope)^) and $7f800000)<>0)));
  longword(pointer(@RMSPeakValue)^):=longword(pointer(@RMSPeakValue)^) and (-((((longword(pointer(@RMSPeakValue)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@RMSPeakValue)^) and $7f800000)<>0)));
  plongword(@RMSPeakValue)^:=plongword(@RMSPeakValue)^ and $7fffffff;
  if plongword(@RMSPeakValue)^>plongword(@Envelope)^ then begin
   Theta:=Attack;
  end else begin
   Theta:=Release;
  end;
  Envelope:=((1-Theta)*RMSPeakValue)+(Theta*Envelope);
  if plongword(@Envelope)^>plongword(@Threshold)^ then begin
   DestGain:=power(Threshold/Envelope,1-Ratio);
  end else begin
   DestGain:=1;
  end;
  Gain:=Gain+((DestGain-Gain)*SoftHardKneeFactor);
  longword(pointer(@Gain)^):=longword(pointer(@Gain)^) and (-((((longword(pointer(@Gain)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@Gain)^) and $7f800000)<>0)));
 end;
{$endif}
begin
{$ifdef BR808COMPRESSOR}
 if Compressor^.Mode<>cmNONE then begin
  MaxWindowSamples:=SampleRate div 10;
  CompressorData^.WindowSize:=Track^.POTBufferSize;
  CompressorData^.WindowMask:=Track^.POTBufferMask;
  CompressorData^.PeakBuffer:=pointer(CompressorBuffer);
  AttackValue:=exp(-1/((SampleRate*sqr((Compressor^.Attack*fCI999*0.99)+0.01))+0.00001));
  longword(pointer(@AttackValue)^):=longword(pointer(@AttackValue)^) and longword($ffffffff+longword(((((longword(pointer(@AttackValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  Attack:=AttackValue;
  ReleaseValue:=exp(-1/((SampleRate*5*sqr((Compressor^.Release*fCI999*0.99)+0.01))+0.00001));
  longword(pointer(@ReleaseValue)^):=longword(pointer(@ReleaseValue)^) and longword($ffffffff+longword(((((longword(pointer(@ReleaseValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  Release:=ReleaseValue;
  WindowValue:=Clip(SampleRate*0.1*sqr((Compressor^.WindowSize*fCI999*0.99)+0.01),1,MaxWindowSamples);
  WindowSamples:=SoftTRUNC(WindowValue);
  if WindowSamples<1 then begin
   WindowSamples:=1;
  end;
  if WindowSamples>MaxWindowSamples then begin
   WindowSamples:=MaxWindowSamples;
  end;
  CompressorData^.WindowSamples:=WindowSamples;
  CompressorData^.InvWindowSamples:=1.0/WindowSamples;
  MinSoftHardKneeValue:=power(0.00003,SampleRate/44100);
  SoftHardKneeValue:=Clip(power(Clip(sqr(Compressor^.SoftHardKnee*fCI255),0.00003,1.0),SampleRate/44100),MinSoftHardKneeValue,1.0);
  longword(pointer(@SoftHardKneeValue)^):=longword(pointer(@SoftHardKneeValue)^) and longword($ffffffff+longword(((((longword(pointer(@SoftHardKneeValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  SoftHardKneeFactor:=SoftHardKneeValue;
  if Compressor^.Ratio=255 then begin
   RatioValue:=InfiniteRatio;
  end else begin
   RatioValue:=1/Clip((Compressor^.Ratio*fci17)+1,1.0,16.0);
  end;
  longword(pointer(@RatioValue)^):=longword(pointer(@RatioValue)^) and longword($ffffffff+longword(((((longword(pointer(@RatioValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  Ratio:=RatioValue;
  ThresholdValue:=sqr(Compressor^.Threshold*fci999);
  longword(pointer(@ThresholdValue)^):=longword(pointer(@ThresholdValue)^) and longword($ffffffff+longword(((((longword(pointer(@ThresholdValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  Threshold:=ThresholdValue;
  if Compressor^.AutoGain then begin
   case Compressor^.Mode of
    cmMonoEnvFollowPeak,cmMonoAveragePeak,cmMonoMinimumPeak,cmMonoMaximumPeak,
    cmStereoEnvFollowPeak,cmStereoAveragePeak,cmStereoMinimumPeak,cmStereoMaximumPeak:begin
     OutGainValue:=Threshold;
    end;
    else begin
     OutGainValue:=sqr(Threshold);
    end;
   end;
   if abs(OutGainValue)>EPSILON then begin
    case Compressor^.Mode of
     cmMonoEnvFollowPeak,cmMonoAveragePeak,cmMonoMinimumPeak,cmMonoMaximumPeak,
     cmStereoEnvFollowPeak,cmStereoAveragePeak,cmStereoMinimumPeak,cmStereoMaximumPeak:begin
      OutGainValue:=1/OutGainValue;
     end;
     else begin
      OutGainValue:=FastSQRT(1/OutGainValue);
     end;
    end;
   end else begin
    OutGainValue:=1;
   end;
  end else begin
   if Compressor^.OutGain=0 then begin
    OutGainValue:=1;
   end else begin
    OutGainValue:=power(10,Compressor^.OutGain*fci999m4);
   end;
  end;
  longword(pointer(@OutGainValue)^):=longword(pointer(@OutGainValue)^) and longword($ffffffff+longword(((((longword(pointer(@OutGainValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  CompressorData^.WindowCoefFactor:=1.0-exp(-1.0/max(WindowValue,0.001));
  longword(pointer(@CompressorData^.WindowCoefFactor)^):=longword(pointer(@CompressorData^.WindowCoefFactor)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.WindowCoefFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  OldWindowSamples:=WindowSamples;
  Remain:=Samples;
  CompressorData^.PeakBufferPosition:=CompressorData^.PeakBufferPosition and CompressorData^.WindowMask;
  while Remain>0 do begin
   if assigned(WindowBuffer) then begin
    WindowValue:=Clip(WindowValue*WindowBuffer^,1,MaxWindowSamples);
    WindowSamples:=SoftTRUNC(WindowValue); 
    if WindowSamples>MaxWindowSamples then begin
     WindowSamples:=MaxWindowSamples;
    end;
    inc(WindowBuffer);
    if WindowSamples<>OldWindowSamples then begin
     OldWindowSamples:=WindowSamples;
     CompressorData^.WindowCoefFactor:=1.0-exp(-1.0/max(WindowValue,0.001));
     CompressorData^.WindowSamples:=WindowSamples;
     longword(pointer(@CompressorData^.WindowCoefFactor)^):=longword(pointer(@CompressorData^.WindowCoefFactor)^) and longword($ffffffff+longword(((((longword(pointer(@CompressorData^.WindowCoefFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    end;
   end;
   if assigned(SoftHardKneeBuffer) then begin
    SoftHardKneeFactor:=Clip(SoftHardKneeValue*SoftHardKneeBuffer^,MinSoftHardKneeValue,1);
    longword(pointer(@SoftHardKneeFactor)^):=longword(pointer(@SoftHardKneeFactor)^) and longword($ffffffff+longword(((((longword(pointer(@SoftHardKneeFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(SoftHardKneeBuffer);
   end;
   Threshold:=ThresholdValue*ThresholdBuffer^;
   inc(ThresholdBuffer);
   Ratio:=RatioValue*RatioBuffer^;
   inc(RatioBuffer);
   Attack:=AttackValue*AttackBuffer^;
   inc(AttackBuffer);
   Release:=ReleaseValue*ReleaseBuffer^;
   inc(ReleaseBuffer);
   OutGain:=OutGainValue*OutGainBuffer^;
   inc(OutGainBuffer);
   longword(pointer(@Threshold)^):=longword(pointer(@Threshold)^) and longword($ffffffff+longword(((((longword(pointer(@Threshold)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Ratio)^):=longword(pointer(@Ratio)^) and longword($ffffffff+longword(((((longword(pointer(@Ratio)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Attack)^):=longword(pointer(@Attack)^) and longword($ffffffff+longword(((((longword(pointer(@Attack)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Release)^):=longword(pointer(@Release)^) and longword($ffffffff+longword(((((longword(pointer(@Release)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@OutGain)^):=longword(pointer(@OutGain)^) and longword($ffffffff+longword(((((longword(pointer(@OutGain)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   SynthCompressorWindowProcs[Compressor^.Mode](SideBuffer,CompressorData);
   ProcessCompress(CompressorData^.RMSPeakValueLeft,CompressorData^.EnvelopeLeft,CompressorData^.GainLeft);
   ProcessCompress(CompressorData^.RMSPeakValueRight,CompressorData^.EnvelopeRight,CompressorData^.GainRight);
   Buffer^.Left:=Buffer^.Left*CompressorData^.GainLeft*OutGain;
   Buffer^.Right:=Buffer^.Right*CompressorData^.GainRight*OutGain;
   longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Buffer);
   inc(SideBuffer);
   dec(Remain);
  end;
 end;
{$endif}
end;

procedure SynthProcessReverb(Track:PSynthTrack;Reverb:PSynthReverb;ReverbData:PSynthReverbData;Buffer:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808REVERB}
var SampleCounter,AllPassFilterCount,AllPassFilterCounter,MaxSamples,
    Time,TimeEx:longint;
    CutOff,Wet,Dry,FeedBack,SampleLeft,SampleRight,
    OutputLeft,OutputRight,LeftOutput,RightOutput:single;
{$endif}
begin
{$ifdef BR808REVERB}
 if Reverb^.Active then begin
  CutOff:=sin(Reverb^.Absortion*fCI255*44100*Track^.InternalSampleRateFactor*pi*0.5);
  Wet:=Reverb^.Wet*fCI255;
  Dry:=Reverb^.Dry*fCI255;
  FeedBack:=sqr(Reverb^.FeedBack*fci255);
  AllPassFilterCount:=Reverb^.NumberOfAllPassFilters;
  if AllPassFilterCount>=MaxReverbAllPassFilters then begin
   AllPassFilterCount:=MaxReverbAllPassFilters;
  end;
  MaxSamples:=Track^.InternalSampleRate*2;
  if not ReverbData^.Ready then begin
   ReverbData^.LeftCounter:=MaxSamples-4;
   ReverbData^.RightCounter:=MaxSamples-4;
   ReverbData^.LeftDelayedCounter:=ReverbData^.LeftCounter-SoftTRUNC((sqr(Reverb^.PreDelay*fCI255)*MaxSamples)+0.5);
   ReverbData^.RightDelayedCounter:=ReverbData^.RightCounter-SoftTRUNC(((sqr(Reverb^.PreDelay*fCI255)+sqr(Reverb^.CombFilterSeparation*fCI255))*MaxSamples)+0.5);
   if ReverbData^.LeftDelayedCounter<0 then begin
    ReverbData^.LeftDelayedCounter:=0;
   end;
   if ReverbData^.RightDelayedCounter<0 then begin
    ReverbData^.RightDelayedCounter:=0;
   end;
   TimeEx:=SoftTRUNC(Clip((sqr(Reverb^.RoomSize*fCI255)*639)+1.5,1,640));
   for AllPassFilterCounter:=0 to AllPassFilterCount-1 do begin
    Time:=(TimeEx*(AllPassFilterCounter+1))+(AllPassFilterCounter*AllPassFilterCounter);
    ReverbData^.Counter[AllPassFilterCounter,0]:=MaxSamples-4;
    ReverbData^.Counter[AllPassFilterCounter,2]:=ReverbData^.Counter[AllPassFilterCounter,0]-Time;
    ReverbData^.Counter[AllPassFilterCounter,1]:=MaxSamples-4;
    ReverbData^.Counter[AllPassFilterCounter,3]:=ReverbData^.Counter[AllPassFilterCounter,1]-(Time+SoftTRUNC(AllPassFilterCounter*1.3));
    if ReverbData^.Counter[AllPassFilterCounter,2]<0 then begin
     ReverbData^.Counter[AllPassFilterCounter,2]:=0;
    end;
    if ReverbData^.Counter[AllPassFilterCounter,3]<0 then begin
     ReverbData^.Counter[AllPassFilterCounter,3]:=0;
    end;
   end;
   ReverbData^.Ready:=true;
  end;
  for SampleCounter:=1 to Samples do begin
   SampleLeft:=Buffer^.Left;
   SampleRight:=Buffer^.Right;
   longword(pointer(@SampleLeft)^):=longword(pointer(@SampleLeft)^) and longword($ffffffff+longword(((((longword(pointer(@SampleLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@SampleRight)^):=longword(pointer(@SampleRight)^) and longword($ffffffff+longword(((((longword(pointer(@SampleRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

   if ReverbData^.LeftCounter>=MaxSamples then begin
    ReverbData^.LeftCounter:=0;
   end;
   if ReverbData^.RightCounter>=MaxSamples then begin
    ReverbData^.RightCounter:=0;
   end;
   if ReverbData^.LeftDelayedCounter>=MaxSamples then begin
    ReverbData^.LeftDelayedCounter:=0;
   end;
   if ReverbData^.RightDelayedCounter>=MaxSamples then begin
    ReverbData^.RightDelayedCounter:=0;
   end;

   ReverbData^.LeftBuffer^[ReverbData^.LeftCounter]:=SampleLeft;
   ReverbData^.RightBuffer^[ReverbData^.RightCounter]:=SampleRight;

   OutputLeft:=ReverbData^.LeftBuffer^[ReverbData^.LeftDelayedCounter];
   OutputRight:=ReverbData^.RightBuffer^[ReverbData^.RightDelayedCounter];

   inc(ReverbData^.LeftCounter);
   inc(ReverbData^.RightCounter);
   inc(ReverbData^.LeftDelayedCounter);
   inc(ReverbData^.RightDelayedCounter);

   for AllPassFilterCounter:=0 to AllPassFilterCount-1 do begin
    if ReverbData^.Counter[AllPassFilterCounter,0]>=MaxSamples then begin
     ReverbData^.Counter[AllPassFilterCounter,0]:=0;
    end;
    if ReverbData^.Counter[AllPassFilterCounter,1]>=MaxSamples then begin
     ReverbData^.Counter[AllPassFilterCounter,1]:=0;
    end;
    if ReverbData^.Counter[AllPassFilterCounter,2]>=MaxSamples then begin
     ReverbData^.Counter[AllPassFilterCounter,2]:=0;
    end;
    if ReverbData^.Counter[AllPassFilterCounter,3]>=MaxSamples then begin
     ReverbData^.Counter[AllPassFilterCounter,3]:=0;
    end;
    LeftOutput:=(OutputLeft*(-FeedBack))+ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,2]].Left;
    longword(pointer(@LeftOutput)^):=longword(pointer(@LeftOutput)^) and longword($ffffffff+longword(((((longword(pointer(@LeftOutput)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Left:=OutputLeft+(LeftOutput*FeedBack);
//  longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Left)^):=longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Left)^) and longword($ffffffff+longword(((((longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    OutputLeft:=LeftOutput;
    RightOutput:=(OutputRight*(-FeedBack))+ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,3]].Right;
    longword(pointer(@RightOutput)^):=longword(pointer(@RightOutput)^) and longword($ffffffff+longword(((((longword(pointer(@RightOutput)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,1]].Right:=OutputRight+(RightOutput*FeedBack);
//  longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Right)^):=longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Right)^) and longword($ffffffff+longword(((((longword(pointer(@ReverbData^.AllPassBuffer[AllPassFilterCounter]^[ReverbData^.Counter[AllPassFilterCounter,0]].Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    OutputRight:=RightOutput;
    inc(ReverbData^.Counter[AllPassFilterCounter,0]);
    inc(ReverbData^.Counter[AllPassFilterCounter,1]);
    inc(ReverbData^.Counter[AllPassFilterCounter,2]);
    inc(ReverbData^.Counter[AllPassFilterCounter,3]);
   end;

   ReverbData^.LastLowPassLeft:=ReverbData^.LastLowPassLeft+(CutOff*(OutputLeft-ReverbData^.LastLowPassLeft));
   ReverbData^.LastLowPassRight:=ReverbData^.LastLowPassRight+(CutOff*(OutputRight-ReverbData^.LastLowPassRight));
   longword(pointer(@ReverbData^.LastLowPassLeft)^):=longword(pointer(@ReverbData^.LastLowPassLeft)^) and longword($ffffffff+longword(((((longword(pointer(@ReverbData^.LastLowPassLeft)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@ReverbData^.LastLowPassRight)^):=longword(pointer(@ReverbData^.LastLowPassRight)^) and longword($ffffffff+longword(((((longword(pointer(@ReverbData^.LastLowPassRight)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));

   Buffer^.Left:=(Buffer^.Left*Dry)+(ReverbData^.LastLowPassLeft*Wet);
   Buffer^.Right:=(Buffer^.Right*Dry)+(ReverbData^.LastLowPassRight*Wet);
   longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Buffer);
  end;
 end;
{$endif}
end;

procedure SynthProcessPitchShifterInit(Track:PSynthTrack;PitchShifter:PSynthPitchShifter;PitchShifterData:PSynthPitchShifterData);{$ifdef cpu386}register;{$endif}
begin
{$ifdef BR808PITCHSHIFTER}
 FillChar(PitchShifterData^,sizeof(TSynthPitchShifterData),#0);
 PitchShifterData^.P1:=0;
 PitchShifterData^.P2:=(PitchBufferSize shr 1) shl OutputShift;
 PitchShifterData^.InputPointer:=0;
 PitchShifterData^.OutputIncrement:=1;
 PitchShifterData^.OutputIncrement:=PitchShifterData^.OutputIncrement-(1 shl OutputShift);
{$endif}
end;

procedure SynthProcessPitchShifter(Track:PSynthTrack;PitchShifter:PSynthPitchShifter;PitchShifterData:PSynthPitchShifterData;Buffer:PSynthBufferSample;TuneBuffer,FineTuneBuffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808PITCHSHIFTER}
var InSample,OutSample:PSynthBufferSample;
    Factor,A,B:single;
    Counter:longint;
    P1,P2,InputPointer,OutputIncrement,UP1,UP2:longword;
    WorkBuffer:PSynthPitchShifterBuffer;
    Fade:PSynthPitchShifterFadeBuffer;
    SemiTones:single;
{$endif}
BEGIN
{$ifdef BR808PITCHSHIFTER}
 if not PitchShifter^.Active then exit;
 SemiTones:=PitchShifter^.Tune+(PitchShifter^.FineTune*fCI100);
 Factor:=power(2,SemiTones*fCI12);
 PitchShifterData^.OutputIncrement:=softtrunc((Factor*(1 shl OutputShift))+0.5);
 PitchShifterData^.OutputIncrement:=PitchShifterData^.OutputIncrement-(1 shl OutputShift);
 P1:=PitchShifterData^.P1;
 P2:=PitchShifterData^.P2;                      
 InputPointer:=PitchShifterData^.InputPointer;
 OutputIncrement:=PitchShifterData^.OutputIncrement;
 Fade:=@Track.PitchShifterFadeBuffer;
 InSample:=Buffer;
 OutSample:=Buffer;
 WorkBuffer:=@PitchShifterData^.Buffer;
 if (assigned(TuneBuffer) and (TuneBuffer<>Track^.F1D0Buffer)) or (assigned(FineTuneBuffer) and (FineTuneBuffer<>Track^.F1D0Buffer)) then begin
  for Counter:=1 to Samples do begin
   if assigned(TuneBuffer) and (TuneBuffer<>Track^.F1D0Buffer) then begin
    SemiTones:=PitchShifter^.Tune*TuneBuffer^;
    inc(TuneBuffer);
   end else begin
    SemiTones:=PitchShifter^.Tune;
   end;
   if assigned(FineTuneBuffer) and (FineTuneBuffer<>Track^.F1D0Buffer) then begin
    SemiTones:=SemiTones+((PitchShifter^.FineTune*FineTuneBuffer^)*fCI100);
    inc(FineTuneBuffer);
   end else begin
    SemiTones:=SemiTones+(PitchShifter^.FineTune*fCI100);
   end;
   Factor:=power(2,SemiTones*fCI12);
   PitchShifterData^.OutputIncrement:=softtrunc((Factor*(1 shl OutputShift))+0.5);
   PitchShifterData^.OutputIncrement:=PitchShifterData^.OutputIncrement-(1 shl OutputShift);
   OutputIncrement:=PitchShifterData^.OutputIncrement;
   UP1:=P1 shr OutputShift;
   UP2:=P2 shr OutputShift;
   longword(pointer(@InSample^.Left)^):=longword(pointer(@InSample^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@InSample^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@InSample^.Right)^):=longword(pointer(@InSample^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@InSample^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   WorkBuffer^[InputPointer].Left:=InSample^.Left;
   A:=WorkBuffer^[(InputPointer-UP1) and PitchBufferMask].Left*Fade^[UP1 and PitchBufferMask];
   B:=WorkBuffer^[(InputPointer-UP2) and PitchBufferMask].Left*Fade^[UP2 and PitchBufferMask];
   longword(pointer(@A)^):=longword(pointer(@A)^) and longword($ffffffff+longword(((((longword(pointer(@A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@B)^):=longword(pointer(@B)^) and longword($ffffffff+longword(((((longword(pointer(@B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample^.Left:=A+B;
   WorkBuffer^[InputPointer].Right:=InSample^.Right;
   A:=WorkBuffer^[(InputPointer-UP1) and PitchBufferMask].Right*Fade^[UP1 and PitchBufferMask];
   B:=WorkBuffer^[(InputPointer-UP2) and PitchBufferMask].Right*Fade^[UP2 and PitchBufferMask];
   longword(pointer(@A)^):=longword(pointer(@A)^) and longword($ffffffff+longword(((((longword(pointer(@A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@B)^):=longword(pointer(@B)^) and longword($ffffffff+longword(((((longword(pointer(@B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample^.Right:=A+B;
   P1:=P1-OutputIncrement;
   P2:=P2-OutputIncrement;
   InputPointer:=(InputPointer+1) and PitchBufferMask;
   inc(InSample);
   inc(OutSample);
  end;
 end else begin
  for Counter:=1 to Samples do begin
   UP1:=P1 shr OutputShift;
   UP2:=P2 shr OutputShift;
   longword(pointer(@InSample^.Left)^):=longword(pointer(@InSample^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@InSample^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@InSample^.Right)^):=longword(pointer(@InSample^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@InSample^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   WorkBuffer^[InputPointer].Left:=InSample^.Left;
   A:=WorkBuffer^[(InputPointer-UP1) and PitchBufferMask].Left*Fade^[UP1 and PitchBufferMask];
   B:=WorkBuffer^[(InputPointer-UP2) and PitchBufferMask].Left*Fade^[UP2 and PitchBufferMask];
   longword(pointer(@A)^):=longword(pointer(@A)^) and longword($ffffffff+longword(((((longword(pointer(@A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@B)^):=longword(pointer(@B)^) and longword($ffffffff+longword(((((longword(pointer(@B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample^.Left:=A+B;
   WorkBuffer^[InputPointer].Right:=InSample^.Right;
   A:=WorkBuffer^[(InputPointer-UP1) and PitchBufferMask].Right*Fade^[UP1 and PitchBufferMask];
   B:=WorkBuffer^[(InputPointer-UP2) and PitchBufferMask].Right*Fade^[UP2 and PitchBufferMask];
   longword(pointer(@A)^):=longword(pointer(@A)^) and longword($ffffffff+longword(((((longword(pointer(@A)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@B)^):=longword(pointer(@B)^) and longword($ffffffff+longword(((((longword(pointer(@B)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample^.Right:=A+B;
   P1:=P1-OutputIncrement;
   P2:=P2-OutputIncrement;
   InputPointer:=(InputPointer+1) and PitchBufferMask;
   inc(InSample);
   inc(OutSample);
  end;
 end;
 PitchShifterData^.P1:=P1;
 PitchShifterData^.P2:=P2;
 PitchShifterData^.InputPointer:=InputPointer;
{$endif}
end;

procedure SynthProcessEQInit(Track:PSynthTrack;EQ:PSynthEQ;EQData:PSynthEQData);{$ifdef cpu386}register;{$endif}
{$ifdef BR808EQ}
var Band:longint;
{$endif}
begin
{$ifdef BR808EQ}
 FillChar(EQData^,sizeof(TSynthEQData),#0);
 for Band:=0 to MaxEQBands-1 do begin
  EQData^.Bands[Band].BandHz:=-1;
  EQData^.Bands[Band].Gain:=-1;
 end;
 EQData.PreAmp:=-1;
 EQData.Mode:=-1;
 EQData^.i:=0;
 EQData^.j:=2;
 EQData^.k:=1;
{$endif}
end;

procedure SynthProcessEQ(Track:PSynthTrack;EQ:PSynthEQ;EQData:PSynthEQData;Buffer:PSynthBufferSample;Gain0Buffer,Gain1Buffer,Gain2Buffer,Gain3Buffer,Gain4Buffer,Gain5Buffer,Gain6Buffer,Gain7Buffer,Gain8Buffer,Gain9Buffer:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
{$ifdef BR808EQ}
const M_SQRT2=1.41421356237309504880;
      GAIN_F0=1;
      GAIN_F1=GAIN_F0/M_SQRT2;
var i,dBRange,Channel,Pass,Band,NumPasses:longint;
    InSample,OutSample,WorkSample:TSynthBufferSample;
    l:single;
    v:array[0..MaxEQBands-1] of single;
 function CalculateTeta(const f:double):double;
 begin
  result:=2*pi*f*Track^.InternalSampleRateFactor;
 end;
 function CalculateAlpha(const Beta:double):double;
 begin
  result:=(0.5-Beta)*0.5;
 end;
 function CalculateGamma(const Beta,TF0:double):double;
 begin
  result:=(0.5+Beta)*cos(TF0);
 end;
 function CalculateBeta0(const TF0,TF:double):double;
 begin
  result:=(0.25*sqr(GAIN_F1)*sqr(cos(tf0)))-(0.5*sqr(GAIN_F1)*cos(tf)*cos(tf0))+(0.25*sqr(GAIN_F1))-(0.25*sqr(GAIN_F0)*sqr(sin(tf)));
 end;
 function CalculateBeta1(const TF0,TF:double):double;
 begin
  result:=(2.0*sqr(GAIN_F1)*sqr(cos(tf)))+(sqr(GAIN_F1)*sqr(cos(tf0)))-(2.0*sqr(GAIN_F1)*cos(tf)*cos(tf0))-(sqr(GAIN_F1))+(sqr(GAIN_F0)*sqr(sin(tf)));
 end;
 function CalculateBeta2(const TF0,TF:double):double;
 begin
  result:=(sqr(GAIN_F1)*sqr(cos(tf0)))-(2.0*sqr(GAIN_F1)*cos(tf)*cos(tf0))+(sqr(GAIN_F1))-(sqr(GAIN_F0)*sqr(sin(tf)));
 end;
 procedure FindF1andF2(const F0,OctavePercent:double;var F1,F2:double);
 var OctaveFactor:double;
 begin
  OctaveFactor:=power(2,OctavePercent*0.5);
  F1:=F0/OctaveFactor;
  F2:=F0*OctaveFactor;
 end;
 function FindRoot(const a,b,c:double;var x0:double):boolean;
 var k,h,ka,x1:double;
 begin
  k:=c-((b*b)/(4*a));
  h:=-(b/(2*a));
  ka:=-(k/a);
  if ka<0 then begin
   result:=false;
  end else begin
   ka:=sqrt(ka);
   x0:=h-ka;
   x1:=h+ka;
   if x1<x0 then begin
    x0:=x1;
   end;
   result:=true;
  end;
 end;
 procedure SetBandPassFilter(var Coefficients:TSynthEQDataCoefficients;const Frequency:double);
 var F1,F2,X0:double;
 begin
  FindF1andF2(Frequency,EQ^.Octave*fci65536,F1,F2);
  if FindRoot(CalculateBeta2(CalculateTeta(Frequency),CalculateTeta(F1)),CalculateBeta1(CalculateTeta(Frequency),CalculateTeta(F1)),CalculateBeta0(CalculateTeta(Frequency),CalculateTeta(F1)),X0) then begin
   Coefficients.Beta:=2*X0;
   Coefficients.Alpha:=2*CalculateAlpha(X0);
   Coefficients.Gamma:=2*CalculateGamma(X0,CalculateTeta(Frequency));
  end else begin
   Coefficients.Beta:=0;
   Coefficients.Alpha:=0;
   Coefficients.Gamma:=0;
  end;
 end;
{$endif}
begin
{$ifdef BR808EQ}
 case EQ^.Mode of
  eqm6db:begin
   dBRange:=6;
  end;
  eqm12db:begin
   dBRange:=12;
  end;
  else begin
   dBRange:=24;
  end;
 end;
 for Band:=0 to MaxEQBands-1 do begin
  if EQData^.Bands[Band].BandHz<>EQ^.BandHz[Band] then begin
   EQData^.Bands[Band].BandHz:=EQ^.BandHz[Band];
   SetBandPassFilter(EQData^.Bands[Band].Coefficients,EQData^.Bands[Band].BandHz);
   longword(pointer(@EQData^.Bands[Band].Coefficients.Beta)^):=longword(pointer(@EQData^.Bands[Band].Coefficients.Beta)^) and (-((((longword(pointer(@EQData^.Bands[Band].Coefficients.Beta)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@EQData^.Bands[Band].Coefficients.Beta)^) and $7f800000)<>0)));
   longword(pointer(@EQData^.Bands[Band].Coefficients.Alpha)^):=longword(pointer(@EQData^.Bands[Band].Coefficients.Alpha)^) and (-((((longword(pointer(@EQData^.Bands[Band].Coefficients.Alpha)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@EQData^.Bands[Band].Coefficients.Alpha)^) and $7f800000)<>0)));
   longword(pointer(@EQData^.Bands[Band].Coefficients.Gamma)^):=longword(pointer(@EQData^.Bands[Band].Coefficients.Gamma)^) and (-((((longword(pointer(@EQData^.Bands[Band].Coefficients.Gamma)^) and $7f800000)-$7f800000) shr 31) and ord((longword(pointer(@EQData^.Bands[Band].Coefficients.Gamma)^) and $7f800000)<>0)));
  end;
  if (EQData^.Bands[Band].Gain<>EQ^.Gain[Band]) or (EQData^.Mode<>EQ^.Mode) then begin
   EQData^.Bands[Band].Gain:=EQ^.Gain[Band];
   EQData^.Bands[Band].GainValue:=power(10,(((EQ^.Gain[Band]*(dBRange*2))/240)-dBRange)/20);
   longword(pointer(@EQData^.Bands[Band].GainValue)^):=longword(pointer(@EQData^.Bands[Band].GainValue)^) and longword($ffffffff+longword(((((longword(pointer(@EQData^.Bands[Band].GainValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  end;
 end;
 if (EQData^.PreAmp<>EQ^.PreAmp) or (EQData^.Mode<>EQ^.Mode) then begin
  EQData^.PreAmp:=EQ^.PreAmp;
  EQData^.PreAmpValue:=power(10,(((EQ^.PreAmp*(dBRange*2))/240)-dBRange)/20);
  longword(pointer(@EQData^.PreAmpValue)^):=longword(pointer(@EQData^.PreAmpValue)^) and longword($ffffffff+longword(((((longword(pointer(@EQData^.PreAmpValue)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end;
 EQData^.Mode:=EQ^.Mode;
 if EQ^.Cascaded then begin
  NumPasses:=2;
 end else begin
  NumPasses:=1;
 end;
 if (Gain0Buffer=Track^.F1D0Buffer) and (Gain1Buffer=Track^.F1D0Buffer) and (Gain2Buffer=Track^.F1D0Buffer) and (Gain3Buffer=Track^.F1D0Buffer) and (Gain4Buffer=Track^.F1D0Buffer) and (Gain5Buffer=Track^.F1D0Buffer) and (Gain6Buffer=Track^.F1D0Buffer) and (Gain7Buffer=Track^.F1D0Buffer) and (Gain8Buffer=Track^.F1D0Buffer) and (Gain9Buffer=Track^.F1D0Buffer) then begin
  for i:=1 to Samples do begin
   InSample.Left:=Buffer^.Left*EQData^.PreAmpValue;
   InSample.Right:=Buffer^.Right*EQData^.PreAmpValue;
   longword(pointer(@InSample.Left)^):=longword(pointer(@InSample.Left)^) and longword($ffffffff+longword(((((longword(pointer(@InSample.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@InSample.Right)^):=longword(pointer(@InSample.Right)^) and longword($ffffffff+longword(((((longword(pointer(@InSample.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample.Left:=0;
   OutSample.Right:=0;
   WorkSample:=InSample;
   for Channel:=0 to 1 do begin
    for Pass:=0 to NumPasses-1 do begin
     if not EQ^.AddCascaded then begin
      OutSample.Channel[Channel]:=0;
     end;
     for Band:=0 to MaxEQBands-1 do begin
      EQData^.Bands[Band].History[Pass,Channel].x[EQData^.i]:=WorkSample.Channel[Channel];
      l:=(EQData^.Bands[Band].Coefficients.Alpha*(EQData^.Bands[Band].History[Pass,Channel].x[EQData^.i]-EQData^.Bands[Band].History[Pass,Channel].x[EQData^.k]))+
         (EQData^.Bands[Band].Coefficients.Gamma*EQData^.Bands[Band].History[Pass,Channel].y[EQData^.j])-
         (EQData^.Bands[Band].Coefficients.Beta*EQData^.Bands[Band].History[Pass,Channel].y[EQData^.k]);
      longword(pointer(@l)^):=longword(pointer(@l)^) and longword($ffffffff+longword(((((longword(pointer(@l)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      EQData^.Bands[Band].History[Pass,Channel].y[EQData^.i]:=l;
      l:=l*EQData^.Bands[Band].GainValue;
      longword(pointer(@l)^):=longword(pointer(@l)^) and longword($ffffffff+longword(((((longword(pointer(@l)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      // The multiplication by 2.0 was moved into the coefficients to save CPU
      // cycles here
      OutSample.Channel[Channel]:=OutSample.Channel[Channel]+l;
     end;
     WorkSample.Channel[Channel]:=OutSample.Channel[Channel];
    end;
    // Scale down original sample value and add it to the filters output. This
    // substitutes the multiplication by 0.25. Go back to use the floating point
    // multiplication before the conversion to give more dynamic range
    OutSample.Channel[Channel]:=OutSample.Channel[Channel]+(InSample.Channel[Channel]*0.25);
    longword(pointer(@OutSample.Channel[Channel])^):=longword(pointer(@OutSample.Channel[Channel])^) and longword($ffffffff+longword(((((longword(pointer(@OutSample.Channel[Channel])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   end;
   Buffer^:=OutSample;
   longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Buffer);
   inc(EQData^.i);
   inc(EQData^.j);
   inc(EQData^.k);
   if EQData^.i=3 then begin
    EQData^.i:=0;
   end else if EQData^.j=3 then begin
    EQData^.j:=0;
   end else if EQData^.k=3 then begin
    EQData^.k:=0;
   end;
  end;
 end else begin
  for i:=1 to Samples do begin
   v[0]:=Gain0Buffer^;
   v[1]:=Gain1Buffer^;
   v[2]:=Gain2Buffer^;
   v[3]:=Gain3Buffer^;
   v[4]:=Gain4Buffer^;
   v[5]:=Gain5Buffer^;
   v[6]:=Gain6Buffer^;
   v[7]:=Gain7Buffer^;
   v[8]:=Gain8Buffer^;
   v[9]:=Gain9Buffer^;
   InSample.Left:=Buffer^.Left*EQData^.PreAmpValue;
   InSample.Right:=Buffer^.Right*EQData^.PreAmpValue;
   longword(pointer(@InSample.Left)^):=longword(pointer(@InSample.Left)^) and longword($ffffffff+longword(((((longword(pointer(@InSample.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@InSample.Right)^):=longword(pointer(@InSample.Right)^) and longword($ffffffff+longword(((((longword(pointer(@InSample.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   OutSample.Left:=0;
   OutSample.Right:=0;
   WorkSample:=InSample;
   for Channel:=0 to 1 do begin
    for Pass:=0 to NumPasses-1 do begin
     if not EQ^.AddCascaded then begin
      OutSample.Channel[Channel]:=0;
     end;
     for Band:=0 to MaxEQBands-1 do begin
      EQData^.Bands[Band].History[Pass,Channel].x[EQData^.i]:=WorkSample.Channel[Channel];
      l:=(EQData^.Bands[Band].Coefficients.Alpha*(EQData^.Bands[Band].History[Pass,Channel].x[EQData^.i]-EQData^.Bands[Band].History[Pass,Channel].x[EQData^.k]))+
         (EQData^.Bands[Band].Coefficients.Gamma*EQData^.Bands[Band].History[Pass,Channel].y[EQData^.j])-
         (EQData^.Bands[Band].Coefficients.Beta*EQData^.Bands[Band].History[Pass,Channel].y[EQData^.k]);
      longword(pointer(@l)^):=longword(pointer(@l)^) and longword($ffffffff+longword(((((longword(pointer(@l)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      EQData^.Bands[Band].History[Pass,Channel].y[EQData^.i]:=l;
      l:=l*(EQData^.Bands[Band].GainValue*v[Band]);
      longword(pointer(@l)^):=longword(pointer(@l)^) and longword($ffffffff+longword(((((longword(pointer(@l)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      // The multiplication by 2.0 was moved into the coefficients to save CPU
      // cycles here
      OutSample.Channel[Channel]:=OutSample.Channel[Channel]+l;
     end;
     WorkSample.Channel[Channel]:=OutSample.Channel[Channel];
    end;
    // Scale down original sample value and add it to the filters output. This
    // substitutes the multiplication by 0.25. Go back to use the floating point
    // multiplication before the conversion to give more dynamic range
    OutSample.Channel[Channel]:=OutSample.Channel[Channel]+(InSample.Channel[Channel]*0.25);
    longword(pointer(@OutSample.Channel[Channel])^):=longword(pointer(@OutSample.Channel[Channel])^) and longword($ffffffff+longword(((((longword(pointer(@OutSample.Channel[Channel])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   end;
   Buffer^:=OutSample;
   longword(pointer(@Buffer^.Left)^):=longword(pointer(@Buffer^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Buffer^.Right)^):=longword(pointer(@Buffer^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buffer^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Buffer);
   inc(EQData^.i);
   inc(EQData^.j);
   inc(EQData^.k);
   if EQData^.i=3 then begin
    EQData^.i:=0;
   end else if EQData^.j=3 then begin
    EQData^.j:=0;
   end else if EQData^.k=3 then begin
    EQData^.k:=0;
   end;
   inc(Gain0Buffer);
   inc(Gain1Buffer);
   inc(Gain2Buffer);
   inc(Gain3Buffer);
   inc(Gain4Buffer);
   inc(Gain5Buffer);
   inc(Gain6Buffer);
   inc(Gain7Buffer);
   inc(Gain8Buffer);
   inc(Gain9Buffer);
  end;
 end;
{$endif}
end;

procedure SynthInitEQ(EQ:PSynthEQ);
begin
 FillChar(EQ^,sizeof(TSynthEQ),#0);
 EQ^.Active:=false;
 EQ^.Mode:=eqm12db;
 EQ^.PreAmp:=120;
 EQ^.Octave:=1 shl 16;
 EQ^.Cascaded:=false;
 EQ^.AddCascaded:=false;
 EQ^.BandHz[0]:=60;
 EQ^.BandHz[1]:=120;
 EQ^.BandHz[2]:=310;
 EQ^.BandHz[3]:=600;
 EQ^.BandHz[4]:=1000;
 EQ^.BandHz[5]:=3000;
 EQ^.BandHz[6]:=6000;
 EQ^.BandHz[7]:=12000;
 EQ^.BandHz[8]:=14000;
 EQ^.BandHz[9]:=16000;
 EQ^.Gain[0]:=120;
 EQ^.Gain[1]:=120;
 EQ^.Gain[2]:=120;
 EQ^.Gain[3]:=120;
 EQ^.Gain[4]:=120;
 EQ^.Gain[5]:=120;
 EQ^.Gain[6]:=120;
 EQ^.Gain[7]:=120;
 EQ^.Gain[8]:=120;
 EQ^.Gain[9]:=120;
end;

procedure SynthInitEQISO(EQ:PSynthEQ);
begin
 FillChar(EQ^,sizeof(TSynthEQ),#0);
 EQ^.Active:=false;
 EQ^.Mode:=eqm12db;
 EQ^.PreAmp:=120;
 EQ^.Octave:=1 shl 16;
 EQ^.Cascaded:=false;
 EQ^.AddCascaded:=false;
 EQ^.BandHz[0]:=31;
 EQ^.BandHz[1]:=62;
 EQ^.BandHz[2]:=125;
 EQ^.BandHz[3]:=250;
 EQ^.BandHz[4]:=500;
 EQ^.BandHz[5]:=1000;
 EQ^.BandHz[6]:=2000;
 EQ^.BandHz[7]:=4000;
 EQ^.BandHz[8]:=8000;
 EQ^.BandHz[9]:=16000;
 EQ^.Gain[0]:=120;
 EQ^.Gain[1]:=120;
 EQ^.Gain[2]:=120;
 EQ^.Gain[3]:=120;
 EQ^.Gain[4]:=120;
 EQ^.Gain[5]:=120;
 EQ^.Gain[6]:=120;
 EQ^.Gain[7]:=120;
 EQ^.Gain[8]:=120;
 EQ^.Gain[9]:=120;
end;

procedure SynthInitInstrument(Instrument:PSynthInstrument);
var i:longint;
begin
{$ifndef BR808EXEMUSPLAYER}
 FillChar(Instrument^,sizeof(TSynthInstrument),#0);
 
 Instrument^.Oscillator[0].NoteBegin:=0;
 Instrument^.Oscillator[0].NoteEnd:=119;
 Instrument^.Oscillator[0].SynthesisType:=stADDITIVE;
 Instrument^.Oscillator[0].WaveForm:=wfNONE;
 Instrument^.Oscillator[0].Color:=0;
 Instrument^.Oscillator[0].FeedBack:=0;
 Instrument^.Oscillator[0].FineTune:=0;
 Instrument^.Oscillator[0].Transpose:=0;
 Instrument^.Oscillator[0].Volume:=255;
 Instrument^.Oscillator[0].Glide:=0;{}
 Instrument^.Oscillator[0].Carry:=false;
 Instrument^.Oscillator[0].RandomPhase:=false;
 Instrument^.Oscillator[0].UsePanning:=false;
 Instrument^.Oscillator[0].Panning:=0;
 Instrument^.Oscillator[0].Output:=false;
 Instrument^.Oscillator[0].Input:=-1;
 Instrument^.Oscillator[0].HardSyncInput:=-1;
 Instrument^.Oscillator[0].PluckedStringDelayLineMode:=psdlmALLPASSLOGIC;
 Instrument^.Oscillator[0].PluckedStringDelayLineWidth:=1;
 Instrument^.Oscillator[0].PluckedStringReflection:=128;
 Instrument^.Oscillator[0].PluckedStringPick:=0;
 Instrument^.Oscillator[0].PluckedStringPickUp:=13;
 Instrument^.Oscillator[0].SuperOscWaveform:=sowfSAWUP;
 Instrument^.Oscillator[0].SuperOscMode:=sodcmORIGINAL;
 Instrument^.Oscillator[0].SuperOscCount:=7;
 Instrument^.Oscillator[0].SuperOscDetune:=128;
 Instrument^.Oscillator[0].SuperOscMix:=128;

 for i:=1 to MaxInstrumentOscillator-1 do begin
  Instrument^.Oscillator[i]:=Instrument^.Oscillator[0];
 end;
 Instrument^.Oscillator[0].WaveForm:=wfSINE;

 Instrument^.ADSR[0].Modes[esAttack]:=emLINEAR;
 Instrument^.ADSR[0].Times[esAttack]:=64;
 Instrument^.ADSR[0].Modes[esDecay]:=emEXP;
 Instrument^.ADSR[0].Times[esDecay]:=128;
 Instrument^.ADSR[0].Modes[esSustain]:=emsON;
 Instrument^.ADSR[0].Times[esSustain]:=128;
 Instrument^.ADSR[0].Modes[esRelease]:=emLINEAR;
 Instrument^.ADSR[0].Times[esRelease]:=64;
 Instrument^.ADSR[0].TargetDecayLevel:=128;
 Instrument^.ADSR[0].Amplify:=255;
 Instrument^.ADSR[0].Carry:=false;
 for i:=1 to MaxInstrumentADSR-1 do begin
  Instrument^.ADSR[i]:=Instrument^.ADSR[0];
 end;
 Instrument^.ADSR[0].Active:=true;
 Instrument^.ADSR[0].ActiveCheck:=true;

 Instrument^.Envelope[0].Amplify:=255;
 for i:=1 to MaxInstrumentEnvelopes-1 do begin
  Instrument^.Envelope[i]:=Instrument^.Envelope[0];
 end;

 Instrument^.LFO[0].WaveForm:=lwfNONE;
 Instrument^.LFO[0].PhaseSync:=lpsVOICE;
 for i:=1 to MaxInstrumentLFO-1 do begin
  Instrument^.LFO[i]:=Instrument^.LFO[0];
 end;

 Instrument^.Filter[0].Volume:=255;
 Instrument^.Filter[0].MinHz:=20;
 Instrument^.Filter[0].MaxHz:=13000;
 Instrument^.Filter[0].CutOff:=255;
 for i:=1 to MaxInstrumentFilter-1 do begin
  Instrument^.Filter[i]:=Instrument^.Filter[0];
 end;

 Instrument^.VoiceDistortion[0].Gain:=255;
 for i:=1 to MaxInstrumentDistortion-1 do begin
  Instrument^.VoiceDistortion[i]:=Instrument^.VoiceDistortion[0];
 end;

 Instrument^.ChannelFilter[0].Volume:=255;
 Instrument^.ChannelFilter[0].MinHz:=20;
 Instrument^.ChannelFilter[0].MaxHz:=13000;
 Instrument^.ChannelFilter[0].CutOff:=255;
 for i:=1 to MaxInstrumentFilter-1 do begin
  Instrument^.ChannelFilter[i]:=Instrument^.ChannelFilter[0];
 end;

 Instrument^.ChannelDistortion[0].Gain:=255;
 for i:=1 to MaxInstrumentDistortion-1 do begin
  Instrument^.ChannelDistortion[i]:=Instrument^.ChannelDistortion[0];
 end;

 Instrument^.ChannelPitchShifter.Tune:=0;
 Instrument^.ChannelPitchShifter.FineTune:=0;

 Instrument^.ChannelCompressor.Mode:=0;
 Instrument^.ChannelCompressor.Threshold:=500;
 Instrument^.ChannelCompressor.Ratio:=51;
 Instrument^.ChannelCompressor.WindowSize:=1;
 Instrument^.ChannelCompressor.SoftHardKnee:=255;
 Instrument^.ChannelCompressor.OutGain:=0;
 Instrument^.ChannelCompressor.Attack:=442;
 Instrument^.ChannelCompressor.Release:=442;
 Instrument^.ChannelCompressor.AutoGain:=false;
 Instrument^.ChannelCompressor.SideIn:=0;

 Instrument^.ChannelDelay[0].Wet:=127;
 Instrument^.ChannelDelay[0].Dry:=255;
 Instrument^.ChannelDelay[0].FeedBackLeft:=64;
 Instrument^.ChannelDelay[0].FeedBackRight:=64;
 Instrument^.ChannelDelay[0].TimeLeft:=99;
 Instrument^.ChannelDelay[0].TimeRight:=99;
 Instrument^.ChannelDelay[0].Fine:=true;
 Instrument^.ChannelDelay[0].Recursive:=true;
 for i:=1 to MaxInstrumentDelay-1 do begin
  Instrument^.ChannelDelay[i]:=Instrument^.ChannelDelay[0];
 end;

 Instrument^.ChannelChorusFlanger.Wet:=255;
 Instrument^.ChannelChorusFlanger.Dry:=255;
 Instrument^.ChannelChorusFlanger.FeedBackLeft:=64;
 Instrument^.ChannelChorusFlanger.FeedBackRight:=64;
 Instrument^.ChannelChorusFlanger.TimeLeft:=14;
 Instrument^.ChannelChorusFlanger.TimeRight:=14;
 Instrument^.ChannelChorusFlanger.LFORateLeft:=3;
 Instrument^.ChannelChorusFlanger.LFORateRight:=3;
 Instrument^.ChannelChorusFlanger.LFODepthLeft:=64;
 Instrument^.ChannelChorusFlanger.LFODepthRight:=64;
 Instrument^.ChannelChorusFlanger.LFOPhaseLeft:=0;
 Instrument^.ChannelChorusFlanger.LFOPhaseRight:=0;
 Instrument^.ChannelChorusFlanger.Fine:=true;
 Instrument^.ChannelChorusFlanger.Count:=1;

 Instrument^.ChannelSpeech.Active:=false;
 Instrument^.ChannelSpeech.FrameLength:=1;
 Instrument^.ChannelSpeech.Speed:=5;
 Instrument^.ChannelSpeech.TextNumber:=0;
 Instrument^.ChannelSpeech.Color:=0;
 Instrument^.ChannelSpeech.NoiseGain:=64;
 Instrument^.ChannelSpeech.Gain:=202;//64;
 Instrument^.ChannelSpeech.F4:=3250;
 Instrument^.ChannelSpeech.F5:=3700;
 Instrument^.ChannelSpeech.F6:=4990;
 Instrument^.ChannelSpeech.B4:=200;
 Instrument^.ChannelSpeech.B5:=200;
 Instrument^.ChannelSpeech.B6:=500;
 Instrument^.ChannelSpeech.CascadeGain:=20;
 Instrument^.ChannelSpeech.ParallelGain:=118;
 Instrument^.ChannelSpeech.AspirationGain:=255;
 Instrument^.ChannelSpeech.FricationGain:=32;

 SynthInitEQ(@Instrument^.ChannelEQ);

 Instrument^.Link.Active:=false;
 Instrument^.Link.Channel:=-1;
 Instrument^.Link.ProgramNr:=-1;

 Instrument^.ChannelVolume:=$ff;
 Instrument^.GlobalOutput:=0;
 Instrument^.GlobalReverb:=$ff;
 Instrument^.Volume:=$80;
 Instrument^.Transpose:=0;
 Instrument^.MaxPolyphony:=16;
 Instrument^.Carry:=false;
 Instrument^.Controller7BitFlags:=$ffffffff;

 Instrument^.ModulationMatrix[0].Source:=mmiVelocity;
 Instrument^.ModulationMatrix[0].SourceIndex:=0;
 Instrument^.ModulationMatrix[0].SourceFlags:=0;
 Instrument^.ModulationMatrix[0].SourceMode:=mmismSQR;
 Instrument^.ModulationMatrix[0].Target:=mmoVOLUME;
 Instrument^.ModulationMatrix[0].TargetIndex:=0;
 Instrument^.ModulationMatrix[0].Amount:=64;
 Instrument^.ModulationMatrix[0].Polarity:=mmpADD;

 Instrument^.ModulationMatrix[1].Source:=mmiVOLUME;
 Instrument^.ModulationMatrix[1].SourceIndex:=0;
 Instrument^.ModulationMatrix[1].SourceFlags:=2;
 Instrument^.ModulationMatrix[1].SourceMode:=mmismSQR;
 Instrument^.ModulationMatrix[1].Target:=mmoGlobalChannelVolume;
 Instrument^.ModulationMatrix[1].TargetIndex:=0;
 Instrument^.ModulationMatrix[1].Amount:=64;
 Instrument^.ModulationMatrix[1].Polarity:=mmpADD;

 Instrument^.ModulationMatrix[2].Source:=mmiEXPRESSION;
 Instrument^.ModulationMatrix[2].SourceIndex:=0;
 Instrument^.ModulationMatrix[2].SourceFlags:=2;
 Instrument^.ModulationMatrix[2].SourceMode:=mmismSQR;
 Instrument^.ModulationMatrix[2].Target:=mmoGlobalChannelVolume;
 Instrument^.ModulationMatrix[2].TargetIndex:=0;
 Instrument^.ModulationMatrix[2].Amount:=64;
 Instrument^.ModulationMatrix[2].Polarity:=mmpMUL;

 Instrument^.ModulationMatrix[3].Source:=mmiADSR;
 Instrument^.ModulationMatrix[3].SourceIndex:=0;
 Instrument^.ModulationMatrix[3].SourceFlags:=0;
 Instrument^.ModulationMatrix[3].SourceMode:=0;
 Instrument^.ModulationMatrix[3].Target:=mmoVOLUME;
 Instrument^.ModulationMatrix[3].TargetIndex:=0;
 Instrument^.ModulationMatrix[3].Amount:=64;
 Instrument^.ModulationMatrix[3].Polarity:=mmpMUL;

 Instrument^.ModulationMatrix[4].Source:=mmiPANNING;
 Instrument^.ModulationMatrix[4].SourceIndex:=0;
 Instrument^.ModulationMatrix[4].SourceFlags:=2;
 Instrument^.ModulationMatrix[4].SourceMode:=0;
 Instrument^.ModulationMatrix[4].Target:=mmoPANNING;
 Instrument^.ModulationMatrix[4].TargetIndex:=0;
 Instrument^.ModulationMatrix[4].Amount:=64;
 Instrument^.ModulationMatrix[4].Polarity:=mmpADD;

 Instrument^.ModulationMatrixItems:=5;

 Instrument^.VoiceOrder[voDistortion]:=voDistortion;
 Instrument^.VoiceOrder[voFilter]:=voFilter;

 Instrument^.ChannelOrder[coDistortion]:=coDistortion;
 Instrument^.ChannelOrder[coFilter]:=coFilter;
 Instrument^.ChannelOrder[coDelay]:=coDelay;
 Instrument^.ChannelOrder[coChorusFlanger]:=coChorusFlanger;
 Instrument^.ChannelOrder[coCompressor]:=coCompressor;
 Instrument^.ChannelOrder[coSpeech]:=coSpeech;
 Instrument^.ChannelOrder[coPitchShifter]:=coPitchShifter;
 Instrument^.ChannelOrder[coEQ]:=coEQ;

 Instrument^.UseTuningTable:=false;
 for i:=0 to 127 do begin
  Instrument^.TuningTable[i]:=i;
 end;
{$endif}
end;

procedure SynthInitSpeechSegments;
{$ifdef BR808SPEECH}
var Counter,SubCounter:longint;
{$endif}
begin
{$ifdef BR808SPEECH}
 FillChar(SpeechSegmentsArray,sizeof(TSynthSpeechSegments),#0);
 for Counter:=0 to NumberOfSegments-1 do begin
//SpeechSegmentsArray[Counter].Name:=SynthSpeechSegmentsStream.Name[Counter];
  SpeechSegmentsArray[Counter].Rank:=SynthSpeechSegmentsStream.Rank[Counter];
  SpeechSegmentsArray[Counter].Duration:=SynthSpeechSegmentsStream.Duration[Counter];
//SpeechSegmentsArray[Counter].AdditionalDuration:=SynthSpeechSegmentsStream.AdditionalDuration[Counter];
  SpeechSegmentsArray[Counter].Features:=SynthSpeechSegmentsStream.Features[Counter];
  for SubCounter:=0 to NumberOfSegmentParameters-1 do begin
   SpeechSegmentsArray[Counter].Parameters[SubCounter].Prop:=SynthSpeechSegmentsStream.Prop[SubCounter,Counter];
   SpeechSegmentsArray[Counter].Parameters[SubCounter].Extern:=SynthSpeechSegmentsStream.Extern[SubCounter,Counter];
   SpeechSegmentsArray[Counter].Parameters[SubCounter].Intern:=SynthSpeechSegmentsStream.Intern[SubCounter,Counter];
   SpeechSegmentsArray[Counter].Parameters[SubCounter].Steady:=SynthSpeechSegmentsStream.Steady[SubCounter,Counter];
   SpeechSegmentsArray[Counter].Parameters[SubCounter].Fixed:=SynthSpeechSegmentsStream.Fixed[SubCounter,Counter];
  end;
 end;
{$endif}
end;

procedure SynthFFTBitReversedLookUpTableCreate(var Instance:TSynthFFTBitReversedLookUpTable;BitCount:longint);
var Size,i,j,k:longint;
begin
 Size:=1 shl BitCount;
 GetMemAligned(Instance.Data,Size*sizeof(longint));
 j:=0;
 Instance.Data^[0]:=0;
 for i:=1 to Size-1 do begin
  k:=Size shr 1;
  j:=j xor k;
  while (j and k)=0 do begin
   k:=k shr 1;
   j:=j xor k;
  end;
  Instance.Data^[i]:=j;
 end;
end;

procedure SynthFFTBitReversedLookUpTableDestroy(var Instance:TSynthFFTBitReversedLookUpTable);
begin
 FreeMemAligned(Instance.Data);
end;

procedure SynthFFTTrigonemtricTableCreate(var Instance:TSynthFFTTrigonemtricTable;BitCount:longint);
var TotalLen,Level,LevelLen,i:longint;
    LevelData:PSynthFFTValueArray;
    FFTData:double;
begin
 Instance.Data:=nil;
 if BitCount>3 then begin
  TotalLen:=(1 shl (BitCount-1))-4;
  GetmemAligned(Instance.Data,TotalLen*sizeof(TSynthFFTValue));
  for Level:=3 to BitCount-1 do begin
   LevelLen:=1 shl (Level-1);
   LevelData:=@Instance.Data^[(1 shl (Level-1))-4];
   FFTData:=pi/(LevelLen shl 1);
   for i:=0 to LevelLen-1 do begin
    LevelData^[i]:=cos(i*FFTData);
   end;
  end;
 end;
end;

procedure SynthFFTTrigonemtricTableDestroy(var Instance:TSynthFFTTrigonemtricTable);
begin
 FreeMemAligned(Instance.Data);
end;

function SynthFFTTrigonemtricTableGetData(var Instance:TSynthFFTTrigonemtricTable;Level:longint):PSynthFFTValueArray;
begin
 result:=@Instance.Data^[(1 shl (Level-1))-4];
end;

procedure SynthFFTCreate(var Instance:TSynthFFT;const AFrameSize:longint);
begin
 Instance.FrameSize:=AFrameSize;
 Instance.BitCount:=trunc((ln(AFrameSize)/ln(2))+0.5);
 SynthFFTBitReversedLookUpTableCreate(Instance.BitReversedLookUpTable,Instance.BitCount);
 SynthFFTTrigonemtricTableCreate(Instance.TrigonemtricTable,Instance.BitCount);
 Instance.Sqrt2Div2:=sqrt(2)*0.5;
 Instance.BufferData:=nil;
 if Instance.BitCount>2 then begin
  GetMemAligned(Instance.BufferData,AFrameSize*sizeof(TSynthFFTValue));
 end;
end;

procedure SynthFFTDestroy(var Instance:TSynthFFT);
begin
 if assigned(Instance.BufferData) then begin
  FreeMemAligned(Instance.BufferData);
 end;
 SynthFFTBitReversedLookUpTableDestroy(Instance.BitReversedLookUpTable);
 SynthFFTTrigonemtricTableDestroy(Instance.TrigonemtricTable);
end;

procedure SynthFFTFFT(var Instance:TSynthFFT;FFTData,WaveData:PSynthFFTValueArray);
var sf,df,df2,trilut,sf1r,sf2r,dfr,dfi,sf1i,sf2i,temp:PSynthFFTValueArray;
    pass,coefcount,coefhalfcount,coefdoublecount,coefindex,ri0,ri1,ri2,ri3,
    n1,n2,n3,i:longint;
    bitlut:PSynthFFTIntegerArray;
    sf0,sf2,v,c,s,b0,b2:TSynthFFTValue;
begin
 n1:=1;
 n2:=2;
 n3:=3;
 case Instance.BitCount of
  0:begin
   FFTData^[0]:=WaveData^[0];
  end;
  1:begin
   FFTData^[0]:=WaveData^[0]+WaveData^[n1];
   FFTData^[n1]:=WaveData^[0]-WaveData^[n1];
  end;
  2:begin
   FFTData^[n1]:=WaveData^[0]-WaveData^[n2];
   FFTData^[n3]:=WaveData^[n1]-WaveData^[n3];
   b0:=WaveData^[0]+WaveData^[n2];
   b2:=WaveData^[n1]+WaveData^[n3];
   FFTData^[0]:=b0+b2;
   FFTData^[n2]:=b0-b2;
  end;
  else begin
   if (Instance.BitCount and 1)<>0 then begin
    df:=Instance.BufferData;
    sf:=FFTData;
   end else begin
    df:=FFTData;
    sf:=Instance.BufferData;
   end;
   bitlut:=Instance.BitReversedLookUpTable.Data;
   coefindex:=0;
   repeat
    ri0:=bitlut^[coefindex];
    ri1:=bitlut^[coefindex+1];
    ri2:=bitlut^[coefindex+2];
    ri3:=bitlut^[coefindex+3];
    df2:=@df^[coefindex];
    df2^[n1]:=WaveData^[ri0]-WaveData^[ri1];
    df2^[n3]:=WaveData^[ri2]-WaveData^[ri3];
    sf0:=WaveData^[ri0]+WaveData^[ri1];
    sf2:=WaveData^[ri2]+WaveData^[ri3];
    df2^[0]:=sf0+sf2;
    df2^[n2]:=sf0-sf2;
    inc(coefindex,4);
   until coefindex>=Instance.FrameSize;
   coefindex:=0;
   repeat
    sf^[coefindex]:=df^[coefindex]+df^[coefindex+4];
    sf^[coefindex+4]:=df^[coefindex]-df^[coefindex+4];
    sf^[coefindex+2]:=df^[coefindex+2];
    sf^[coefindex+6]:=df^[coefindex+6];
    v:=(df[coefindex+5]-df^[coefindex+7])*Instance.Sqrt2Div2;
    sf^[coefindex+1]:=df^[coefindex+1]+v;
    sf^[coefindex+3]:=df^[coefindex+1]-v;
    v:=(df^[coefindex+5]+df^[coefindex+7])*Instance.Sqrt2Div2;
    sf[coefindex+5]:=v+df^[coefindex+3];
    sf[coefindex+7]:=v-df^[coefindex+3];
    inc(coefindex,8);
   until coefindex>=Instance.FrameSize;
   for pass:=3 to Instance.BitCount-1 do begin
    coefindex:=0;
    coefcount:=1 shl pass;
    coefhalfcount:=coefcount shr 1;
    coefdoublecount:=coefcount shl 1;
    trilut:=pointer(SynthFFTTrigonemtricTableGetData(Instance.TrigonemtricTable,pass));
    repeat
     sf1r:=@sf^[coefindex];
     sf2r:=@sf1r^[coefcount];
     dfr:=@df^[coefindex];
     dfi:=@dfr^[coefcount];
     dfr^[0]:=sf1r^[0]+sf2r^[0];
     dfi^[0]:=sf1r^[0]-sf2r^[0];
     dfr^[coefhalfcount]:=sf1r^[coefhalfcount];
     dfi^[coefhalfcount]:=sf2r^[coefhalfcount];
     sf1i:=@sf1r^[coefhalfcount];
     sf2i:=@sf1i^[coefcount];
     for i:=1 to coefhalfcount-1 do  begin
      c:=trilut^[i];
      s:=trilut^[coefhalfcount-i];
      v:=(sf2r^[i]*c)-(sf2i^[i]*s);
      dfr^[i]:=sf1r^[i]+v;
      dfi^[-i]:=sf1r^[i]-v;
      v:=(sf2r^[i]*s)+(sf2i^[i]*c);
      dfi^[i]:=v+sf1i^[i];
      dfi^[coefcount-i]:=v-sf1i^[i];
     end;
     inc(coefindex,coefdoublecount);
    until coefindex>=Instance.FrameSize;
    temp:=df;
    df:=sf;
    sf:=temp;
   end;
  end;
 end;
end;

procedure SynthFFTIFFT(var Instance:TSynthFFT;FFTData,WaveData:PSynthFFTValueArray);
var n1,n2,n3,n4,n5,n6,n7,pass,coefcount,coefhalfcount,coefdoublecount,
    coefindex,i:longint;
    sf,df,dft,trilut,sfr,sfi,df1r,df2r,df1i,df2i,temp,sf2:PSynthFFTValueArray;
    c,s,vr,vi,b0,b1,b2,b3:TSynthFFTValue;
    bitlut:PSynthFFTIntegerArray;
begin
 n1:=1;
 n2:=2;
 n3:=3;
 n4:=4;
 n5:=5;
 n6:=6;
 n7:=7;
 case Instance.BitCount of
  0:begin
   WaveData^[0]:=FFTData^[0];
  end;
  1:begin
   WaveData^[0]:=FFTData^[0]+FFTData^[n1];
   WaveData^[n1]:=FFTData^[0]-FFTData^[n1];
  end;
  2:begin
   b0:=FFTData^[0]+FFTData[n2];
   b2:=FFTData^[0]-FFTData[n2];
   WaveData^[0]:=b0+(FFTData[n1]*2);
   WaveData^[n2]:=b0-(FFTData[n1]*2);
   WaveData^[n1]:=b2+(FFTData[n3]*2);
   WaveData^[n3]:=b2-(FFTData[n3]*2);
  end;
  else begin
   sf:=FFTData;
   if (Instance.BitCount and 1)<>0 then begin
    df:=Instance.BufferData;
    dft:=WaveData;
   end else begin
    df:=WaveData;
    dft:=pointer(Instance.BufferData);
   end;
   for pass:=Instance.BitCount-1 downto 3 do begin
    coefindex:=0;
    coefcount:=1 shl pass;
    coefhalfcount:=coefcount shr 1;
    coefdoublecount:=coefcount shl 1;
    trilut:=SynthFFTTrigonemtricTableGetData(Instance.TrigonemtricTable,pass);
    repeat
     sfr:=@sf^[coefindex];
     sfi:=@sfr^[coefcount];
     df1r:=@df^[coefindex];
     df2r:=@df1r^[coefcount];
     df1r^[0]:=sfr^[0]+sfi^[0];
     df2r^[0]:=sfr^[0]-sfi^[0];
     df1r^[coefhalfcount]:=sfr^[coefhalfcount]*2;
     df2r^[coefhalfcount]:=sfi^[coefhalfcount]*2;
     df1i:=@df1r^[coefhalfcount];
     df2i:=@df1i^[coefcount];
     for i:=1 to coefhalfcount-1 do begin
      df1r^[i]:=sfr^[i]+sfi^[-i];
      df1i^[i]:=sfi^[i]-sfi^[coefcount-i];
      c:=trilut^[i];
      s:=trilut^[coefhalfcount-i];
      vr:=sfr^[i]-sfi^[-i];
      vi:=sfi^[i]+sfi^[coefcount-i];
      df2r^[i]:=(vr*c)+(vi*s);
      df2i^[i]:=(vi*c)-(vr*s);
     end;
     inc(coefindex,coefdoublecount);
    until coefindex>=Instance.FrameSize;
    if pass<Instance.BitCount-1 then begin
     temp:=df;
     df:=sf;
     sf:=temp;
    end else begin
     sf:=df;
     df:=dft;
    end;
   end;
   coefindex:=0;
   repeat
    df^[coefindex]:=sf^[coefindex]+sf^[coefindex+4];
    df^[coefindex+4]:=sf^[coefindex]-sf^[coefindex+4];
    df^[coefindex+2]:=sf^[coefindex+2]*2;
    df^[coefindex+6]:=sf^[coefindex+6]*2;
    df^[coefindex+1]:=sf^[coefindex+1]+sf^[coefindex+3];
    df^[coefindex+3]:=sf^[coefindex+5]-sf^[coefindex+7];
    vr:=sf^[coefindex+1]-sf^[coefindex+3];
    vi:=sf^[coefindex+5]+sf^[coefindex+7];
    df^[coefindex+5]:=(vr+vi)*Instance.Sqrt2Div2;
    df^[coefindex+7]:=(vi-vr)*Instance.Sqrt2Div2;
    inc(coefindex,8);
   until coefindex>=Instance.FrameSize;
   coefindex:=0;
   bitlut:=Instance.BitReversedLookUpTable.Data;
   sf2:=df;
   repeat
    b0:=sf2^[0]+sf2^[n2];
    b2:=sf2^[0]-sf2^[n2];
    b1:=sf2^[n1]*2;
    b3:=sf2^[n3]*2;
    WaveData^[bitlut^[0]]:=b0+b1;
    WaveData^[bitlut^[n1]]:=b0-b1;
    WaveData^[bitlut^[n2]]:=b2+b3;
    WaveData^[bitlut^[n3]]:=b2-b3;
    b0:=sf2^[n4]+sf2^[n6];
    b2:=sf2^[n4]-sf2^[n6];
    b1:=sf2^[n5]*2;
    b3:=sf2^[n7]*2;
    WaveData^[bitlut^[n4]]:=b0+b1;
    WaveData^[bitlut^[n5]]:=b0-b1;
    WaveData^[bitlut^[n6]]:=b2+b3;
    WaveData^[bitlut^[n7]]:=b2-b3;
    inc(sf2,8);
    inc(coefindex,8);
    inc(bitlut,8);
   until coefindex>=Instance.FrameSize;
  end;
 end;
end;

procedure SynthFFTRescale(var Instance:TSynthFFT;WaveData:PSynthFFTValueArray);
var FFTData:TSynthFFTValue;
    i:longint;
begin
 FFTData:=1.0/Instance.FrameSize;
 for i:=0 to Instance.FrameSize-1 do begin
  WaveData^[i]:=WaveData^[i]*FFTData;
 end;
end;

function PadSynthProfileGauss(fi,bwi:single):single;
var x:single;
begin
 x:=sqr(fi/bwi);
 if x>14.71280603 then begin
  result:=0;
 end else begin
  result:=exp(-x)/bwi;
 end;
end;

function PadSynthProfileSingle(fi,bwi:single):single;
var x:single;
begin
 x:=fi/bwi;
 if abs(x)>0.1 then begin
  result:=0;
 end else begin
  result:=1/bwi;
 end;
end;

function PadSynthProfileDetune(fi,bwi:single):single;
var x:single;
begin
 x:=fi/bwi;
 if (x<-0.5) or ((x>-0.4) and (x<0.4)) or (x>0.5) then begin
  result:=0;
 end else begin
  result:=1/bwi;
 end;
end;

function PadSynthProfileSpread(fi,bwi:single):single;
var x:single;
begin
 x:=fi/bwi;
 if abs(x)>0.5 then begin
  result:=0;
 end else begin
  result:=1/bwi;
 end;
end;

type TPadSynthProfile=function(fi,bwi:single):single;
const PadSynthProfiles:array[0..3] of TPadSynthProfile=(PadSynthProfileGauss,PadSynthProfileSingle,PadSynthProfileDetune,PadSynthProfileSpread);

procedure PadSynth(Seed:longword;Wavetable:psinglearray;WavetableSize,SampleRate,Profile:longint;Frequency,Bandwidth,BandwidthScale:single;Harmonics:psinglearray;NumHarmonics:longint;ExtendedAlgorithm:boolean);
var nh,i:longint;
    bwhzt,bwhz,bwi,fi,bp,sr2,sr,WavetableSizeDiv,pi2:single;
    freqamp,freqphases:psinglearray;
    NoiseSeed,NoiseValue:longword;
    NoiseValueFloatCasted:single absolute NoiseValue;
 function relF(n:single):single;
 begin
  result:=n*(1+(n*0.1));
  if result<1e-10 then begin
   result:=1e-10;
  end;
 end;
 procedure IFFT;
 var i:longint;
     FFTInstance:TSynthFFT;
     InBuffer,OutBuffer:PSynthFFTValueArray;
 begin
  InBuffer:=nil;
  OutBuffer:=nil;
  GetMemZero(InBuffer,WavetableSize*2*sizeof(TSynthFFTValue));
  GetMemZero(OutBuffer,WavetableSize*2*sizeof(TSynthFFTValue));
  for i:=0 to (WavetableSize div 2)-1 do begin
   InBuffer^[i]:=freqamp^[i]*cos(freqphases^[i]);
   InBuffer^[i+(WavetableSize div 2)]:=freqamp^[i]*sin(freqphases^[i]);
  end;
  SynthFFTCreate(FFTInstance,WavetableSize);
  SynthFFTIFFT(FFTInstance,InBuffer,OutBuffer);
  SynthFFTRescale(FFTInstance,OutBuffer);
  SynthFFTDestroy(FFTInstance);
  for i:=0 to WavetableSize-1 do begin
   psinglearray(Wavetable)^[i]:=OutBuffer^[i];
  end;
  FreeMemAligned(InBuffer);
  FreeMemAligned(OutBuffer);
 end;
 procedure Normalize;
 var i:longint;
     max,v:single;
 begin
  max:=0;
  for i:=0 to WavetableSize-1 do begin
   if i=0 then begin
    max:=abs(psinglearray(Wavetable)^[i]);
   end else begin
    if max<abs(psinglearray(Wavetable)^[i]) then begin
     max:=abs(psinglearray(Wavetable)^[i]);
    end;
   end;
  end;
  if max<1e-5 then max:=1e-5;
//max:=max*1.4141;
  v:=1/max;
  for i:=0 to WavetableSize-1 do begin
   psinglearray(Wavetable)^[i]:=psinglearray(Wavetable)^[i]*v;
  end;
 end;
begin
 WavetableSize:=WavetableSize;
 GetMemAligned(freqamp,(WavetableSize div 2)*2*sizeof(single));
 GetMemAligned(freqphases,(WavetableSize div 2)*2*sizeof(single));
 FillChar(freqamp^,(WavetableSize div 2)*2*sizeof(single),#$00);
 FillChar(freqphases^,(WavetableSize div 2)*2*sizeof(single),#$00);
 bwhzt:=(power(2,Bandwidth*fCI1200)-1.0)*Frequency;
 sr2:=1/(2*SampleRate);
 sr:=1/SampleRate;
 WavetableSizeDiv:=1/(WavetableSize);
 NoiseSeed:=$12345678;
 Profile:=Profile and 3;
 for nh:=1 to NumHarmonics-1 do begin
  if ExtendedAlgorithm then begin
   bwhz:=bwhzt*power(relf(nh),BandwidthScale);
   fi:=Frequency*relf(nh)*sr;
  end else begin
   bwhz:=bwhzt*nh;
   fi:=Frequency*nh*sr;
  end;
  bwi:=bwhz*sr2;
  for i:=0 to (WavetableSize div 2)-1 do begin
   bp:=PadSynthProfiles[Profile]((i*WavetableSizeDiv)-fi,bwi);
   freqamp^[i]:=freqamp^[i]+(bp*Harmonics^[nh]);
   NoiseSeed:=((NoiseSeed*$524281)+$3133731) xor longword(pointer(@freqamp^[i])^);
  end;
 end;
 NoiseSeed:=NoiseSeed xor Seed;
 pi2:=pi*2;
 for i:=0 to (WavetableSize div 2)-1 do begin
  NoiseSeed:=(NoiseSeed*1664525)+1013904223; //NoiseSeed:=(NoiseSeed*$524281)+$3133731;
  NoiseValue:=((NoiseSeed shr 9) and $7fffff) or $40000000;
  NoiseValueFloatCasted:=NoiseValueFloatCasted-3;
  NoiseValue:=NoiseValue and $7ffffffff;
  freqphases[i]:=NoiseValueFloatCasted*pi2;
 end;
 IFFT;
 Normalize;
 FreeMemAligned(freqamp);
 FreeMemAligned(freqphases);
end;

procedure SynthInitSample(Track:PSynthTrack;Sample:PSynthSample);
var i:longint;
    d1,d2:psingles;
begin
 if assigned(Sample^.WorkData) then begin
  FreeMemAligned(Sample^.WorkData);
  Sample^.WorkData:=nil;
 end;
 if Sample^.PadSynth.Active and Sample^.PadSynth.ToGenerate and (Sample^.PadSynth.WaveTableSize>0) then begin
  Sample^.PadSynth.ToGenerate:=false;
  Sample^.PadSynth.WaveTableSize:=NextOfPowerTwo(Sample^.PadSynth.WaveTableSize);
  if assigned(Sample^.Data) then begin
   FreeMemAligned(Sample^.Data);
   Sample^.Data:=nil;
  end;
  if Sample^.PadSynth.Stereo then begin
   Sample^.Header.Channels:=2;
   Sample^.Header.Samples:=Sample^.PadSynth.WaveTableSize;
   Sample^.Header.SampleRate:=Sample^.PadSynth.SampleRate;
   GetMemZero(Sample^.Data,Sample^.PadSynth.WaveTableSize*4*sizeof(single));
   d1:=nil;
   d2:=nil;
   GetMemZero(d1,Sample^.PadSynth.WaveTableSize*2*sizeof(single));
   GetMemZero(d2,Sample^.PadSynth.WaveTableSize*2*sizeof(single));
   PadSynth($f2f4f6f8,pointer(d1),Sample^.PadSynth.WavetableSize,Sample^.PadSynth.SampleRate,Sample^.PadSynth.Profile,Sample^.PadSynth.Frequency,Sample^.PadSynth.BandWidth,Sample^.PadSynth.BandWidthScale,@Sample^.PadSynth.Harmonics,Sample^.PadSynth.NumHarmonics,Sample^.PadSynth.ExtendedAlgorithm);
   PadSynth($1f3f5f7f,pointer(d2),Sample^.PadSynth.WavetableSize,Sample^.PadSynth.SampleRate,Sample^.PadSynth.Profile,Sample^.PadSynth.Frequency,Sample^.PadSynth.BandWidth,Sample^.PadSynth.BandWidthScale,@Sample^.PadSynth.Harmonics,Sample^.PadSynth.NumHarmonics,Sample^.PadSynth.ExtendedAlgorithm);
   for i:=0 to Sample^.PadSynth.WaveTableSize-1 do begin
    PSynthBufferSamples(Sample^.Data)^[i].Left:=d1^[i];
    PSynthBufferSamples(Sample^.Data)^[i].Right:=d2^[i];
   end;
   FreeMemAligned(d1);
   FreeMemAligned(d2);
  end else begin
   Sample^.Header.Channels:=1;
   Sample^.Header.Samples:=Sample^.PadSynth.WaveTableSize;
   Sample^.Header.SampleRate:=Sample^.PadSynth.SampleRate;
   GetMemZero(Sample^.Data,Sample^.PadSynth.WaveTableSize*2*sizeof(single));
{$ifdef BR808SAMPLES}
   PadSynth($c001c0d3,pointer(Sample^.Data),Sample^.PadSynth.WavetableSize,Sample^.PadSynth.SampleRate,Sample^.PadSynth.Profile,Sample^.PadSynth.Frequency,Sample^.PadSynth.BandWidth,Sample^.PadSynth.BandWidthScale,@Sample^.PadSynth.Harmonics,Sample^.PadSynth.NumHarmonics,Sample^.PadSynth.ExtendedAlgorithm);
{$endif}
  end;
 end;
 if assigned(Sample^.Data) and (Sample^.Header.Samples>0) then begin
  GetMemAligned(Sample^.WorkData,((Sample^.Header.Samples*Sample^.Header.Channels)+(SampleFixUp*2))*sizeof(single));
  Move(Sample^.Data^,psingles(Sample^.WorkData)^[SampleFixUp],Sample^.Header.Samples*Sample^.Header.Channels*sizeof(single));
  if Sample^.Header.Channels=2 then begin
   for i:=0 to (SampleFixUp shr 1)-1 do begin
    psingles(Sample^.WorkData)^[SampleFixUp-((i+1)*2)]:=psingles(Sample^.WorkData)^[SampleFixUp];
    psingles(Sample^.WorkData)^[SampleFixUp-(((i+1)*2)-1)]:=psingles(Sample^.WorkData)^[SampleFixUp+1];
    psingles(Sample^.WorkData)^[SampleFixUp+(Sample^.Header.Samples*2)+(i*2)]:=psingles(Sample^.WorkData)^[SampleFixUp+(Sample^.Header.Samples*2)-2];
    psingles(Sample^.WorkData)^[SampleFixUp+(Sample^.Header.Samples*2)+((i*2)+1)]:=psingles(Sample^.WorkData)^[SampleFixUp+(Sample^.Header.Samples*2)-1];
   end;
  end else begin
   for i:=0 to SampleFixUp-1 do begin
    psingles(Sample^.WorkData)^[i]:=psingles(Sample^.WorkData)^[SampleFixUp];
    psingles(Sample^.WorkData)^[SampleFixUp+Sample^.Header.Samples+i]:=psingles(Sample^.WorkData)^[SampleFixUp+Sample^.Header.Samples-1];
   end;
  end;
  if Sample^.Header.Loop.StartSample<0 then begin
   Sample^.Header.Loop.StartSample:=0;
  end else if Sample^.Header.Loop.StartSample>=Sample^.Header.Samples then begin
   Sample^.Header.Loop.StartSample:=Sample^.Header.Samples-1;
  end;
  if Sample^.Header.Loop.EndSample<0 then begin
   Sample^.Header.Loop.EndSample:=0;
  end else if Sample^.Header.Loop.EndSample>=Sample^.Header.Samples then begin
   Sample^.Header.Loop.EndSample:=Sample^.Header.Samples-1;
  end;
  if Sample^.Header.Loop.StartSample>Sample^.Header.Loop.EndSample then begin
   Sample^.Header.Loop.Mode:=slNONE;
  end;
  if Sample^.Header.SustainLoop.StartSample<0 then begin
   Sample^.Header.SustainLoop.StartSample:=0;
  end else if Sample^.Header.SustainLoop.StartSample>=Sample^.Header.Samples then begin
   Sample^.Header.SustainLoop.StartSample:=Sample^.Header.Samples-1;
  end;
  if Sample^.Header.SustainLoop.EndSample<0 then begin
   Sample^.Header.SustainLoop.EndSample:=0;
  end else if Sample^.Header.SustainLoop.EndSample>=Sample^.Header.Samples then begin
   Sample^.Header.SustainLoop.EndSample:=Sample^.Header.Samples-1;
  end;
  if Sample^.Header.SustainLoop.StartSample>Sample^.Header.SustainLoop.EndSample then begin
   Sample^.Header.SustainLoop.Mode:=slNONE;
  end;
  if Sample^.Header.Channels=2 then begin
   case Sample^.Header.Loop.Mode of
    slFORWARD,slBACKWARD:begin
     for i:=0 to SampleFixUp-1 do begin
      PSynthBufferSamples(@psingles(Sample^.WorkData)^[SampleFixUp])^[Sample^.Header.Loop.EndSample+i]:=PSynthBufferSamples(@psingles(Sample^.WorkData)^[SampleFixUp])^[Sample^.Header.Loop.StartSample+i];
     end;
    end;
   end;
   case Sample^.Header.SustainLoop.Mode of
    slFORWARD,slBACKWARD:begin
     for i:=0 to SampleFixUp-1 do begin
      PSynthBufferSamples(@psingles(Sample^.WorkData)^[SampleFixUp])^[Sample^.Header.SustainLoop.EndSample+i]:=PSynthBufferSamples(@psingles(Sample^.WorkData)^[SampleFixUp])^[Sample^.Header.SustainLoop.StartSample+i];
     end;
    end;
   end;
  end else begin
   case Sample^.Header.Loop.Mode of
    slFORWARD,slBACKWARD:begin
     for i:=0 to SampleFixUp-1 do begin
      psingles(Sample^.WorkData)^[Sample^.Header.Loop.EndSample+i+SampleFixUp]:=psingles(Sample^.WorkData)^[Sample^.Header.Loop.StartSample+i+SampleFixUp];
     end;
    end;
   end;
   case Sample^.Header.SustainLoop.Mode of
    slFORWARD,slBACKWARD:begin
     for i:=0 to SampleFixUp-1 do begin
      psingles(Sample^.WorkData)^[Sample^.Header.SustainLoop.EndSample+i+SampleFixUp]:=psingles(Sample^.WorkData)^[Sample^.Header.SustainLoop.StartSample+i+SampleFixUp];
     end;
    end;
   end;
  end;
 end;
end;

procedure SynthInitSamples(Track:PSynthTrack);
var i,j:longint;
begin
 for i:=0 to MaxInstruments-1 do begin
  for j:=0 to MaxSamples-1 do begin
   SynthInitSample(Track,@Track^.Samples[i,j]);
  end;
 end;
end;

procedure SynthInitTuningTables(Track:PSynthTrack);
var i,j,k:longint;
begin
 for i:=low(Track^.TuningTables) to high(Track^.TuningTables) do begin
  for j:=low(Track^.TuningTables[i]) to high(Track^.TuningTables[i]) do begin
   for k:=low(Track^.TuningTables[i,j]) to high(Track^.TuningTables[i,j]) do begin
    Track^.TuningTables[i,j,k]:=k;
   end;
  end;
 end;
end;

procedure SynthInitChorusSINCTable(Track:PSynthTrack);
var i,j:longint;
    iv:double;
begin
 for i:=0 to CHORUS_INTERPOLATION_SAMPLES-1 do begin
  for j:=0 to CHORUS_INTERPOLATION_SUBSAMPLES-1 do begin
   iv:=(i-(CHORUS_INTERPOLATION_SAMPLES*0.5))+(j/CHORUS_INTERPOLATION_SUBSAMPLES);
   if abs(iv)<0.000001 then begin
    Track^.ChorusSINCTable[i,j]:=1;
   end else begin
    Track^.ChorusSINCTable[i,j]:=(sin(iv*pi)/(iv*pi))*(0.5*(1+cos(2*pi*iv/CHORUS_INTERPOLATION_SAMPLES)));
   end;
  end;
 end;
end;

procedure SynthInitSINC(Track:PSynthTrack);
VAR FracValue,SincValue,WindowValue{,WindowFactor},WindowParameter,
    OtherPosition,HalfPoints,Position,a,beta,i0beta:double;
    Counter,SubCounter,Points{,ThePoints},Len:longint;
BEGIN
 Points:=SINC16_WIDTH;
 Len:=SINC16_LUTLEN;
//ThePoints:=Points;
 HalfPoints:=Points*0.5;
//WindowFactor:=(2*PIValue)/ThePoints;
 a:=-20*log10(1/(1 shl 24)); // 24 bits -> -144dB stopband attenuation
 if a>50 then begin
  beta:=0.1102*(a-8.7);
 end else if a>=21 then begin
  beta:=(0.5842*power(a-21,0.4))+(0.07886*(a-21));
 end else begin
  beta:=0;
 end;
 i0beta:=i0(beta);
 for Counter:=0 to Len-1 do begin
  FracValue:=(Counter/Len)-0.5;
  for SubCounter:=0 to Points-1 do begin
   OtherPosition:=SubCounter-FracValue;
   Position:=OtherPosition-HalfPoints;
   if abs(Position)<EPSILON then begin
    SincValue:=SINC_CUTOFF;
   end else begin
    SincValue:=sin(SINC_CUTOFF*Position*PIValue)/(Position*PIValue);
   end;
   WindowParameter:=Position/HalfPoints;
   if abs(WindowParameter)<1 then begin
    WindowValue:=i0(beta*sqrt(1-sqr(WindowParameter)))/i0beta;
   end else begin
    WindowValue:=0;//i0(0)/i0beta;
   end;
{  WindowParameter:=OtherPosition*WindowFactor;
   WindowValue:=0.42-(0.50*cos(WindowParameter))+(0.08*cos(2.0*WindowParameter));}
   Track^.SINCTable[Counter,SubCounter]:=SincValue*WindowValue;
  end;
 end;
end;

procedure SynthInitPitchShifterFadeBuffer(Track:PSynthTrack); {$ifdef cpu386}register;{$endif}
var i:longint;
begin
 for i:=0 to PitchBufferSize-1 do begin
  Track^.PitchShifterFadeBuffer[i]:=0.5+(0.5*cos(((i/(PitchBufferSize-1))-0.5)*2*3.141592));
 end;
end;

function SynthCreate(SampleRate,BufferSamples:longint;ThreadPlay:longbool=true;SoundOutput:longbool=true):PSynthTrack; {$ifdef csdk}stdcall; [public,alias:'_SynthCreate@16'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 GetMemAligned(result,sizeof(TSynthTrack));
 SynthInit(result,SampleRate,BufferSamples,ThreadPlay,SoundOutput);
end;

procedure SynthDestroy(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthDestroy@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 SynthDone(Track);
 FreeMemAligned(Track);
end;

{$ifdef VSTi}
procedure SynthConvertOldToNewUnits(Track:PSynthTrack);
var i,j:longint;
 function Clip(x,min,max:longint):longint;
 begin
  if x<min then begin
   result:=min;
  end else if x>max then begin
   result:=max;
  end else begin
   result:=x;
  end;
 end;
 procedure DoReverb(var Reverb:TSynthReverb);
 begin
  Reverb.CombFilterSeparation:=Clip(Reverb.CombFilterSeparation*2,0,255);
  Reverb.RoomSize:=Clip(Reverb.RoomSize*2,0,255);
  Reverb.FeedBack:=Clip(Reverb.FeedBack*2,0,255);
  Reverb.Absortion:=Clip(Reverb.Absortion*2,0,255);
  Reverb.Wet:=Clip(Reverb.Wet*2,0,255);
  Reverb.Dry:=Clip(Reverb.Dry*2,0,255);
 end;
 procedure DoDelay(var Delay:TSynthDelay);
 begin
  Delay.Wet:=Clip(Delay.Wet*2,0,255);
  Delay.Dry:=Clip(Delay.Dry*2,0,255);
 end;
 procedure DoChorusFlanger(var ChorusFlanger:TSynthChorusFlanger);
 begin
  ChorusFlanger.Wet:=Clip(ChorusFlanger.Wet*2,0,255);
  ChorusFlanger.Dry:=Clip(ChorusFlanger.Dry*2,0,255);
  ChorusFlanger.TimeLeft:=Clip(ChorusFlanger.TimeLeft*2,0,255);
  ChorusFlanger.TimeRight:=Clip(ChorusFlanger.TimeRight*2,0,255);
  ChorusFlanger.FeedBackLeft:=Clip(ChorusFlanger.FeedBackLeft*2,-128,127);
  ChorusFlanger.FeedBackRight:=Clip(ChorusFlanger.FeedBackRight*2,-128,127);
  ChorusFlanger.LFORateLeft:=Clip(ChorusFlanger.LFORateLeft*2,0,255);
  ChorusFlanger.LFORateRight:=Clip(ChorusFlanger.LFORateRight*2,0,255);
  ChorusFlanger.LFODepthLeft:=Clip(ChorusFlanger.LFODepthLeft*2,0,255);
  ChorusFlanger.LFODepthRight:=Clip(ChorusFlanger.LFODepthRight*2,0,255);
  ChorusFlanger.LFOPhaseLeft:=Clip(ChorusFlanger.LFOPhaseLeft*2,0,255);
  ChorusFlanger.LFOPhaseRight:=Clip(ChorusFlanger.LFOPhaseRight*2,0,255);
 end;
 procedure DoPitchShifter(var PitchShifter:TSynthPitchShifter);
 begin
  PitchShifter.Tune:=Clip(PitchShifter.Tune-64,-128,127);
  PitchShifter.FineTune:=Clip(PitchShifter.FineTune-64,-128,127);
 end;
begin
 DoReverb(Track^.Global.Reverb);
 DoDelay(Track^.Global.Delay);
 DoChorusFlanger(Track^.Global.ChorusFlanger);
 DoPitchShifter(Track^.Global.PitchShifter);
 for i:=low(Track^.Instruments) to high(Track^.Instruments) do begin
  Track^.Instruments[i].Volume:=Clip(Track^.Instruments[i].Volume*2,0,255);
  Track^.Instruments[i].ChannelVolume:=Clip(Track^.Instruments[i].ChannelVolume*2,0,255);
  Track^.Instruments[i].GlobalOutput:=Clip(Track^.Instruments[i].GlobalOutput*2,0,255);
  Track^.Instruments[i].GlobalReverb:=Clip(Track^.Instruments[i].GlobalReverb*2,0,255);
  Track^.Instruments[i].GlobalDelay:=Clip(Track^.Instruments[i].GlobalDelay*2,0,255);
  Track^.Instruments[i].GlobalChorusFlanger:=Clip(Track^.Instruments[i].GlobalChorusFlanger*2,0,255);
  for j:=low(Track^.Instruments[i].Oscillator) to high(Track^.Instruments[i].Oscillator) do begin
   Track^.Instruments[i].Oscillator[j].FineTune:=Clip(((Track^.Instruments[i].Oscillator[j].FineTune*100)+32) div 64,-128,127);
   Track^.Instruments[i].Oscillator[j].FeedBack:=Clip(Track^.Instruments[i].Oscillator[j].FeedBack*2,-256,256);
   Track^.Instruments[i].Oscillator[j].PhaseStart:=Clip(Track^.Instruments[i].Oscillator[j].PhaseStart*2,0,255);
   Track^.Instruments[i].Oscillator[j].Volume:=Clip(Track^.Instruments[i].Oscillator[j].Volume*2,0,255);
   Track^.Instruments[i].Oscillator[j].Glide:=Clip(Track^.Instruments[i].Oscillator[j].Glide*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].ADSR) to high(Track^.Instruments[i].ADSR) do begin
   Track^.Instruments[i].ADSR[j].Times[1]:=Clip(Track^.Instruments[i].ADSR[j].Times[1]*2,0,255);
   Track^.Instruments[i].ADSR[j].Times[2]:=Clip(Track^.Instruments[i].ADSR[j].Times[2]*2,0,255);
   Track^.Instruments[i].ADSR[j].Times[3]:=Clip(Track^.Instruments[i].ADSR[j].Times[3]*2,0,255);
   Track^.Instruments[i].ADSR[j].Times[4]:=Clip(Track^.Instruments[i].ADSR[j].Times[4]*2,0,255);
   Track^.Instruments[i].ADSR[j].TargetDecayLevel:=Clip(Track^.Instruments[i].ADSR[j].TargetDecayLevel*2,0,255);
   Track^.Instruments[i].ADSR[j].Amplify:=Clip(Track^.Instruments[i].ADSR[j].Amplify*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].Envelope) to high(Track^.Instruments[i].Envelope) do begin
   Track^.Instruments[i].Envelope[j].Amplify:=Clip(Track^.Instruments[i].Envelope[j].Amplify*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].LFO) to high(Track^.Instruments[i].LFO) do begin
   Track^.Instruments[i].LFO[j].Rate:=Clip(Track^.Instruments[i].LFO[j].Rate*2,0,255);
   Track^.Instruments[i].LFO[j].Depth:=Clip(Track^.Instruments[i].LFO[j].Depth*2,0,255);
   Track^.Instruments[i].LFO[j].Middle:=Clip(Track^.Instruments[i].LFO[j].Middle*2,-128,127);
   Track^.Instruments[i].LFO[j].Sweep:=Clip(Track^.Instruments[i].LFO[j].Sweep*2,0,255);
   Track^.Instruments[i].LFO[j].PhaseStart:=Clip(Track^.Instruments[i].LFO[j].PhaseStart*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].Filter) to high(Track^.Instruments[i].Filter) do begin
   Track^.Instruments[i].Filter[j].CutOff:=Clip(Track^.Instruments[i].Filter[j].CutOff*2,0,255);
   Track^.Instruments[i].Filter[j].Resonance:=Clip(Track^.Instruments[i].Filter[j].Resonance*2,0,255);
   Track^.Instruments[i].Filter[j].Volume:=Clip(Track^.Instruments[i].Filter[j].Volume*2,0,255);
   Track^.Instruments[i].Filter[j].Amplify:=Clip(Track^.Instruments[i].Filter[j].Amplify*2,-128,127);
   if (Track^.Instruments[i].Filter[j].MinHz=0) and (Track^.Instruments[i].Filter[j].MaxHz=0) then begin
    Track^.Instruments[i].Filter[j].MinHz:=12;
    Track^.Instruments[i].Filter[j].MaxHz:=12000;
   end;
  end;
  for j:=low(Track^.Instruments[i].VoiceDistortion) to high(Track^.Instruments[i].VoiceDistortion) do begin
   Track^.Instruments[i].VoiceDistortion[j].Gain:=Clip(Track^.Instruments[i].VoiceDistortion[j].Gain*2,0,255);
   Track^.Instruments[i].VoiceDistortion[j].Dist:=Clip(Track^.Instruments[i].VoiceDistortion[j].Dist*2,0,255);
   Track^.Instruments[i].VoiceDistortion[j].Rate:=Clip(Track^.Instruments[i].VoiceDistortion[j].Rate*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].ChannelDistortion) to high(Track^.Instruments[i].ChannelDistortion) do begin
   Track^.Instruments[i].ChannelDistortion[j].Gain:=Clip(Track^.Instruments[i].ChannelDistortion[j].Gain*2,0,255);
   Track^.Instruments[i].ChannelDistortion[j].Dist:=Clip(Track^.Instruments[i].ChannelDistortion[j].Dist*2,0,255);
   Track^.Instruments[i].ChannelDistortion[j].Rate:=Clip(Track^.Instruments[i].ChannelDistortion[j].Rate*2,0,255);
  end;
  for j:=low(Track^.Instruments[i].ChannelFilter) to high(Track^.Instruments[i].ChannelFilter) do begin
   Track^.Instruments[i].ChannelFilter[i].CutOff:=Clip(Track^.Instruments[i].ChannelFilter[i].CutOff*2,0,255);
   Track^.Instruments[i].ChannelFilter[i].Resonance:=Clip(Track^.Instruments[i].ChannelFilter[i].Resonance*2,0,255);
   Track^.Instruments[i].ChannelFilter[i].Volume:=Clip(Track^.Instruments[i].ChannelFilter[i].Volume*2,0,255);
   Track^.Instruments[i].ChannelFilter[i].Amplify:=Clip(Track^.Instruments[i].ChannelFilter[i].Amplify*2,-128,127);
   if (Track^.Instruments[i].ChannelFilter[i].MinHz=0) and (Track^.Instruments[i].ChannelFilter[i].MaxHz=0) then begin
    Track^.Instruments[i].ChannelFilter[i].MinHz:=12;
    Track^.Instruments[i].ChannelFilter[i].MaxHz:=12000;
   end;
  end;
  for j:=low(Track^.Instruments[i].ChannelDelay) to high(Track^.Instruments[i].ChannelDelay) do begin
   DoDelay(Track^.Instruments[i].ChannelDelay[j]);
  end;
  DoChorusFlanger(Track^.Instruments[i].ChannelChorusFlanger);
  Track^.Instruments[i].ChannelSpeech.NoiseGain:=Clip(Track^.Instruments[i].ChannelSpeech.NoiseGain*2,0,255);
  Track^.Instruments[i].ChannelSpeech.Gain:=Clip(Track^.Instruments[i].ChannelSpeech.Gain*2,0,255);
  Track^.Instruments[i].ChannelSpeech.CascadeGain:=Clip(Track^.Instruments[i].ChannelSpeech.CascadeGain*2,0,255);
  Track^.Instruments[i].ChannelSpeech.ParallelGain:=Clip(Track^.Instruments[i].ChannelSpeech.ParallelGain*2,0,255);
  Track^.Instruments[i].ChannelSpeech.AspirationGain:=Clip(Track^.Instruments[i].ChannelSpeech.AspirationGain*2,0,255);
  Track^.Instruments[i].ChannelSpeech.FricationGain:=Clip(Track^.Instruments[i].ChannelSpeech.FricationGain*2,0,255);
  DoPitchShifter(Track^.Instruments[i].ChannelPitchShifter);
 end;
end;
{$endif}

{procedure SynthAllPassInit(var Instance:TSynthAllPass;Coefficient:single);
begin
 Instance.a:=coefficient;
 Instance.x0:=0;
 Instance.x1:=0;
 Instance.x2:=0;
 Instance.y0:=0;
 Instance.y1:=0;
 Instance.y2:=0;
end;

function SynthAllPassProcess(var Instance:TSynthAllPass;Input:single):single;
begin
 Instance.x2:=Instance.x1;
 Instance.x1:=Instance.x0;
 Instance.x0:=Input;
 Instance.y2:=Instance.y1;
 Instance.y1:=Instance.y0;
 result:=((Instance.x2+((Input-Instance.y2)*Instance.a))+FixDenormalValue)-FixDenormalValue;
 Instance.y0:=result;
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthAllPassFilterCascadeInit(var Instance:TSynthAllPassFilterCascade;Coefficients:psingle;Order:longint);
var i:longint;
begin
 Instance.Order:=Order;
 for i:=0 to Order-1 do begin
  SynthAllPassInit(Instance.AllPassFilters[i],Coefficients^);
  inc(Coefficients);
 end;
end;

function SynthAllPassFilterCascadeProcess(var Instance:TSynthAllPassFilterCascade;Input:single):single;
var i:longint;
begin
 result:=(Input+FixDenormalValue)-FixDenormalValue;
 for i:=0 to Instance.Order-1 do begin
  result:=(SynthAllPassProcess(Instance.AllPassFilters[i],result)+FixDenormalValue)-FixDenormalValue;
 end;
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
end;

procedure SynthHalfBandFilterInit(var Instance:TSynthHalfBandFilter;Order:longint;Steep:boolean);
begin
 if Steep then begin
  if Order=12 then begin // rejection=104dB, transition band=0.01
   Instance.aCoeffs[0]:=0.036681502163648017;
   Instance.aCoeffs[1]:=0.2746317593794541;
   Instance.aCoeffs[2]:=0.56109896978791948;
   Instance.aCoeffs[3]:=0.769741833862266;
   Instance.aCoeffs[4]:=0.8922608180038789;
   Instance.aCoeffs[5]:=0.962094548378084;
   Instance.bCoeffs[0]:=0.13654762463195771;
   Instance.bCoeffs[1]:=0.42313861743656667;
   Instance.bCoeffs[2]:=0.6775400499741616;
   Instance.bCoeffs[3]:=0.839889624849638;
   Instance.bCoeffs[4]:=0.9315419599631839;
   Instance.bCoeffs[5]:=0.9878163707328971;
  end else if Order=10 then begin // rejection=86dB, transition band=0.01
   Instance.aCoeffs[0]:=0.051457617441190984;
   Instance.aCoeffs[1]:=0.35978656070567017;
   Instance.aCoeffs[2]:=0.6725475931034693;
   Instance.aCoeffs[3]:=0.8590884928249939;
   Instance.aCoeffs[4]:=0.9540209867860787;
   Instance.bCoeffs[0]:=0.18621906251989334;
   Instance.bCoeffs[1]:=0.529951372847964;
   Instance.bCoeffs[2]:=0.7810257527489514;
   Instance.bCoeffs[3]:=0.9141815687605308;
   Instance.bCoeffs[4]:=0.985475023014907;
  end else if Order=8 then begin // rejection=69dB, transition band=0.01
   Instance.aCoeffs[0]:=0.07711507983241622;
   Instance.aCoeffs[1]:=0.4820706250610472;
   Instance.aCoeffs[2]:=0.7968204713315797;
   Instance.aCoeffs[3]:=0.9412514277740471;
   Instance.bCoeffs[0]:=0.2659685265210946;
   Instance.bCoeffs[1]:=0.6651041532634957;
   Instance.bCoeffs[2]:=0.8841015085506159;
   Instance.bCoeffs[3]:=0.9820054141886075;
  end else if Order=6 then begin  // rejection=51dB, transition band=0.01
   Instance.aCoeffs[0]:=0.1271414136264853;
   Instance.aCoeffs[1]:=0.6528245886369117;
   Instance.aCoeffs[2]:=0.9176942834328115;
   Instance.bCoeffs[0]:=0.40056789819445626;
   Instance.bCoeffs[1]:=0.8204163891923343;
   Instance.bCoeffs[2]:=0.9763114515836773;
  end else if Order=4 then begin // rejection=53dB,transition band=0.05
   Instance.aCoeffs[0]:=0.12073211751675449;
   Instance.aCoeffs[1]:=0.6632020224193995;
   Instance.bCoeffs[0]:=0.3903621872345006;
   Instance.bCoeffs[1]:=0.890786832653497;
  end else begin // order=2, rejection=36dB, transition band=0.1
   Instance.aCoeffs[0]:=0.23647102099689224;
   Instance.bCoeffs[0]:=0.7145421497126001;
  end;
 end else begin // softer slopes, more attenuation and less stopband ripple
  if Order=12 then begin //rejection=104dB, transition band=0.01
   Instance.aCoeffs[0]:=0.01677466677723562;
   Instance.aCoeffs[1]:=0.13902148819717805;
   Instance.aCoeffs[2]:=0.3325011117394731;
   Instance.aCoeffs[3]:=0.53766105314488;
   Instance.aCoeffs[4]:=0.7214184024215805;
   Instance.aCoeffs[5]:=0.8821858402078155;
   Instance.bCoeffs[0]:=0.06501319274445962;
   Instance.bCoeffs[1]:=0.23094129990840923;
   Instance.bCoeffs[2]:=0.4364942348420355;
   Instance.bCoeffs[3]:=0.6329609551399348;
   Instance.bCoeffs[4]:=0.80378086794111226;
   Instance.bCoeffs[5]:=0.9599687404800694;
  end else if Order=10 then begin // rejection=86dB, transition band=0.01
   Instance.aCoeffs[0]:=0.02366831419883467;
   Instance.aCoeffs[1]:=0.18989476227180174;
   Instance.aCoeffs[2]:=0.43157318062118555;
   Instance.aCoeffs[3]:=0.6632020224193995;
   Instance.aCoeffs[4]:=0.860015542499582;
   Instance.bCoeffs[0]:=0.09056555904993387;
   Instance.bCoeffs[1]:=0.3078575723749043;
   Instance.bCoeffs[2]:=0.5516782402507934;
   Instance.bCoeffs[3]:=0.7652146863779808;
   Instance.bCoeffs[4]:=0.95247728378667541;
  end else if Order=8 then begin // rejection=69dB, transition band=0.01
   Instance.aCoeffs[0]:=0.03583278843106211;
   Instance.aCoeffs[1]:=0.2720401433964576;
   Instance.aCoeffs[2]:=0.5720571972357003;
   Instance.aCoeffs[3]:=0.827124761997324;
   Instance.bCoeffs[0]:=0.1340901419430669;
   Instance.bCoeffs[1]:=0.4243248712718685;
   Instance.bCoeffs[2]:=0.7062921421386394;
   Instance.bCoeffs[3]:=0.9415030941737551;
  end else if Order=6 then begin // rejection=51dB, transition band=0.01
   Instance.aCoeffs[0]:=0.06029739095712437;
   Instance.aCoeffs[1]:=0.4125907203610563;
   Instance.aCoeffs[2]:=0.7727156537429234;
   Instance.bCoeffs[0]:=0.21597144456092948;
   Instance.bCoeffs[1]:=0.6043586264658363;
   Instance.bCoeffs[2]:=0.9238861386532906;
  end else if Order=4 then begin // rejection=53dB,transition band=0.05
   Instance.aCoeffs[0]:=0.07986642623635751;
   Instance.aCoeffs[1]:=0.5453536510711322;
   Instance.bCoeffs[0]:=0.28382934487410993;
   Instance.bCoeffs[1]:=0.8344118914807379;
  end else begin // order=2, rejection=36dB, transition band=0.1
   Instance.aCoeffs[0]:=0.23647102099689224;
   Instance.bCoeffs[0]:=0.7145421497126001;
  end;
 end;
 SynthAllPassFilterCascadeInit(Instance.FilterA,@Instance.aCoeffs[0],Order div 2);
 SynthAllPassFilterCascadeInit(Instance.FilterB,@Instance.bCoeffs[0],Order div 2);
 Instance.Last:=0;
end;

function SynthHalfBandFilterProcess(var Instance:TSynthHalfBandFilter;Input:single):single;
begin
 result:=(SynthAllPassFilterCascadeProcess(Instance.FilterA,Input)+Instance.Last)*0.5;
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 Instance.Last:=SynthAllPassFilterCascadeProcess(Instance.FilterB,Input);
end;}

procedure SynthButterworthFilterCalculateCoefficients(var Instance:TSynthButterworthFilter;Order,SampleRate:longint;Frequency:double);
type PComplex=^TComplex;
     TComplex=record
      Re,Im:double;
     end;
 procedure ComplexMultiply2Inplace64(var a:TComplex;const b:TComplex);
 var c,d:double;
 begin
  c:=sqr(b.Re)-sqr(b.Im);
  d:=a.Re;
  a.Re:=(a.Re*c)-(2*(a.Im*(b.Im*b.Re)));
  a.Im:=(a.Im*c)+(2*(d*(b.Im*b.Re)));
 end;
var i:longint;
    k,k2,t,a,w0,TanW0,PIHalfOrderInv:double;
    c,d:TComplex;
begin
 Instance.Order:=Order;
 if Instance.Order<>0 then begin
  Instance.OrderInv:=1/Instance.Order;
  PIHalfOrderInv:=(pi*0.5)/Instance.Order;
  d.Im:=sin(PIHalfOrderInv);
  d.Re:=cos(PIHalfOrderInv);
  Instance.Gain:=1;
  w0:=(2*pi*Frequency)/SampleRate;
  TanW0:=tan(w0*0.5);
  k:=TanW0;
  k2:=k*k;
  c:=d;
  i:=0;
  while i<(Instance.Order-1) do begin
// a:=2*sin((i+1)*PIHalfOrderInv)*k;
   a:=2*c.Im*k;
   ComplexMultiply2Inplace64(c,d);
   t:=1/(k2+a+1);
   Instance.Gain:=Instance.Gain*t*k2;
   Instance.Coefs[i]:=2*((1-k2)*t);
   Instance.Coefs[i+1]:=((a-1)-k2)*t;
   inc(i,2);
  end;
  if i<Instance.Order then begin
   t:=1/(1+k);
   Instance.Gain:=Instance.Gain*t*k;
   Instance.Coefs[i]:=(1-k)*t;
  end;
  for i:=0 to Instance.Order-1 do begin
   Instance.State[i]:=0;
  end;
 end;
end;

function SynthButterworthFilterProcess(var Instance:TSynthButterworthFilter;Input:double):double;
var i:longint;
begin
 result:=Instance.Gain*(Input+(1e-34));
 for i:=0 to (Instance.Order shr 1)-1 do begin
  Input:=result;
  result:=Input+Instance.State[i*2];
{ if ((longword(int64(pointer(@result)^) shr 32)+$100000) and $7ff00000)<=$100000 then begin
   result:=0;
  end;}
  Instance.State[i*2]:=((Input*2)+(Instance.Coefs[i*2]*result))+Instance.State[(i*2)+1];
  Instance.State[(i*2)+1]:=Input+(Instance.Coefs[(i*2)+1]*result);
 end;
 if (Instance.Order and 1)<>0 then begin
  i:=((Instance.Order+1) shr 1)-1;
{ if ((longword(int64(pointer(@result)^) shr 32)+$100000) and $7ff00000)<=$100000 then begin
   result:=0;
  end;}
  Input:=result;
  result:=Input+Instance.State[i*2];
  Instance.State[i*2]:=Input+(Instance.Coefs[i*2]*result);
 end;
end;

procedure SynthOversamplerInit(var Instance:TSynthOversampler;Order,SampleRate,Factor:longint);
const TransitionBandwidth=0.99;
begin
 Instance.Factor:=Factor;
 SynthButterworthFilterCalculateCoefficients(Instance.UpFilter,Order,SampleRate*Factor,(SampleRate*0.5)*TransitionBandwidth);
 SynthButterworthFilterCalculateCoefficients(Instance.DownFilter,Order,SampleRate*Factor,(SampleRate*0.5)*TransitionBandwidth);
{SynthHalfBandFilterInit(Instance.DownHalfBand,12,true);
 SynthHalfBandFilterInit(Instance.UpHalfBand,12,true);}
end;

function SynthOversamplerProcess(var Instance:TSynthOversampler;Input:single):single;
const FixDenormal:double=1e-34;
var i:longint;
begin
{result:=SynthHalfBandFilterProcess(Instance.DownHalfBand,SynthHalfBandFilterProcess(Instance.UpHalfBand,Input));
 SynthHalfBandFilterProcess(Instance.DownHalfBand,SynthHalfBandFilterProcess(Instance.UpHalfBand,0));}
 Instance.Buffer[0]:=SynthButterworthFilterProcess(Instance.UpFilter,Input+FixDenormal);
 for i:=1 to Instance.Factor-1 do begin
  Instance.Buffer[i]:=SynthButterworthFilterProcess(Instance.UpFilter,-FixDenormal);
 end;
 result:=SynthButterworthFilterProcess(Instance.DownFilter,Instance.Buffer[0]+FixDenormal);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 for i:=1 to Instance.Factor-1 do begin
  SynthButterworthFilterProcess(Instance.DownFilter,Instance.Buffer[i]);
 end;
end;

function SynthOversamplerProcessDown(var Instance:TSynthOversampler;Input:PSynthBufferSample;Channel:longint):single;
const FixDenormal:double=1e-34;
var i:longint;
begin
 result:=SynthButterworthFilterProcess(Instance.DownFilter,Input^.Channel[Channel]+FixDenormal);
 longword(pointer(@result)^):=longword(pointer(@result)^) and longword($ffffffff+longword(((((longword(pointer(@result)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 inc(Input);
 for i:=1 to Instance.Factor-1 do begin
  SynthButterworthFilterProcess(Instance.DownFilter,Input^.Channel[Channel]+FixDenormal);
  inc(Input);
 end;
end;

procedure SynthInitBandlimitedWavetables(Track:PSynthTrack);
const spi3=(pi*pi)/3.0;
      pi0d5=pi*0.5;
 procedure Normalize(var t:TBandlimitedWaveTables);
 var i,j:longint;
     MaxPeak,Factor:single;
 begin
  MaxPeak:=1e-10;
  for i:=low(TBandlimitedWaveTables) to high(TBandlimitedWaveTables) do begin
   for j:=low(TBandlimitedWaveTable) to high(TBandlimitedWaveTable) do begin
    if MaxPeak<abs(t[i,j]) then begin
     MaxPeak:=abs(t[i,j]);
    end;
   end;
  end;
  Factor:=1/(MaxPeak*0.5);
  for i:=low(TBandlimitedWaveTables) to high(TBandlimitedWaveTables) do begin
   for j:=low(TBandlimitedWaveTable) to high(TBandlimitedWaveTable) do begin
    t[i,j]:=Clip((t[i,j]*Factor)-1.0,-1.0,1.0);
   end;
  end;
 end;
var Note,i,j,Partial,Partials,LastPartials,Sign:longint;
    InvSize,m,n,ip:single;
begin
 i:=0;
 for Note:=low(TBandlimitedWaveTables) to high(TBandlimitedWaveTables) do begin
  j:=SoftTRUNC(power(2,(Note-69)/12)*880);
  while i<=j do begin
   Track^.BandlimitedMap[i]:=Note;
   inc(i);
  end;
 end;
 while i<=high(TBandlimitedMap) do begin
  Track^.BandlimitedMap[i]:=high(TBandlimitedWaveTables);
  inc(i);
 end;
 InvSize:=1/BANDLIMITED_WAVETABLE_SIZE;
 LastPartials:=-1;
 for i:=0 to (BANDLIMITED_WAVETABLE_SIZE*2)-1 do begin
  Track^.BandlimitedDoubleSineLUT[i]:=sin(i*pi*InvSize);
 end;
 for i:=0 to BANDLIMITED_WAVETABLE_SIZE-1 do begin
  Track^.BandlimitedSineLUT[i]:=Track^.BandlimitedDoubleSineLUT[i*2];
 end;
 for Note:=low(TBandlimitedWaveTables) to high(TBandlimitedWaveTables) do begin
  Partials:=round((Track^.InternalSampleRate*0.5)/(440*power(2,(Note-69)/12)));
  if (LastPartials<>Partials) or (Note=low(TBandlimitedWaveTables)) then begin
   for i:=0 to BANDLIMITED_WAVETABLE_SIZE-1 do begin
    Track^.BandlimitedSaw[Note,i]:=0;
    Track^.BandlimitedParabola[Note,i]:=spi3;
   end;
   LastPartials:=Partials;                                    
   Sign:=-1;
   if Partials>0 then begin
    ip:=1/Partials;
    for Partial:=1 to Partials do begin
     n:=sqr(cos(((Partial-1)*pi0d5)*ip));
     m:=n/Partial;
     for i:=0 to BANDLIMITED_WAVETABLE_SIZE-1 do begin
      Track^.BandlimitedSaw[Note,i]:=Track^.BandlimitedSaw[Note,i]+(Track^.BandlimitedDoubleSineLUT[(i*Partial) and ((BANDLIMITED_WAVETABLE_SIZE*2)-1)]*m);
     end;
     m:=(n/sqr(Partial))*(Sign*4.0);
     for i:=0 to BANDLIMITED_WAVETABLE_SIZE-1 do begin
      Track^.BandlimitedParabola[Note,i]:=Track^.BandlimitedParabola[Note,i]+(Track^.BandlimitedSineLUT[((i*Partial)+(BANDLIMITED_WAVETABLE_SIZE div 4)) and BANDLIMITED_WAVETABLE_MASK]*m);
     end;
     Sign:=-Sign;
    end;
   end;
  end else begin
   Track^.BandlimitedSaw[Note]:=Track^.BandlimitedSaw[Note-1];
   Track^.BandlimitedParabola[Note]:=Track^.BandlimitedParabola[Note-1];
  end;
 end;
 Normalize(Track^.BandlimitedSaw);
 Normalize(Track^.BandlimitedParabola);
end;

{$ifdef UseSSE}
function SynthGetBandlimitedWavetableSSE(Track:PSynthTrack;BandlimitedWaveTables:PBandlimitedWaveTables;Phase,PhaseIncrement:single):single; assembler; register;
const MinBound:longint=low(TBandlimitedMap);
      MaxBound:longint=high(TBandlimitedMap);
      BANDLIMITED_WAVETABLE_SIZE_FLOAT:single=BANDLIMITED_WAVETABLE_SIZE;
      F0:single=0;
      F1:single=1;
var PhaseTranslated:single;
    Index:longint;
    BandlimitedWaveTable:PBandlimitedWaveTable;
asm
 movss xmm3,dword ptr Phase
 movss xmm4,dword ptr PhaseIncrement

 // Index:=round(PhaseIncrement*Track^.InternalSampleRate*2);
 mov ecx,dword ptr [eax+TSynthTrack.InternalSampleRate]
 add ecx,ecx
 cvtsi2ss xmm0,ecx
 mulss xmm0,xmm4
 cvtss2si ecx,xmm0

 // Clamp to low(TBandlimitedMap) .. high(TBandlimitedMap)
 cmp ecx,dword ptr MinBound
 cmovl ecx,dword ptr MinBound
 cmp ecx,dword ptr MaxBound
 cmovg ecx,dword ptr MaxBound

 // BandlimitedWaveTable:=@BandlimitedWaveTables[Track^.BandlimitedMap[Index]];
 mov eax,dword ptr [eax+ecx*4+TSynthTrack.BandlimitedMap]
 shl eax,BANDLIMITED_WAVETABLE_BITS+2
 add eax,edx // BandlimitedWaveTables

 // PhaseTranslated:=frac(Phase);
 movss xmm0,xmm3
 cvttss2si edx,xmm0
 cvtsi2ss xmm1,edx
 subss xmm0,xmm1

 // PhaseTranslated:=(longint(longword(pointer(@PhaseTranslated)^) shr 31)+PhaseTranslated)*BANDLIMITED_WAVETABLE_SIZE;
 comiss xmm0,dword ptr F0
 jge @Skip
  addss xmm0,dword ptr F1
 @Skip:
 mulss xmm0,dword ptr BANDLIMITED_WAVETABLE_SIZE_FLOAT

 // Index:={$ifdef rtl}trunc{$else}SoftTRUNC{$endif}(PhaseTranslated) and BANDLIMITED_WAVETABLE_MASK;
 // PhaseTranslated:=frac(PhaseTranslated);
 cvttss2si edx,xmm0
 cvtsi2ss xmm1,edx
 subss xmm0,xmm1

 // result:=(BandlimitedWaveTable^[Index and BANDLIMITED_WAVETABLE_MASK]*(1.0-PhaseTranslated))+(BandlimitedWaveTable^[(Index+1) and BANDLIMITED_WAVETABLE_MASK]*PhaseTranslated);
 and edx,BANDLIMITED_WAVETABLE_MASK
 movss xmm1,dword ptr [eax+edx*4]
 inc edx
 and edx,BANDLIMITED_WAVETABLE_MASK
 movss xmm2,dword ptr [eax+edx*4]

 subss xmm2,xmm1
 mulss xmm0,xmm2
 addss xmm0,xmm1

 movss dword ptr result,xmm0
end;
{$endif}

function SynthGetBandlimitedWavetable(Track:PSynthTrack;BandlimitedWaveTables:PBandlimitedWaveTables;Phase,PhaseIncrement:single):single;
{$ifdef cpu386}
{$ifndef ver130}
const MinBound:longint=low(TBandlimitedMap);
      MaxBound:longint=high(TBandlimitedMap);
{$endif}
{$endif}
var PhaseTranslated:single;
    Index:longint;
    BandlimitedWaveTable:PBandlimitedWaveTable;
begin
 Index:=round(PhaseIncrement*Track^.InternalSampleRate*2);
{$ifdef cpu386}
{$ifndef ver130}
 asm
  mov eax,dword ptr Index
  cmp eax,dword ptr MinBound
  cmovl eax,dword ptr MinBound
  cmp eax,dword ptr MaxBound
  cmovg eax,dword ptr MaxBound
  mov dword ptr Index,eax
 end;
{$else}
 Index:=longword(longword(Index) and longword($ffffffff+longword(longword(longword(Index)-longword(low(TBandlimitedMap))) shr 31)));
 Index:=longword(longword(Index)+longword((longword(high(TBandlimitedMap))-longword(Index)) and longword(0-longword(longword(high(TBandlimitedMap)-longword(Index)) shr 31))));
{$endif}
{$else}
 if Index<low(TBandlimitedMap) then begin
  Index:=low(TBandlimitedMap):
 end else if Index>high(TBandlimitedMap) then begin
  Index:=high(TBandlimitedMap):
 end;
{$endif}
 BandlimitedWaveTable:=@BandlimitedWaveTables[Track^.BandlimitedMap[Index]];
{$ifdef cpu386}
 asm
  fld dword ptr Phase
  fld1
  fxch st(1)
  fprem
  fxch st(1)
  fstp st(0)
  fstp dword ptr PhaseTranslated
 end;
{$else}
 PhaseTranslated:=frac(Phase);
{$endif}
 PhaseTranslated:=(longint(longword(pointer(@PhaseTranslated)^) shr 31)+PhaseTranslated)*BANDLIMITED_WAVETABLE_SIZE;
 Index:={$ifdef rtl}trunc{$else}SoftTRUNC{$endif}(PhaseTranslated) and BANDLIMITED_WAVETABLE_MASK;
{$ifdef cpu386}
 asm
  fld dword ptr PhaseTranslated
  fld1
  fxch st(1)
  fprem
  fxch st(1)
  fstp st(0)
  fstp dword ptr PhaseTranslated
 end;
{$else}
 PhaseTranslated:=frac(PhaseTranslated);
{$endif}
 result:=(BandlimitedWaveTable^[Index and BANDLIMITED_WAVETABLE_MASK]*(1.0-PhaseTranslated))+(BandlimitedWaveTable^[(Index+1) and BANDLIMITED_WAVETABLE_MASK]*PhaseTranslated);
end;

procedure SynthReinitSampleRate(Track:PSynthTrack);
begin
 Track^.InternalSampleRate:=Track^.BaseSampleRate*Track^.InternalSamplingFactor;
 Track^.InternalSampleRateRampingFactor:=Track^.InternalSampleRate/10000;
 Track^.InternalSampleRateFactor:=1/Track^.InternalSampleRate;
 Track^.InternalHalfSampleRateFactor:=1/(Track^.InternalSampleRate*0.5);
 Track^.InternalBufferSamples:=Track^.BaseBufferSamples*Track^.InternalSamplingFactor;
 Track^.RampingSamples:=(120*Track^.InternalSampleRate) div 44100;
 if Track^.RampingSamples<1 then begin
  Track^.RampingSamples:=1;
 end;
 Track^.ClickRemovalFactor:=power(0.992,44100*Track^.InternalSampleRateFactor);
end;

procedure SynthInitDownsampleSINC(Track:PSynthTrack);
var a,beta,i0beta,FracValue,SincValue,WindowValue,WindowParameter,
    OtherPosition,HalfPoints,Position,CutOff:double;
    Counter,SubCounter,Points,Len,Index:longint;
begin
 CutOff:=0.97/Track^.OversamplingFactor;

 a:=-20*log10(1/(1 shl 24)); // 24 bits -> -144dB stopband attenuation (and if for 16 bits -> -96dB stopband attenuation)
 if a>50 then begin
  beta:=0.1102*(a-8.7);
 end else if a>=21 then begin
  beta:=(0.5842*power(a-21,0.4))+(0.07886*(a-21));
 end else begin
  beta:=0;
 end;

 Points:=Track^.OversamplingFactor*Track^.OversamplingOrder;

//Points:=NextOfPowerTwo(round64((((a-7.95)/(2.285*((1-((2*0.5)/Track^.OversamplingFactor))*pi)))*Track^.OversamplingFactor)+0.5));

 Len:=1;

 GetMemZero(Track^.DownsampleSINC,(Points*Len)*sizeof(single));
 Track^.DownsampleSINCRingBufferLen:=Points*4;
 Track^.DownsampleSINCRingBufferMask:=Track^.DownsampleSINCRingBufferLen-1;
 Track^.DownsampleSINCLen:=Len;
 Track^.DownsampleSINCPoints:=Points;
 for Counter:=-1 to {$ifdef MultiOutput}NumberOfChannels{$endif}-1 do begin
  GetMemZero(Track^.DownsampleSINCRingBuffer[Counter],Track^.DownsampleSINCRingBufferLen*sizeof(TSynthBufferSample));
  Track^.DownsampleSINCRingBufferIndex[Counter]:=0;
 end;

 Index:=0;

 i0beta:=i0(beta);

 HalfPoints:=Points*0.5;

 for Counter:=0 to Len-1 do begin
  FracValue:=(Counter/Len)-0.5;
  for SubCounter:=0 to Points-1 do begin
   OtherPosition:=SubCounter-FracValue;
   Position:=OtherPosition-HalfPoints;
   WindowParameter:=Position/HalfPoints;
   if abs(Position)<EPSILON then begin
    SincValue:=CutOff;
   end else begin
    SincValue:=sin(CutOff*Position*pi)/(Position*pi);
   end;
   if abs(WindowParameter)<=1 then begin
    WindowValue:=i0(beta*sqrt(1-sqr(WindowParameter)))/i0beta;
   end else begin
    WindowValue:=0;
   end;
   Track^.DownsampleSINC^[Index]:=SincValue*WindowValue;
   inc(Index);
  end;
 end;
end;

procedure SynthReinitOversample(Track:PSynthTrack);
{$ifdef MultiOutput}
var i:longint;
{$endif}
begin
 if (Track^.LastOversampling<>Track^.Oversampling) or (Track^.LastFineOversampling<>Track^.FineOversampling) or (Track^.LastOversamplingOrder<>Track^.OversamplingOrder) then begin
  if Track^.Oversampling>DOWNSAMPLE_MAX then begin
   Track^.Oversampling:=DOWNSAMPLE_MAX;
  end;
  Track^.LastOversampling:=Track^.Oversampling;
  Track^.LastFineOversampling:=Track^.FineOversampling;
  Track^.LastOversamplingOrder:=Track^.OversamplingOrder;
  Track^.OversamplingFactor:=1 shl Track^.Oversampling;
  if Track^.OversamplingFactor>1 then begin
   if Track^.FineOversampling then begin
    SynthInitDownsampleSINC(Track);
   end;
   begin
    SynthOversamplerInit(Track^.Oversamplers[-1,0],Track^.OversamplingOrder,Track^.BaseSampleRate,Track^.OversamplingFactor);
    Track^.Oversamplers[-1,1]:=Track^.Oversamplers[-1,0];
{$ifdef MultiOutput}
    for i:=0 to NumberOfChannels-1 do begin
     Track^.Oversamplers[i,0]:=Track^.Oversamplers[-1,0];
     Track^.Oversamplers[i,1]:=Track^.Oversamplers[-1,1];
    end;
{$endif}
   end;
  end;
  if (Track^.FineOversampling and (Track^.InternalSamplingFactor<>Track^.OversamplingFactor)) or
     ((Track^.InternalSamplingFactor<>1) and not Track^.FineOversampling) then begin
   if Track^.FineOversampling then begin
    Track^.InternalSamplingFactor:=Track^.OversamplingFactor;
   end else begin
    Track^.InternalSamplingFactor:=1;
   end;
   SynthReinitSampleRate(Track);
   SynthReinit(Track,Track^.BaseSampleRate,Track^.BaseBufferSamples);
  end;
 end;
end;

procedure SynthJobCreateThreads(Track:PSynthTrack); forward;

procedure SynthInitValueBuffers(Track:PSynthTrack);
var i:longint;
begin
 for i:=0 to 127 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values7BitBuffers[i],i/127,FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values7BitBuffers[i],i/127,FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values7BitSqrBuffers[i],sqr(i/127),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values7BitSqrBuffers[i],sqr(i/127),FixedWorkBufferSize);
  end;
 end;
 for i:=0 to 255 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values8BitBuffers[i],i/255,FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values8BitBuffers[i],i/255,FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values8BitSqrBuffers[i],sqr(i/255),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values8BitSqrBuffers[i],sqr(i/255),FixedWorkBufferSize);
  end;
 end;
 for i:=0 to 255 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values8BitExtBuffers[i],i,FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values8BitExtBuffers[i],i,FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values8BitExtSqrBuffers[i],sqr(i),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values8BitExtSqrBuffers[i],sqr(i),FixedWorkBufferSize);
  end;
 end;
 for i:=0 to 127 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values14BitBuffers[i],(i shl 7)/16383,FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values14BitBuffers[i],(i shl 7)/16383,FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.Values14BitSqrBuffers[i],sqr((i shl 7)/16383),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.Values14BitSqrBuffers[i],sqr((i shl 7)/16383),FixedWorkBufferSize);
  end;
 end;
 for i:=0 to 255 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.ValuesRescaleBuffers[i],i/(i+1),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.ValuesRescaleBuffers[i],i/(i+1),FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.ValuesRescaleSqrBuffers[i],sqr(i/(i+1)),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.ValuesRescaleSqrBuffers[i],sqr(i/(i+1)),FixedWorkBufferSize);
  end;
 end;
 for i:=0 to 255 do begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.ValuesInvRescaleBuffers[i],(i+1)/i,FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.ValuesInvRescaleBuffers[i],(i+1)/i,FixedWorkBufferSize);
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthFillFloatSSE(@Track^.WorkBuffers^.ValuesInvRescaleSqrBuffers[i],sqr((i+1)/i),FixedWorkBufferSize);
  end else{$endif} begin
   SynthFillFloat(@Track^.WorkBuffers^.ValuesInvRescaleSqrBuffers[i],sqr((i+1)/i),FixedWorkBufferSize);
  end;
 end;
end;

procedure SynthInit(Track:PSynthTrack;SampleRate,BufferSamples:longint;ThreadPlay:longbool=true;SoundOutput:longbool=true); {$ifdef csdk}stdcall; [public,alias:'_SynthInit@20'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifndef cpu386}
const verinfo:pansichar='BeRo''s BR808 software synthesizer - Copyright (C) 2004-2011, Benjamin ''BeRo'' Rosseaux'+' - http://www.farbrausch.de/br404/ - http://www.rosseaux.com/';
{$endif}
var Counter,SubCounter:longint;
{$ifdef WIN32Plain}
    WOC:TWAVEOUTCAPS;
{$endif}
    Value:single;
{$ifdef cpu386}
    OldFCW:word;
{$endif}
{$ifdef UseSSE}
    OldSIMDCtrl:longword;
{$endif}
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
{$ifdef BR808SPEECH}
 SynthInitSpeechSegments;
{$endif}
{$ifdef cpu386}
 asm
  jmp @Skip
  db 'BeRo''s BR808 software synthesizer - Copyright (C) 2004-2011, Benjamin ''BeRo'' Rosseaux',' - http://www.farbrausch.de/br404/ - http://www.rosseaux.com/',0
  @Skip:
 end;
{$else}
 if assigned(verinfo) then begin
 end;
{$endif}
 CheckCPU;
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   stmxcsr dword ptr OldSIMDCtrl
  end;
  SIMDSetFlags;
 end;
{$endif}
 if SampleRate=0 then begin
  SampleRate:=1;
 end;
 FillChar(Track^,sizeof(TSynthTrack),#0);
{$ifdef textdebug}
 assignfile(Track^.TextDebug,'c:\Debug\br404.txt');
 rewrite(Track^.TextDebug);
 Track^.TimeDebug:=0;
 Track^.DebugWait:=true;
{$endif}
 Track^.UseMultithreading:=true;
{$ifdef UseSSE}
 Track^.UseSSE:=true;
{$else}
 Track^.UseSSE:=false;
{$endif}
 Track^.Active:=false;
 Track^.ThreadIsWorking:=false;
 Track^.ThreadsTerminated:=false;
 Track^.Threads:=0;
 Track^.ScanPeaks:=false;
 Track^.ScanPeakFactor:=0;
 Track^.Global.Oversample:=0;
 Track^.Global.FineOversample:=false;
 Track^.Global.FineSincOversample:=false;
 Track^.Global.OversampleOrder:=4;
 Track^.Global.RampingLen:=27;
 Track^.Global.RampingMode:=0;
 Track^.Global.Clipping:=false;
 Track^.Global.Voices.Count:=NumberOfVoicesStandard;
 Track^.DownsampleSINC:=nil;
 Track^.DownsampleSINCRingBuffer[-1]:=nil;
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  Track^.DownsampleSINCRingBuffer[Counter]:=nil;
 end;
{$endif}
 Track^.LastOversampling:=-1;
 Track^.LastFineOversampling:=false;
 Track^.FineOversampling:=false;
 Track^.FineSincOversampling:=false;
 Track^.OversamplingOrder:=4;
 Track^.Oversampling:=0;
 if Track^.Oversampling>DOWNSAMPLE_MAX then begin
  Track^.Oversampling:=DOWNSAMPLE_MAX;
 end;
 Track^.OversamplingFactor:=1 shl Track^.Oversampling;
 Track^.InternalSamplingFactor:=1;
 Track^.ThreadPlay:=ThreadPlay;
 Track^.SoundOutput:=SoundOutput;
 Track^.LinkContentDestroy:=false;
 Track^.Played:=false;
 Track^.DoAudioProcessing:=true;
 Track^.Time:=0;
 Track^.DifferenceTicksIncrement:=0;
 Track^.Tempo:=500000;
 Track^.BaseSampleRate:=SampleRate;
 Track^.InternalSampleRate:=SampleRate*Track^.InternalSamplingFactor;
 Track^.InternalSampleRateRampingFactor:=Track^.InternalSampleRate/10000;
 Track^.InternalSampleRateFactor:=1/Track^.InternalSampleRate;
 Track^.InternalHalfSampleRateFactor:=1/(Track^.InternalSampleRate*0.5);
 Track^.BaseBufferSamples:=BufferSamples;
 Track^.InternalBufferSamples:=BufferSamples*Track^.InternalSamplingFactor;
 Track^.RampingSamples:=(120*Track^.InternalSampleRate) div 44100;
 if Track^.RampingSamples<1 then begin
  Track^.RampingSamples:=1;
 end;
 Track^.BaseClickRemovalFactor:=power(0.992,44100/Track^.BaseSampleRate);
 Track^.ClickRemovalFactor:=power(0.992,44100*Track^.InternalSampleRateFactor);
 Track^.DelayBufferSize:=NextOfPowerTwo(Track^.InternalSampleRate*DelayBufferSeconds);
 Track^.DelayBufferMask:=Track^.DelayBufferSize-1;
 Track^.ChorusSamples:=NextOfPowerTwo(Track^.InternalSampleRate);
 Track^.ChorusSamplesMask:=Track^.ChorusSamples-1;
 Track^.POTBufferSize:=NextOfPowerTwo(Track^.InternalSampleRate);
 Track^.POTBufferMask:=Track^.POTBufferSize-1;
 GetMemZero(Track^.WorkBuffers,sizeof(TSynthWorkBuffers));
 GetMemZero(Track^.Buffer,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
 GetMemZero(Track^.OversampleBuffer,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  GetMemZero(Track^.ChannelBuffer[Counter],(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
 end;
{$endif}
 GetMemZero(Track^.F1D0Buffer,FixedWorkBufferSize*sizeof(TSynthFloatValue));
 Value:=1;
{$ifdef UseSSE}
 if SSEExt and Track^.UseSSE then begin
  SynthFillFloatSSE(Track^.F1D0Buffer,Value,FixedWorkBufferSize);
 end else{$endif} begin
  SynthFillFloat(Track^.F1D0Buffer,Value,FixedWorkBufferSize);
 end;
 GetMemZero(Track^.F0D5Buffer,FixedWorkBufferSize*sizeof(TSynthFloatValue));
 Value:=0.5;
{$ifdef UseSSE}
 if SSEExt and Track^.UseSSE then begin
  SynthFillFloatSSE(Track^.F0D5Buffer,Value,FixedWorkBufferSize);
 end else{$endif} begin
  SynthFillFloat(Track^.F0D5Buffer,Value,FixedWorkBufferSize);
 end;
 GetMemZero(Track^.ZeroBuffer,FixedWorkBufferSize*sizeof(TSynthFloatValue));
 Value:=0;
{$ifdef UseSSE}
 if SSEExt and Track^.UseSSE then begin
  SynthFillFloatSSE(Track^.ZeroBuffer,Value,FixedWorkBufferSize);
 end else{$endif} begin
  SynthFillFloat(Track^.ZeroBuffer,Value,FixedWorkBufferSize);
 end;
 GetMemZero(Track^.GlobalData.DelayBuffer,Track^.DelayBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.ChorusFlangerBuffer,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.CompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.FinalCompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.Reverb.LeftBuffer,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue));
 GetMemZero(Track^.GlobalData.Reverb.RightBuffer,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue));
 for Counter:=0 to MaxReverbAllPassFilters-1 do begin
  GetMemZero(Track^.GlobalData.Reverb.AllPassBuffer[Counter],Track^.InternalSampleRate*2*sizeof(TSynthBufferSample));
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   GetMemZero(Track^.PluckedStringBuffers[Counter,SubCounter,0],(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue));
   GetMemZero(Track^.PluckedStringBuffers[Counter,SubCounter,1],(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue));
{  Track^.PluckedStrings[Counter,SubCounter].UpperRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,0];
   Track^.PluckedStrings[Counter,SubCounter].LowerRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,1];}
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.UpperRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,0];
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.LowerRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,1];
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  for SubCounter:=0 to MaxInstrumentDelay-1 do begin
   Track^.Channels[Counter].DelayBuffer[SubCounter]:=nil;
// GetMemZero(Track^.Channels[Counter].DelayBuffer[SubCounter],Track^.DelayBufferSize*sizeof(TSynthBufferSample));
  end;
  GetMemZero(Track^.Channels[Counter].ChorusFlangerBuffer,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample));
  GetMemZero(Track^.Channels[Counter].CompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
  GetMemZero(Track^.Channels[Counter].Buffer,FixedWorkBufferSize*sizeof(TSynthBufferSample));
  Track^.Channels[Counter].Patch:=0;
  Track^.Channels[Counter].Instrument:=@Track^.Instruments[0];
  Track^.Channels[Counter].LastInstrument:=nil;
  Track^.Channels[Counter].LastVoiceInstrument:=nil;
{$ifdef BR808SPEECH}
  SynthSpeechInit(Track^.Channels[Counter].SpeechInstance);
{$endif}
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  Track^.Voices[Counter].Number:=Counter;
{ for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString:=@Track^.PluckedStrings[Counter,SubCounter];
  end;}
  Track^.Voices[Counter].Instrument:=nil;
  Track^.Voices[Counter].LastInstrument:=nil;
  Track^.Voices[Counter].KeyOffVelocity:=127;
 end;
 for Counter:=0 to MaxThreads-1 do begin
  for SubCounter:=0 to MaxInstrumentADSR-1 do begin
   Track^.ADSRBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentEnvelopes-1 do begin
   Track^.EnvelopeBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentLFO-1 do begin
   Track^.LFOBuffersActive[Counter,SubCounter]:=false;
  end;
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  SynthInitInstrument(@Track^.Instruments[Counter]);
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  for SubCounter:=0 to MaxInstrumentEnvelopes-1 do begin
   Track^.Envelopes[Counter,SubCounter].NodesCount:=0;
   Track^.Envelopes[Counter,SubCounter].NegValue:=0;
   Track^.Envelopes[Counter,SubCounter].PosValue:=0;
   Track^.Envelopes[Counter,SubCounter].LoopStart:=-1;
   Track^.Envelopes[Counter,SubCounter].LoopEnd:=-1;
   Track^.Envelopes[Counter,SubCounter].SustainLoopStart:=-1;
   Track^.Envelopes[Counter,SubCounter].SustainLoopEnd:=-1;
  end;
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  for SubCounter:=0 to MaxSamples-1 do begin
   Track^.Samples[Counter,SubCounter].Header.Channels:=1;
   Track^.Samples[Counter,SubCounter].Header.SampleRate:=44100;
   Track^.Samples[Counter,SubCounter].Header.PhaseSamples:=100;
   Track^.Samples[Counter,SubCounter].Header.Note:=69;
   Track^.Samples[Counter,SubCounter].PadSynth.Active:=false;
   Track^.Samples[Counter,SubCounter].PadSynth.ToGenerate:=false;
   Track^.Samples[Counter,SubCounter].PadSynth.WavetableSize:=262144;
   Track^.Samples[Counter,SubCounter].PadSynth.SampleRate:=44100;
   Track^.Samples[Counter,SubCounter].PadSynth.Profile:=psfGAUSS;
   Track^.Samples[Counter,SubCounter].PadSynth.Frequency:=440;
   Track^.Samples[Counter,SubCounter].PadSynth.BandWidth:=20;
   Track^.Samples[Counter,SubCounter].PadSynth.BandWidthScale:=0.5;
   Track^.Samples[Counter,SubCounter].PadSynth.NumHarmonics:=8;
   Track^.Samples[Counter,SubCounter].PadSynth.ExtendedAlgorithm:=false;
   Track^.Samples[Counter,SubCounter].PadSynth.CurveMode:=3;
   Track^.Samples[Counter,SubCounter].PadSynth.CurveSteepness:=128;
   Track^.Samples[Counter,SubCounter].PadSynth.Balance:=32;
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  Track^.ChannelInitialPrograms[Counter]:=0;
 end;
 Track^.Global.Reverb.Active:=true;
 Track^.Global.Reverb.PreDelay:=46;
 Track^.Global.Reverb.CombFilterSeparation:=22;
 Track^.Global.Reverb.RoomSize:=88;
 Track^.Global.Reverb.FeedBack:=232;
 Track^.Global.Reverb.Absortion:=32;
 Track^.Global.Reverb.Dry:=$9e;
 Track^.Global.Reverb.Wet:=$61;
 Track^.Global.Reverb.NumberOfAllPassFilters:=MaxReverbAllPassFilters;
 Track^.Global.Delay.Wet:=127;
 Track^.Global.Delay.Dry:=255;
 Track^.Global.Delay.FeedBackLeft:=64;
 Track^.Global.Delay.FeedBackRight:=64;
 Track^.Global.Delay.TimeLeft:=99;
 Track^.Global.Delay.TimeRight:=99;
 Track^.Global.Delay.Fine:=true;
 Track^.Global.Delay.Recursive:=true;
 Track^.Global.ChorusFlanger.Wet:=255;
 Track^.Global.ChorusFlanger.Dry:=255;
 Track^.Global.ChorusFlanger.FeedBackLeft:=64;
 Track^.Global.ChorusFlanger.FeedBackRight:=64;
 Track^.Global.ChorusFlanger.TimeLeft:=14;
 Track^.Global.ChorusFlanger.TimeRight:=14;
 Track^.Global.ChorusFlanger.LFORateLeft:=3;
 Track^.Global.ChorusFlanger.LFORateRight:=3;
 Track^.Global.ChorusFlanger.LFODepthLeft:=64;
 Track^.Global.ChorusFlanger.LFODepthRight:=64;
 Track^.Global.ChorusFlanger.LFOPhaseLeft:=0;
 Track^.Global.ChorusFlanger.LFOPhaseRight:=0;
 Track^.Global.ChorusFlanger.Fine:=true;
 Track^.Global.ChorusFlanger.Count:=1;
 Track^.Global.PitchShifter.Tune:=0;
 Track^.Global.PitchShifter.FineTune:=0;
 SynthInitEQ(@Track^.Global.EQ);
 Track^.Global.Compressor.Mode:=0;
 Track^.Global.Compressor.Threshold:=500;
 Track^.Global.Compressor.Ratio:=51;
 Track^.Global.Compressor.WindowSize:=1;
 Track^.Global.Compressor.SoftHardKnee:=255;
 Track^.Global.Compressor.OutGain:=0;
 Track^.Global.Compressor.Attack:=442;
 Track^.Global.Compressor.Release:=442;
 Track^.Global.Compressor.AutoGain:=false;
 Track^.Global.ChorusFlanger.Count:=1;
 Track^.Global.Order[goPITCHSHIFTER]:=goPITCHSHIFTER;
 Track^.Global.Order[goENDFILTER]:=goENDFILTER;
 Track^.Global.Order[goEQ]:=goEQ;
 Track^.Global.Order[goCOMPRESSOR]:=goCOMPRESSOR;
 Track^.Global.Clock.BPM:=125;
 Track^.Global.Clock.TPB:=4;
 Track^.Global.Voices.Count:=NumberOfVoicesStandard;
 Track^.Global.FinalCompressor.Mode:=0;
 Track^.Global.FinalCompressor.Threshold:=500;
 Track^.Global.FinalCompressor.Ratio:=51;
 Track^.Global.FinalCompressor.WindowSize:=1;
 Track^.Global.FinalCompressor.SoftHardKnee:=255;
 Track^.Global.FinalCompressor.OutGain:=0;
 Track^.Global.FinalCompressor.Attack:=442;
 Track^.Global.FinalCompressor.Release:=442;
 Track^.Global.FinalCompressor.AutoGain:=false;
 SynthReset(Track);
 SynthChangeTempo(Track);
{$ifdef WIN32Plain}
 if Track^.SoundOutput then begin
  Track^.BufferCounter:=0;             
  Track^.OutputBufferSize:=Track^.BaseBufferSamples*sizeof(smallint)*2;
  Track^.WaveFormat.wFormatTag:=WAVE_FORMAT_PCM; //3;
  Track^.WaveFormat.nChannels:=2;
  Track^.WaveFormat.wBitsPerSample:=16; //32;
  Track^.WaveFormat.nBlockAlign:=Track^.WaveFormat.nChannels*Track^.WaveFormat.wBitsPerSample div 8;
  Track^.WaveFormat.nSamplesPerSec:=Track^.BaseSampleRate;
  Track^.WaveFormat.nAvgBytesPerSec:=Track^.WaveFormat.nSamplesPerSec*Track^.WaveFormat.nBlockAlign;
  Track^.WaveFormat.cbSize:=0;
  Track^.WaveHandle:=waveOutOpen(@Track^.WaveOutHandle,WAVE_MAPPER,@Track^.WaveFormat,0,0,0);
  for Counter:=0 to 3 do begin
   GetMemZero(Track^.WaveHandler[Counter],sizeof(TWAVEHDR));
   Track^.WaveHandler[Counter].dwFlags:=WHDR_DONE;
   GetMemZero(Track^.WaveHandler[Counter].lpData,Track^.OutputBufferSize);
   Track^.WaveHandler[Counter].dwBufferLength:=Track^.OutputBufferSize;
   Track^.WaveHandler[Counter].dwBytesRecorded:=0;
   Track^.WaveHandler[Counter].dwUser:=0;
   Track^.WaveHandler[Counter].dwLoops:=0;
  end;
 end;
 SynthCreateThread(Track);
 if Track^.SoundOutput then begin
  if waveOutGetDevCaps(0,@WOC,sizeof(TWAVEOUTCAPS))=0 then begin
   Track^.IsSampleAccurate:=(WOC.dwSupport and WAVECAPS_SAMPLEACCURATE)<>0;
  end else begin
   Track^.IsSampleAccurate:=false;
  end;
  Track^.LastGetPositionSample:=0;
  Track^.AddGetPositionSample:=0;
  Track^.FirstBufferTime:=timeGetTime;
  Track^.FirstBufferSample:=0;
  Track^.FirstBuffer:=true;
 end;
{$endif}
 Track^.Volume:=1;
 Track^.Looping:=false;
 Track^.ClipSamples:=false;
 Track^.AGC:=false;
 Track^.AGCFactor:=1;
 Track^.AGCAttackFactor:=power(0.001,1/(Track^.BaseSampleRate*0.015));
 Track^.AGCReleaseFactor:=power(1000,1/(Track^.BaseSampleRate*1));
 Track^.Seed:=$c3e1fc32;
{$ifndef vsti}
 FillChar(Track^.BalancedRootEvent,sizeof(TSynthEvent),#0);
 Track^.BalancedRootEvent.Level:=$7fffffffffffffff;
{$endif}
 Track^.OmniMode:=true;
 Track^.OmniChannel:=0;
 Track^.GeneralMIDIMode:=1;
 Track^.VoiceAllocationAlgorithm:=0;
 Track^.MasterVolume:=16383;
 Track^.MasterBalance:=8192;
 Track^.MasterCoarseTuning:=0.5;
 Track^.MasterFineTuning:=0.5;
 SynthInitTuningTables(Track);
 SynthInitChorusSINCTable(Track);
 SynthInitSINC(Track);
 SynthInitPitchShifterFadeBuffer(Track);
 SynthInitValueBuffers(Track);
 SynthReinitSampleRate(Track);
 SynthInitBandlimitedWavetables(Track);
 SynthReinitOversample(Track);
 SynthJobCreateThreads(Track);
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   ldmxcsr dword ptr OldSIMDCtrl
  end;
 end;
{$endif}
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
end;

procedure SynthReinit(Track:PSynthTrack;SampleRate,BufferSamples:longint); {$ifdef csdk}stdcall; [public,alias:'_SynthReinit@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var Counter,SubCounter:longint;
    NewSampleRate:boolean;
{$ifdef cpu386}
    OldFCW:word;
{$endif}
{$ifdef UseSSE}
    OldSIMDCtrl:longword;
{$endif}
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   stmxcsr dword ptr OldSIMDCtrl
  end;
  SIMDSetFlags;
 end;
{$endif}
 if SampleRate=0 then begin
  SampleRate:=1;
 end;
 NewSampleRate:=SampleRate<>Track^.BaseSampleRate;
{$ifdef textdebug}
 Track^.TimeDebug:=0;
 Track^.DebugWait:=true;
{$endif}
 Track^.Time:=0;
 if NewSampleRate then begin
  Track^.LastOversampling:=-1;
  Track^.LastFineOversampling:=not Track^.FineOversampling;
  Track^.LastOversamplingOrder:=-1;
  Track^.Oversampling:=0;
  if Track^.Oversampling>DOWNSAMPLE_MAX then begin
   Track^.Oversampling:=DOWNSAMPLE_MAX;
  end;
  Track^.OversamplingFactor:=1 shl Track^.Oversampling;
 end;
 Track^.DifferenceTicksIncrement:=0;
 Track^.BaseSampleRate:=SampleRate;
 Track^.InternalSampleRate:=SampleRate*Track^.InternalSamplingFactor;
 Track^.InternalSampleRateRampingFactor:=Track^.InternalSampleRate/10000;
 Track^.InternalSampleRateFactor:=1/Track^.InternalSampleRate;
 Track^.InternalHalfSampleRateFactor:=1/(Track^.InternalSampleRate*0.5);
 Track^.BaseBufferSamples:=BufferSamples;
 Track^.InternalBufferSamples:=BufferSamples*Track^.InternalSamplingFactor;
 Track^.RampingSamples:=(120*Track^.InternalSampleRate) div 44100;
 if Track^.RampingSamples<1 then begin
  Track^.RampingSamples:=1;
 end;
 Track^.BaseClickRemovalFactor:=power(0.992,44100/Track^.BaseSampleRate);
 Track^.ClickRemovalFactor:=power(0.992,44100*Track^.InternalSampleRateFactor);
 Track^.DelayBufferSize:=NextOfPowerTwo(Track^.InternalSampleRate*DelayBufferSeconds);
 Track^.DelayBufferMask:=Track^.DelayBufferSize-1;
 Track^.ChorusSamples:=NextOfPowerTwo(Track^.InternalSampleRate);
 Track^.ChorusSamplesMask:=Track^.ChorusSamples-1;
 Track^.POTBufferSize:=NextOfPowerTwo(Track^.InternalSampleRate);
 Track^.POTBufferMask:=Track^.POTBufferSize-1;
 GetMemZero(Track^.Buffer,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
 GetMemZero(Track^.OversampleBuffer,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  GetMemZero(Track^.ChannelBuffer[Counter],(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample));
 end;
{$endif}
 GetMemZero(Track^.GlobalData.DelayBuffer,Track^.DelayBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.ChorusFlangerBuffer,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.CompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.FinalCompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
 GetMemZero(Track^.GlobalData.Reverb.LeftBuffer,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue));
 GetMemZero(Track^.GlobalData.Reverb.RightBuffer,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue));
 for Counter:=0 to MaxReverbAllPassFilters-1 do begin
  GetMemZero(Track^.GlobalData.Reverb.AllPassBuffer[Counter],Track^.InternalSampleRate*2*sizeof(TSynthBufferSample));
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   GetMemZero(Track^.PluckedStringBuffers[Counter,SubCounter,0],(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue));
   GetMemZero(Track^.PluckedStringBuffers[Counter,SubCounter,1],(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue));
{  Track^.PluckedStrings[Counter,SubCounter].UpperRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,0];
   Track^.PluckedStrings[Counter,SubCounter].LowerRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,1];}
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.UpperRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,0];
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.LowerRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,1];
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  for SubCounter:=0 to MaxInstrumentDelay-1 do begin
   if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
    GetMemZero(Track^.Channels[Counter].DelayBuffer[SubCounter],Track^.DelayBufferSize*sizeof(TSynthBufferSample));
   end;
  end;
  GetMemZero(Track^.Channels[Counter].ChorusFlangerBuffer,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample));
  GetMemZero(Track^.Channels[Counter].CompressorBuffer,Track^.POTBufferSize*sizeof(TSynthBufferSample));
 end;
 for Counter:=0 to MaxThreads-1 do begin
  for SubCounter:=0 to MaxInstrumentADSR-1 do begin
   Track^.ADSRBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentEnvelopes-1 do begin
   Track^.EnvelopeBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentLFO-1 do begin
   Track^.LFOBuffersActive[Counter,SubCounter]:=false;
  end;
 end;
 FillChar(Track^.GlobalData.Compressor,sizeof(TSynthCompressorData),#0);
 Track^.AGCFactor:=1;
 Track^.AGCAttackFactor:=power(0.001,1/(Track^.BaseSampleRate*0.015));
 Track^.AGCReleaseFactor:=power(1000,1/(Track^.BaseSampleRate*1));
 SynthReset(Track);
 SynthChangeTempo(Track);
//SynthInitSINC(Track);
//SynthInitPitchShifterFadeBuffer(Track);
{$ifdef WIN32Plain}
 if Track^.SoundOutput then begin
  waveOutReset(Track^.WaveOutHandle);
  Track^.BufferCounter:=0;
  Track^.LastGetPositionSample:=0;
  Track^.AddGetPositionSample:=0;
  Track^.FirstBufferTime:=timeGetTime;
  Track^.FirstBufferSample:=0;
  Track^.FirstBuffer:=true;
 end;
{$endif}
 SynthReinitSampleRate(Track);
 SynthInitBandlimitedWavetables(Track);
 if NewSampleRate then begin
  SynthReinitOversample(Track);
 end;
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   ldmxcsr dword ptr OldSIMDCtrl
  end;
 end;
{$endif}
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
end;

procedure SynthJobWakeThreads(Track:PSynthTrack); forward;
procedure SynthJobFreeThreads(Track:PSynthTrack); forward;

procedure SynthDone(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthDone@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var Counter,SubCounter:longint;
    CurrentTrackSample,NextTrackSample:PSynthTrackSample;
    SubTrack,NextSubTrack:PSynthTrack;
begin
 Track^.ThreadsTerminated:=true;
 SynthJobWakeThreads(Track);
 while Track^.Threads>0 do begin
{$ifdef win32}
  sleep(10);
{$endif}
 end;
 SynthJobFreeThreads(Track);
 SynthFreeTrack(Track);
 SubTrack:=Track^.LinkRoot;
 while assigned(SubTrack) do begin
  NextSubTrack:=SubTrack^.LinkNext;
  if SubTrack^.LinkContentDestroy then begin
   SynthDestroy(SubTrack);
  end else begin
   SynthUnlink(SubTrack);
  end;
  SubTrack:=NextSubTrack;
 end;
 SynthUnlink(Track);
 CurrentTrackSample:=Track^.TrackSampleRoot;
 while assigned(CurrentTrackSample) do begin
  NextTrackSample:=CurrentTrackSample^.Next;
  SynthDestroyTrackSample(CurrentTrackSample);
  CurrentTrackSample:=NextTrackSample;
 end;
{$ifdef WIN32Plain}
 SynthExitThread(Track);
 if Track^.SoundOutput then begin
  waveOutReset(Track^.WaveOutHandle);
  for Counter:=0 to 3 do begin
   while waveOutUnprepareHeader(Track^.WaveOutHandle,Track^.WaveHandler[Counter],sizeof(TWAVEHDR))=WAVERR_STILLPLAYING do begin
    SLEEP(25);
   end;
  end;
  waveOutReset(Track^.WaveOutHandle);
  waveOutClose(Track^.WaveOutHandle);
  for Counter:=0 to 3 do begin
   FreeMemAligned(Track^.WaveHandler[Counter].lpData);
   FreeMemAligned(Track^.WaveHandler[Counter]);
  end;
 end;
{$endif}
 if assigned(Track^.Informations.TrackName) then begin
  FreeMemAligned(Track^.Informations.TrackName);
 end;
 if assigned(Track^.Informations.Author) then begin
  FreeMemAligned(Track^.Informations.Author);
 end;
 if assigned(Track^.Informations.Comments) then begin
  FreeMemAligned(Track^.Informations.Comments);
 end;
{$ifdef textdebug}
 closefile(Track^.TextDebug);
{$endif}
 if assigned(Track^.DownsampleSINC) then begin
  FreeMemAligned(Track^.DownsampleSINC);
 end;
 if assigned(Track^.DownsampleSINCRingBuffer[-1]) then begin
  FreeMemAligned(Track^.DownsampleSINCRingBuffer[-1]);
 end;
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  if assigned(Track^.DownsampleSINCRingBuffer[Counter]) then begin
   FreeMemAligned(Track^.DownsampleSINCRingBuffer[Counter]);
  end;
 end;
{$endif} FreeMemAligned(Track^.WorkBuffers);
 FreeMemAligned(Track^.Buffer);
 FreeMemAligned(Track^.OversampleBuffer);
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  FreeMemAligned(Track^.ChannelBuffer[Counter]);
 end;
{$endif}
 FreeMemAligned(Track^.F1D0Buffer);
 FreeMemAligned(Track^.F0D5Buffer);
 FreeMemAligned(Track^.ZeroBuffer);
 FreeMemAligned(Track^.GlobalData.DelayBuffer);
 FreeMemAligned(Track^.GlobalData.ChorusFlangerBuffer);
 FreeMemAligned(Track^.GlobalData.CompressorBuffer);
 FreeMemAligned(Track^.GlobalData.FinalCompressorBuffer);
 FreeMemAligned(Track^.GlobalData.Reverb.LeftBuffer);
 FreeMemAligned(Track^.GlobalData.Reverb.RightBuffer);
 for Counter:=0 to MaxReverbAllPassFilters-1 do begin
  FreeMemAligned(Track^.GlobalData.Reverb.AllPassBuffer[Counter]);
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  for SubCounter:=0 to MaxInstrumentEnvelopes-1 do begin
   if assigned(Track^.Envelopes[Counter,SubCounter].Nodes) then begin
    FreeMemAligned(Track^.Envelopes[Counter,SubCounter].Nodes);
    Track^.Envelopes[Counter,SubCounter].Nodes:=nil;
   end;
  end;
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  for SubCounter:=0 to MaxSamples-1 do begin
   if assigned(Track^.Samples[Counter,SubCounter].Data) then begin
    FreeMemAligned(Track^.Samples[Counter,SubCounter].Data);
    Track^.Samples[Counter,SubCounter].Data:=nil;
   end;
   if assigned(Track^.Samples[Counter,SubCounter].WorkData) then begin
    FreeMemAligned(Track^.Samples[Counter,SubCounter].WorkData);
    Track^.Samples[Counter,SubCounter].WorkData:=nil;
   end;
  end;
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   FreeMemAligned(Track^.PluckedStringBuffers[Counter,SubCounter,0]);
   FreeMemAligned(Track^.PluckedStringBuffers[Counter,SubCounter,1]);
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  for SubCounter:=0 to MaxInstrumentDelay-1 do begin
   if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
    FreeMemAligned(Track^.Channels[Counter].DelayBuffer[SubCounter]);
   end;
  end;
  FreeMemAligned(Track^.Channels[Counter].ChorusFlangerBuffer);
  FreeMemAligned(Track^.Channels[Counter].CompressorBuffer);
  FreeMemAligned(Track^.Channels[Counter].Buffer);
 end;
 for Counter:=0 to MaxInstruments-1 do begin
  for SubCounter:=0 to MaxSpeechTexts-1 do begin
   if assigned(Track^.SpeechSegmentLists[Counter,SubCounter].Items) then begin
    FreeMemAligned(Track^.SpeechSegmentLists[Counter,SubCounter].Items);
    Track^.SpeechSegmentLists[Counter,SubCounter].Items:=nil;
   end;
   Track^.SpeechSegmentLists[Counter,SubCounter].ItemCount:=0;
  end;
 end;
end;

procedure SynthLink(Track,ToTrack:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthLink@8'];{$endif}
begin
 SynthUnlink(Track);
 if assigned(ToTrack^.LinkLast) then begin
  ToTrack^.LinkLast^.LinkNext:=Track;
  Track^.LinkPrevious:=ToTrack^.LinkLast;
  Track^.LinkNext:=nil;
  ToTrack^.LinkLast:=Track;
 end else begin
  Track^.LinkPrevious:=nil;
  Track^.LinkNext:=nil;
  ToTrack^.LinkRoot:=Track;
  ToTrack^.LinkLast:=Track;
 end;
 Track^.LinkParent:=ToTrack;
end;

procedure SynthUnlink(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthUnlink@4'];{$endif}
begin
 if assigned(Track^.LinkPrevious) then begin
  Track^.LinkPrevious^.LinkNext:=Track^.LinkNext;
 end;
 if assigned(Track^.LinkNext) then begin
  Track^.LinkNext^.LinkPrevious:=Track^.LinkPrevious;
 end;
 if assigned(Track^.LinkParent) then begin
  if Track^.LinkParent^.LinkRoot=Track then begin
   Track^.LinkParent^.LinkRoot:=Track^.LinkNext;
  end;
  if Track^.LinkParent^.LinkLast=Track then begin
   Track^.LinkParent^.LinkLast:=Track^.LinkPrevious;
  end;
 end;
 Track^.LinkPrevious:=nil;
 Track^.LinkNext:=nil;
 Track^.LinkRoot:=nil;
 Track^.LinkLast:=nil;
 Track^.LinkParent:=nil;
end;

procedure SynthSetAGC(Track:PSynthTrack;AGC:longbool); {$ifdef csdk}stdcall; [public,alias:'_SynthSetAGC@8'];{$endif}
begin
 Track^.AGC:=AGC;
end;

procedure SynthSetClipping(Track:PSynthTrack;Clipping:longbool); {$ifdef csdk}stdcall; [public,alias:'_SynthSetClipping@8'];{$endif}
begin
 Track^.ClipSamples:=Clipping;
end;

procedure SynthSetLooping(Track:PSynthTrack;Looping:longbool); {$ifdef csdk}stdcall; [public,alias:'_SynthSetLooping@8'];{$endif}
begin
 Track^.Looping:=Looping;
end;

function SynthGetTrackName(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall; [public,alias:'_SynthGetTrackName@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.Informations.TrackName;
end;

function SynthGetTrackAuthor(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall; [public,alias:'_SynthGetTrackAuthor@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.Informations.Author;
end;

function SynthGetTrackComments(Track:PSynthTrack):pchar; {$ifdef csdk}stdcall; [public,alias:'_SynthGetTrackComments@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.Informations.Comments;
end;

function SynthGetBuffer(Track:PSynthTrack):pointer; {$ifdef csdk}stdcall; [public,alias:'_SynthGetBuffer@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.Buffer;
end;

function SynthGetRootEvent(Track:PSynthTrack):PSynthEvent; {$ifdef csdk}stdcall; [public,alias:'_SynthGetRootEvent@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.EventQuery;
end;

procedure SynthSetBufferStartHook(Track:PSynthTrack;Hook:TSynthBufferHook); {$ifdef csdk}stdcall; [public,alias:'_SynthSetBufferStartHook@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 Track^.BufferStartHook:=Hook;
end;

procedure SynthSetBufferEndHook(Track:PSynthTrack;Hook:TSynthBufferHook); {$ifdef csdk}stdcall; [public,alias:'_SynthSetBufferEndHook@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 Track^.BufferEndHook:=Hook;
end;

procedure SynthSetEventHook(Track:PSynthTrack;Hook:TSynthEventHook); {$ifdef csdk}stdcall; [public,alias:'_SynthSetEventHook@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 Track^.EventHook:=Hook;
end;

procedure SynthAGC(Track:PSynthTrack;Sample:PSynthBufferSample;Samples:longint);
var i:longint;
begin
 if Track^.AGC then begin
  for i:=1 to Samples do begin
   if (abs(Sample^.Left*Track^.AGCFactor)>1) or (abs(Sample^.Right*Track^.AGCFactor)>1) then begin
    Track^.AGCFactor:=Track^.AGCFactor*Track^.AGCAttackFactor;
   end else begin
    Track^.AGCFactor:=Track^.AGCFactor+((1-Track^.AGCFactor)*Track^.AGCReleaseFactor);
   end;
   longword(pointer(@Track^.AGCFactor)^):=longword(pointer(@Track^.AGCFactor)^) and longword($ffffffff+longword(((((longword(pointer(@Track^.AGCFactor)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   Sample^.Left:=Sample^.Left*Track^.AGCFactor;
   Sample^.Right:=Sample^.Right*Track^.AGCFactor;
   longword(pointer(@Sample^.Left)^):=longword(pointer(@Sample^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Sample^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Sample^.Right)^):=longword(pointer(@Sample^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Sample^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Sample);
  end;
 end;
end;

{$ifdef UseSSE}
procedure SynthClipSamplesSSE(Sample:PSynthBufferSample;Samples:longint); assembler; register;
const FM1:array[0..3] of single=(-1,-1,-1,-1);
      F1:array[0..3] of single=(1,1,1,1);
asm
 lea ecx,[edx*2]
 test ecx,ecx
 jz @Done

  movups xmm4,[FM1]
  movups xmm5,[F1]

  test eax,15
  jnz @Unaligned
   @Aligned:

    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       maxps xmm0,xmm4
       minps xmm0,xmm5

       movaps xmm1,[eax+16]
       maxps xmm1,xmm4
       minps xmm1,xmm5

       movaps xmm2,[eax+32]
       maxps xmm2,xmm4
       minps xmm2,xmm5

       movaps xmm3,[eax+48]
       maxps xmm3,xmm4
       minps xmm3,xmm5

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3
       add eax,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       maxps xmm0,xmm4
       minps xmm0,xmm5
       movaps [eax],xmm0
       add eax,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:
     movups xmm0,[eax]
     maxps xmm0,xmm4
     minps xmm0,xmm5

     movups xmm1,[eax+16]
     maxps xmm1,xmm4
     minps xmm1,xmm5

     movups xmm2,[eax+32]
     maxps xmm2,xmm4
     minps xmm2,xmm5

     movups xmm3,[eax+48]
     maxps xmm3,xmm4
     minps xmm3,xmm5

     movups [eax],xmm0
     movups [eax+16],xmm0
     movups [eax+32],xmm0
     movups [eax+48],xmm0
     add eax,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     maxps xmm0,xmm4
     minps xmm0,xmm5
     movups [eax],xmm0
     add eax,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    maxss xmm0,xmm4
    minss xmm0,xmm5
    movss dword ptr [eax],xmm0
    add eax,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthClipSamples(Sample:PSynthBufferSample;Samples:longint);
var i:longint;
begin
 for i:=1 to Samples do begin
  Sample^.Left:=Clip(Sample^.Left,-1,1);
  Sample^.Right:=Clip(Sample^.Right,-1,1);
  inc(Sample);
 end;
end;

function SynthCreateTrackSample(Track:PSynthTrack;LoopMode:longint=slNONE;LoopStart:longint=0;LoopEnd:longint=0;SustainLoopMode:longint=slNONE;SustainLoopStart:longint=0;SustainLoopEnd:longint=0):PSynthTrackSample; {$ifdef csdk}stdcall; [public,alias:'_SynthCreateTrackSample@28'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
{$ifdef cpu386}
var OldFCW:word;
{$endif}
var i,j:longint;
    s:PSynthBufferSample;
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
 GetMemAligned(result,sizeof(TSynthTrackSample));
 FillChar(result^,sizeof(TSynthTrackSample),#0);
 Track^.Played:=true;
 result^.Parent:=Track;
 result^.Samples:=SynthSeekToSample(Track,-1);
 result^.Loop.Mode:=LoopMode;
 result^.Loop.StartSample:=LoopStart;
 result^.Loop.EndSample:=LoopEnd;
 result^.SustainLoop.Mode:=SustainLoopMode;
 result^.SustainLoop.StartSample:=SustainLoopStart;
 result^.SustainLoop.EndSample:=SustainLoopEnd;
 GetMemZero(result^.Data,(result^.Samples+(SampleFixUp*2))*sizeof(TSynthBufferSample));
 SynthReset(Track);
 Track^.DoAudioProcessing:=true;
 s:=result^.Data;
 inc(s,SampleFixUp);
 i:=result^.Samples;
 while i>0 do begin
  j:=Track^.BaseBufferSamples div 8;
  if j>i then begin
   j:=i;
  end;  
  SynthFillBuffer(Track,j{$ifdef vsti},nil{$endif});
  SynthAGC(Track,Track^.Buffer,j);
  if Track^.ClipSamples then begin
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthClipSamplesSSE(Track^.Buffer,j);
   end else{$endif} begin
    SynthClipSamples(Track^.Buffer,j);
   end;
  end;
  Move(Track^.Buffer^,s^,j*sizeof(TSynthBufferSample));
  inc(s,j);
  dec(i,j);
 end;
 SynthReset(Track);
 if assigned(Track^.TrackSampleLast) then begin
  Track^.TrackSampleLast^.Next:=result;
  result^.Previous:=Track^.TrackSampleLast;
  result^.Next:=nil;
  Track^.TrackSampleLast:=result;
 end else begin
  result^.Previous:=nil;
  result^.Next:=nil;
  Track^.TrackSampleRoot:=result;
  Track^.TrackSampleLast:=result;
 end;
 if result^.Samples>0 then begin
  for i:=0 to SampleFixUp-1 do begin
   PSynthBufferSamples(result^.Data)^[i]:=PSynthBufferSamples(result^.Data)^[SampleFixUp];
   PSynthBufferSamples(result^.Data)^[SampleFixUp+result^.Samples+i]:=PSynthBufferSamples(result^.Data)^[SampleFixUp+result^.Samples-1];
  end;
  if result^.Loop.StartSample<0 then begin
   result^.Loop.StartSample:=0;
  end else if result^.Loop.StartSample>=result^.Samples then begin
   result^.Loop.StartSample:=result^.Samples-1;
  end;
  if result^.Loop.EndSample<0 then begin
   result^.Loop.EndSample:=0;
  end else if result^.Loop.EndSample>=result^.Samples then begin
   result^.Loop.EndSample:=result^.Samples-1;
  end;
  if result^.Loop.StartSample>result^.Loop.EndSample then begin
   result^.Loop.Mode:=slNONE;
  end;
  if result^.SustainLoop.StartSample<0 then begin
   result^.SustainLoop.StartSample:=0;
  end else if result^.SustainLoop.StartSample>=result^.Samples then begin
   result^.SustainLoop.StartSample:=result^.Samples-1;
  end;
  if result^.SustainLoop.EndSample<0 then begin
   result^.SustainLoop.EndSample:=0;
  end else if result^.SustainLoop.EndSample>=result^.Samples then begin
   result^.SustainLoop.EndSample:=result^.Samples-1;
  end;
  if result^.SustainLoop.StartSample>result^.SustainLoop.EndSample then begin
   result^.SustainLoop.Mode:=slNONE;
  end;
  case result^.Loop.Mode of
   slFORWARD,slBACKWARD:begin
    for i:=0 to SampleFixUp-1 do begin
     PSynthBufferSamples(result^.Data)^[result^.Loop.EndSample+i+SampleFixUp]:=PSynthBufferSamples(result^.Data)^[result^.Loop.StartSample+i+SampleFixUp];
    end;
   end;
  end;
  case result^.SustainLoop.Mode of
   slFORWARD,slBACKWARD:begin
    for i:=0 to SampleFixUp-1 do begin
     PSynthBufferSamples(result^.Data)^[result^.SustainLoop.EndSample+i+SampleFixUp]:=PSynthBufferSamples(result^.Data)^[result^.SustainLoop.StartSample+i+SampleFixUp];
    end;
   end;
  end;
 end;
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
end;
{$else}
begin
end;
{$endif}

procedure SynthDestroyTrackSample(TrackSample:PSynthTrackSample); {$ifdef csdk}stdcall; [public,alias:'_SynthDestroyTrackSample@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
var CurrentTrackSampleInstance,NextTrackSampleInstance:PSynthTrackSampleInstance;
begin
 CurrentTrackSampleInstance:=TrackSample^.TrackSampleInstanceRoot;
 while assigned(CurrentTrackSampleInstance) do begin
  NextTrackSampleInstance:=CurrentTrackSampleInstance^.Next;
  SynthDestroyTrackSampleInstance(CurrentTrackSampleInstance);
  CurrentTrackSampleInstance:=NextTrackSampleInstance;
 end;
 if assigned(TrackSample^.Previous) then begin
  TrackSample^.Previous^.Next:=TrackSample^.Next;
 end;
 if assigned(TrackSample^.Next) then begin
  TrackSample^.Next^.Previous:=TrackSample^.Previous;
 end;
 if assigned(TrackSample^.Parent) then begin
  if TrackSample^.Parent^.TrackSampleRoot=TrackSample then begin
   TrackSample^.Parent^.TrackSampleRoot:=TrackSample^.Next;
  end;
  if TrackSample^.Parent^.TrackSampleLast=TrackSample then begin
   TrackSample^.Parent^.TrackSampleLast:=TrackSample^.Previous;
  end;
 end;
 TrackSample^.Previous:=nil;
 TrackSample^.Next:=nil;
 if assigned(TrackSample^.Data) then begin
  FreeMemAligned(TrackSample^.Data);
 end;           
 FreeMemAligned(TrackSample);
end;
{$else}
begin
end;
{$endif}

function SynthCreateTrackSampleInstance(TrackSample:PSynthTrackSample):PSynthTrackSampleInstance; {$ifdef csdk}stdcall; [public,alias:'_SynthCreateTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 GetMemAligned(result,sizeof(TSynthTrackSampleInstance));
 FillChar(result^,sizeof(TSynthTrackSampleInstance),#0);
 result^.Parent:=TrackSample;
 if assigned(TrackSample^.TrackSampleInstanceLast) then begin
  TrackSample^.TrackSampleInstanceLast^.Next:=result;
  result^.Previous:=TrackSample^.TrackSampleInstanceLast;
  result^.Next:=nil;
  TrackSample^.TrackSampleInstanceLast:=result;
 end else begin
  result^.Previous:=nil;
  result^.Next:=nil;
  TrackSample^.TrackSampleInstanceRoot:=result;
  TrackSample^.TrackSampleInstanceLast:=result;
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthDestroyTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall; [public,alias:'_SynthDestroyTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if assigned(TrackSampleInstance^.Previous) then begin
  TrackSampleInstance^.Previous^.Next:=TrackSampleInstance^.Next;
 end;
 if assigned(TrackSampleInstance^.Next) then begin
  TrackSampleInstance^.Next^.Previous:=TrackSampleInstance^.Previous;
 end;
 if assigned(TrackSampleInstance^.Parent) then begin
  if TrackSampleInstance^.Parent^.TrackSampleInstanceRoot=TrackSampleInstance then begin
   TrackSampleInstance^.Parent^.TrackSampleInstanceRoot:=TrackSampleInstance^.Next;
  end;
  if TrackSampleInstance^.Parent^.TrackSampleInstanceLast=TrackSampleInstance then begin
   TrackSampleInstance^.Parent^.TrackSampleInstanceLast:=TrackSampleInstance^.Previous;
  end;
 end;
 TrackSampleInstance^.Previous:=nil;
 TrackSampleInstance^.Next:=nil;
 FreeMemAligned(TrackSampleInstance);
end;
{$else}
begin
end;
{$endif}

procedure SynthStartTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall; [public,alias:'_SynthStartTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 TrackSampleInstance^.Volume:=0.5;
 TrackSampleInstance^.Panning:=0.5;
 TrackSampleInstance^.PanningVolumeLeft:=0.5;
 TrackSampleInstance^.PanningVolumeRight:=0.5;
 TrackSampleInstance^.Position:=0;
 TrackSampleInstance^.Increment:=i32;
 TrackSampleInstance^.Active:=true;
 TrackSampleInstance^.KeyOff:=false;
 TrackSampleInstance^.Backwards:=false;
 TrackSampleInstance^.LastLeft:=0;
 TrackSampleInstance^.LastRight:=0;
 SynthUpdateTrackSampleInstance(TrackSampleInstance);
end;
{$else}
begin
end;
{$endif}

procedure SynthStopTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall; [public,alias:'_SynthStopTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.Active:=false;
 TrackSampleInstance^.Parent^.LastLeft:=TrackSampleInstance^.Parent^.LastLeft+TrackSampleInstance^.LastLeft;
 TrackSampleInstance^.Parent^.LastRight:=TrackSampleInstance^.Parent^.LastRight+TrackSampleInstance^.LastRight;
end;
{$else}
begin
end;
{$endif}

procedure SynthKeyOffTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall; [public,alias:'_SynthKeyOffTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.KeyOff:=true;
end;
{$else}
begin
end;
{$endif}

procedure SynthUpdateTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance); {$ifdef csdk}stdcall; [public,alias:'_SynthUpdateTrackSampleInstance@4'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
var RampingSamples:longint;
    VolumeLeft,VolumeRight:single;
begin
 if TrackSampleInstance^.Active then begin
  RampingSamples:=TrackSampleInstance^.Parent^.Parent^.RampingSamples;
  if RampingSamples>0 then begin
   VolumeLeft:=TrackSampleInstance^.Volume*TrackSampleInstance^.PanningVolumeLeft;
   VolumeRight:=TrackSampleInstance^.Volume*TrackSampleInstance^.PanningVolumeRight;
   TrackSampleInstance^.DestVolumeLeft:=VolumeLeft;
   TrackSampleInstance^.DestVolumeRight:=VolumeRight;
   SynthKillDenormal(TrackSampleInstance^.DestVolumeLeft);
   SynthKillDenormal(TrackSampleInstance^.DestVolumeRight);
   TrackSampleInstance^.VolumeRampingRemain:=RampingSamples;
   TrackSampleInstance^.VolumeRampingLeft:=(TrackSampleInstance^.DestVolumeLeft-TrackSampleInstance^.VolumeLeft)/TrackSampleInstance^.VolumeRampingRemain;
   TrackSampleInstance^.VolumeRampingRight:=(TrackSampleInstance^.DestVolumeRight-TrackSampleInstance^.VolumeRight)/TrackSampleInstance^.VolumeRampingRemain;
   SynthKillDenormal(TrackSampleInstance^.VolumeRampingLeft);
   SynthKillDenormal(TrackSampleInstance^.VolumeRampingRight);
  end;
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthSetTrackSampleInstanceVolume(TrackSampleInstance:PSynthTrackSampleInstance;Volume:single); {$ifdef csdk}stdcall; [public,alias:'_SynthSetTrackSampleInstanceVolume@8'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.Volume:=Volume;
 SynthUpdateTrackSampleInstance(TrackSampleInstance);
end;
{$else}
begin
end;
{$endif}

procedure SynthSetTrackSampleInstancePanning(TrackSampleInstance:PSynthTrackSampleInstance;Panning:single); {$ifdef csdk}stdcall; [public,alias:'_SynthSetTrackSampleInstancePanning@8'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.Panning:=Panning;
 TrackSampleInstance^.PanningVolumeLeft:=cos(TrackSampleInstance^.Panning*halfpi);
 TrackSampleInstance^.PanningVolumeRight:=sin(TrackSampleInstance^.Panning*halfpi);
 SynthUpdateTrackSampleInstance(TrackSampleInstance);
end;
{$else}
begin
end;
{$endif}

procedure SynthSetTrackSampleInstancePanningLeftRight(TrackSampleInstance:PSynthTrackSampleInstance;PanningLeft,PanningRight:single); {$ifdef csdk}stdcall; [public,alias:'_SynthSetTrackSampleInstancePanningLeftRight@12'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.PanningVolumeLeft:=PanningLeft;
 TrackSampleInstance^.PanningVolumeRight:=PanningRight;
 SynthUpdateTrackSampleInstance(TrackSampleInstance);
end;
{$else}
begin
end;
{$endif}

procedure SynthSetTrackSampleInstancePitch(TrackSampleInstance:PSynthTrackSampleInstance;Pitch:single); {$ifdef csdk}stdcall; [public,alias:'_SynthSetTrackSampleInstancePitch@8'];{$endif}
{$ifndef BR808EXEMUSPLAYER}
begin
 if not TrackSampleInstance^.Active then exit;
 TrackSampleInstance^.Increment:=round64(Pitch*i32);
 if TrackSampleInstance^.Backwards then begin
  TrackSampleInstance^.Increment:=-TrackSampleInstance^.Increment;
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthResetVoices(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthResetVoices@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var Counter,SubCounter:longint;
    CurrentLinkTrack:PSynthTrack;
begin
 CurrentLinkTrack:=Track^.LinkRoot;
 while assigned(CurrentLinkTrack) do begin
  SynthResetVoices(CurrentLinkTrack);
  CurrentLinkTrack:=CurrentLinkTrack^.LinkNext;
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  FillChar(Track^.Voices[Counter],sizeof(TSynthVoice),#0);
  Track^.Voices[Counter].Number:=Counter;
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.UpperRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,0];
   Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString.LowerRail.Buffer:=Track^.PluckedStringBuffers[Counter,SubCounter,1];
   SynthPluckedStringInit(Track,Track^.Voices[Counter].OscillatorData[SubCounter].PluckedString);
  end;
  Track^.Voices[Counter].Channel:=@Track^.Channels[0];
 end;
end;

procedure SynthChannelResetControllers(Track:PSynthTrack;Channel:PSynthChannel;All:boolean); forward;

procedure SynthResetChannels(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthResetChannels@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var Counter,SubCounter:longint;
    CurrentLinkTrack:PSynthTrack;
begin
 CurrentLinkTrack:=Track^.LinkRoot;
 while assigned(CurrentLinkTrack) do begin
  SynthResetChannels(CurrentLinkTrack);
  CurrentLinkTrack:=CurrentLinkTrack^.LinkNext;
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   FillChar(Track^.PluckedStringBuffers[Counter,SubCounter,0]^,(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue),#0);
   FillChar(Track^.PluckedStringBuffers[Counter,SubCounter,1]^,(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue),#0);
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  Track^.Channels[Counter].Number:=Counter;
  FillChar(Track^.Channels[Counter].NRPNControllers,sizeof(TSynthNRPNControllers),#0);
  FillChar(Track^.Channels[Counter].Controllers,sizeof(TSynthControllers),#0);
  FillChar(Track^.Channels[Counter].WorkControllers,sizeof(TSynthControllers),#0);
  for SubCounter:=0 to MaxInstrumentDelay-1 do begin
   if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
    FillChar(Track^.Channels[Counter].DelayBuffer[SubCounter]^,Track^.DelayBufferSize*sizeof(TSynthBufferSample),#$0);
   end;
  end;
  FillChar(Track^.Channels[Counter].ChorusFlangerBuffer^,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample),#0);
  FillChar(Track^.Channels[Counter].CompressorBuffer^,Track^.POTBufferSize*sizeof(TSynthBufferSample),#0);
  FillChar(Track^.Channels[Counter].ChannelCompressorData,sizeof(TSynthCompressorData),#0);
  FillChar(Track^.Channels[Counter].ChannelFilterData,sizeof(TSynthInstrumentFilterData),#0);
  FillChar(Track^.Channels[Counter].ChannelEQData,sizeof(TSynthEQData),#0);
  FillChar(Track^.Channels[Counter].ChannelDistortionData,sizeof(TSynthInstrumentDistortionData),#0);
  FillChar(Track^.Channels[Counter].ChannelDelayData,sizeof(TSynthDelayData),#0);
  FillChar(Track^.Channels[Counter].ChannelChorusFlangerData,sizeof(TSynthChorusFlangerData),#0);
  FillChar(Track^.Channels[Counter].ChannelPitchShifterData,sizeof(TSynthPitchShifterData),#0);
  FillChar(Track^.Channels[Counter].ChannelLFOData,sizeof(TSynthChannelLFOData),#0);
  Track^.Channels[Counter].OmniMode:=true;
  Track^.Channels[Counter].PolyMode:=true;
  Track^.Channels[Counter].Balance:=64 shl 7;
  Track^.Channels[Counter].Panning:=64 shl 7;
  Track^.Channels[Counter].Expression:=127 shl 7;
  Track^.Channels[Counter].MainVolume:=100 shl 7;
  Track^.Channels[Counter].Modulation:=0;
  Track^.Channels[Counter].Breath:=0;
  Track^.Channels[Counter].PitchBendDepthSemitones:=2;
  Track^.Channels[Counter].PitchBendDepthCents:=0;
  Track^.Channels[Counter].PitchBend:=$2000;
  Track^.Channels[Counter].PortamentoTime:=0;
  Track^.Channels[Counter].FootPedal:=0;
  Track^.Channels[Counter].HoldPedal:=false;
  Track^.Channels[Counter].PortamentoPedal:=false;
  Track^.Channels[Counter].SostenutoPedal:=false;
  Track^.Channels[Counter].SoftPedal:=false;
  Track^.Channels[Counter].LegatoPedal:=false;
  Track^.Channels[Counter].Hold2Pedal:=false;
  Track^.Channels[Counter].Patch:=Track^.ChannelInitialPrograms[Counter];
  Track^.Channels[Counter].Bank:=0;
  Track^.Channels[Counter].RPN.NParameter:=0;
  Track^.Channels[Counter].RPN.Parameter:=0;
  Track^.Channels[Counter].RPN.Data:=0;
  Track^.Channels[Counter].NRPNSelect:=0;
  Track^.Channels[Counter].TuningBank:=0;
  Track^.Channels[Counter].TuningProgram:=0;
  Track^.Channels[Counter].CoarseTuning:=$2000;
  Track^.Channels[Counter].FineTuning:=$2000;
  Track^.Channels[Counter].Instrument:=@Track^.Instruments[Track^.ChannelInitialPrograms[Counter]];
  Track^.Channels[Counter].LastVolumeFactor:=1;
  Track^.Channels[Counter].LastInstrument:=nil;
  Track^.Channels[Counter].LastVoiceInstrument:=nil;
  Track^.Channels[Counter].RampingVolume.Active:=false;
  Track^.Channels[Counter].RampingExpression.Active:=false;
  Track^.Channels[Counter].RampingPanning.Active:=false;
  Track^.Channels[Counter].RampingBreath.Active:=false;
  Track^.Channels[Counter].RampingModulation.Active:=false;
  Track^.Channels[Counter].RampingPortamentoTime.Active:=false;
  Track^.Channels[Counter].RampingFootPedal.Active:=false;
  Track^.Channels[Counter].RampingHoldPedal.Active:=false;
  Track^.Channels[Counter].RampingPortamentoPedal.Active:=false;
  Track^.Channels[Counter].RampingSostenutoPedal.Active:=false;
  Track^.Channels[Counter].RampingSoftPedal.Active:=false;
  Track^.Channels[Counter].RampingLegatoPedal.Active:=false;
  Track^.Channels[Counter].RampingHold2Pedal.Active:=false;
  for SubCounter:=0 to 127 do begin
   Track^.Channels[Counter].RampingControllers[SubCounter].Active:=false;
  end;
  for SubCounter:=0 to 255 do begin
   Track^.Channels[Counter].RampingNRPNControllers[SubCounter].Active:=false;
  end;
  SynthChannelResetControllers(Track,@Track^.Channels[Counter],true);
 end;
end;

procedure SynthReset(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthReset@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var Counter,SubCounter:longint;
    CurrentLinkTrack:PSynthTrack;
begin
 CurrentLinkTrack:=Track^.LinkRoot;
 while assigned(CurrentLinkTrack) do begin
  SynthReset(CurrentLinkTrack);
  CurrentLinkTrack:=CurrentLinkTrack^.LinkNext;
 end;
 Track^.OmniMode:=true;
 Track^.OmniChannel:=0;
 Track^.GeneralMIDIMode:=1;
 Track^.VoiceAllocationAlgorithm:=0;
 Track^.GlobalData.Reverb.LastLowPassLeft:=0;
 Track^.GlobalData.Reverb.LastLowPassRight:=0;
 Track^.GlobalData.Reverb.LeftDelayedCounter:=0;
 Track^.GlobalData.Reverb.RightDelayedCounter:=0;
 Track^.GlobalData.Reverb.LeftCounter:=0;
 Track^.GlobalData.Reverb.RightCounter:=0;
 Track^.GlobalData.Reverb.Ready:=false;
 Track^.GlobalLFOPhase:=0;
 Track^.GlobalLFOPhaseIncrement:=1*Track^.InternalSampleRateFactor;
 FillChar(Track^.WorkBuffers^,sizeof(TSynthWorkBuffers),#0);
 SynthInitValueBuffers(Track);
 FillChar(Track^.Buffer^,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample),#$0);
{$ifdef MultiOutput}
 for Counter:=0 to NumberOfChannels-1 do begin
  FillChar(Track^.ChannelBuffer[Counter]^,(Track^.InternalBufferSamples+16)*sizeof(TSynthBufferSample),#0);
 end;
{$endif}
 FillChar(Track^.GlobalData.Compressor,sizeof(TSynthCompressorData),#0);
 FillChar(Track^.GlobalData.FinalCompressor,sizeof(TSynthCompressorData),#0);
 FillChar(Track^.GlobalData.DelayBuffer^,Track^.DelayBufferSize*sizeof(TSynthBufferSample),#$0);
 FillChar(Track^.GlobalData.ChorusFlangerBuffer^,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample),#0);
 FillChar(Track^.GlobalData.CompressorBuffer^,Track^.POTBufferSize*sizeof(TSynthBufferSample),#0);
 FillChar(Track^.GlobalData.PitchShifter.Buffer,sizeof(Track^.GlobalData.PitchShifter.Buffer),#0);
 FillChar(Track^.GlobalData.Reverb.LeftBuffer^,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue),#0);
 FillChar(Track^.GlobalData.Reverb.RightBuffer^,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue),#0);
 FillChar(Track^.GlobalData.Reverb.Counter,sizeof(Track^.GlobalData.Reverb.Counter),#0);
 for Counter:=0 to MaxReverbAllPassFilters-1 do begin
  FillChar(Track^.GlobalData.Reverb.AllPassBuffer[Counter]^,Track^.InternalSampleRate*2*sizeof(TSynthBufferSample),#$0);
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  for SubCounter:=0 to MaxInstrumentOscillator-1 do begin
   FillChar(Track^.PluckedStringBuffers[Counter,SubCounter,0]^,(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue),#0);
   FillChar(Track^.PluckedStringBuffers[Counter,SubCounter,1]^,(Track^.InternalSampleRate div 4)*sizeof(TSynthFloatValue),#0);
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  for SubCounter:=0 to MaxInstrumentDelay-1 do begin
   if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
    FillChar(Track^.Channels[Counter].DelayBuffer[SubCounter]^,Track^.DelayBufferSize*sizeof(TSynthBufferSample),#$0);
   end;
  end;
  FillChar(Track^.Channels[Counter].ChorusFlangerBuffer^,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample),#$0);
  FillChar(Track^.Channels[Counter].CompressorBuffer^,Track^.POTBufferSize*sizeof(TSynthBufferSample),#$0);
  FillChar(Track^.Channels[Counter].Buffer^,FixedWorkBufferSize*sizeof(TSynthBufferSample),#$0);
  FillChar(Track^.Channels[Counter].ChannelCompressorData,sizeof(TSynthCompressorData),#0);
  FillChar(Track^.Channels[Counter].ChannelFilterData,sizeof(TSynthInstrumentFilterData),#0);
  FillChar(Track^.Channels[Counter].ChannelEQData,sizeof(TSynthEQData),#0);
  FillChar(Track^.Channels[Counter].ChannelDistortionData,sizeof(TSynthInstrumentDistortionData),#0);
  FillChar(Track^.Channels[Counter].ChannelDelayData,sizeof(TSynthDelayData),#0);
  FillChar(Track^.Channels[Counter].ChannelChorusFlangerData,sizeof(TSynthChorusFlangerData),#0);
  FillChar(Track^.Channels[Counter].ChannelPitchShifterData,sizeof(TSynthPitchShifterData),#0);
 end;
 for Counter:=0 to MaxThreads-1 do begin
  for SubCounter:=0 to MaxInstrumentADSR-1 do begin
   Track^.ADSRBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentEnvelopes-1 do begin
   Track^.EnvelopeBuffersActive[Counter,SubCounter]:=false;
  end;
  for SubCounter:=0 to MaxInstrumentLFO-1 do begin
   Track^.LFOBuffersActive[Counter,SubCounter]:=false;
  end;
 end;
 SynthResetChannels(Track);
 SynthResetVoices(Track);
 FillChar(Track^.GlobalData.EndFilter,sizeof(TSynthEndFilterData),#0);
{$ifdef BR808DELAY}
 SynthProcessDelayInit(Track,@Track^.Global.Delay,@Track^.GlobalData.Delay);
{$endif}
{$ifdef BR808CHORUSFLANGER}
 SynthProcessChorusFlangerInit(Track,@Track^.Global.ChorusFlanger,@Track^.GlobalData.ChorusFlanger);
 SynthProcessChorusFlangerKeyOn(Track,@Track^.Global.ChorusFlanger,@Track^.GlobalData.ChorusFlanger,false,false,nil,nil);
{$endif}
{$ifdef BR808PITCHSHIFTER}
 SynthProcessPitchShifterInit(Track,@Track^.Global.PitchShifter,@Track^.GlobalData.PitchShifter);
{$endif}
{$ifdef BR808EQ}
 SynthProcessEQInit(Track,@Track^.Global.EQ,@Track^.GlobalData.EQ);
{$endif}
{$ifdef BR808COMPRESSOR}
 SynthProcessCompressorInit(Track,@Track^.Global.Compressor,@Track^.GlobalData.Compressor);
 SynthProcessCompressorInit(Track,@Track^.Global.FinalCompressor,@Track^.GlobalData.FinalCompressor);
{$endif}
 for Counter:=0 to NumberOfChannels-1 do begin
{$ifdef BR808PITCHSHIFTER}
  SynthProcessPitchShifterInit(Track,@Track^.Instruments[0].ChannelPitchShifter,@Track^.Channels[Counter].ChannelPitchShifterData);
{$endif}
{$ifdef BR808EQ}
  SynthProcessEQInit(Track,@Track^.Instruments[0].ChannelEQ,@Track^.Channels[Counter].ChannelEQData);
{$endif}
 end;
{$ifdef VSTi}
 Track^.CurrentEvent:=nil;
{$else}
 Track^.CurrentEvent:=Track^.EventQuery;
{$endif}
 Track^.ProcessedSamples:=0;
{$ifdef textdebug}
 Track^.TimeDebug:=0;
 Track^.DebugWait:=true;
{$endif}
 Track^.Time:=0;
 Track^.DifferenceTicksIncrement:=0;
 Track^.SamplesRemain:=0;
 SynthChangeTempo(Track);
{$ifdef WIN32Plain}
 if Track^.SoundOutput then begin
  waveOutReset(Track^.WaveOutHandle);
  Track^.BufferCounter:=0;
  Track^.LastGetPositionSample:=0;
  Track^.AddGetPositionSample:=0;
  Track^.FirstBufferTime:=timeGetTime;
  Track^.FirstBufferSample:=0;
  Track^.FirstBuffer:=true;
 end;
{$endif}
 Track^.AGCFactor:=1;
end;

procedure SynthCheckDelayBuffers(Track:PSynthTrack);
var Counter,SubCounter:longint;
    Instrument:PSynthInstrument;
begin
 for Counter:=0 to NumberOfChannels-1 do begin
  Instrument:=Track^.Channels[Counter].Instrument;
  if assigned(Instrument) then begin
   for SubCounter:=0 to MaxInstrumentDelay-1 do begin
    if Instrument^.ChannelDelay[SubCounter].Active then begin
     if not assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
      GetMemZero(Track^.Channels[Counter].DelayBuffer[SubCounter],Track^.DelayBufferSize*sizeof(TSynthBufferSample));
     end;
    end else begin
     if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
      FreeMemAligned(Track^.Channels[Counter].DelayBuffer[SubCounter]);
      Track^.Channels[Counter].DelayBuffer[SubCounter]:=nil;
     end;
    end;
   end;
  end else begin
   for SubCounter:=0 to MaxInstrumentDelay-1 do begin
    if assigned(Track^.Channels[Counter].DelayBuffer[SubCounter]) then begin
     FreeMemAligned(Track^.Channels[Counter].DelayBuffer[SubCounter]);
     Track^.Channels[Counter].DelayBuffer[SubCounter]:=nil;
    end;
   end;
  end;
 end;
end;

procedure SynthAddEvent(Track:PSynthTrack;NewEvent:PSynthEvent); {$ifdef csdk}stdcall; [public,alias:'_SynthAddEvent@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifdef vsti}
var Event,LastEvent,EventToAdd:PSynthEvent;
begin
 if not assigned(Track) then exit;
 GetMemAligned(EventToAdd,sizeof(TSynthEvent));
 EventToAdd^:=NewEvent^;
 if assigned(NewEvent^.SysEx) and (NewEvent^.SysExLen>0) then begin
  EventToAdd^.SysEx:=nil;
  EventToAdd^.SysExLen:=NewEvent^.SysExLen;
  GetMemAligned(EventToAdd^.SysEx,EventToAdd^.SysExLen);
  Move(NewEvent^.SysEx^,EventToAdd^.SysEx^,EventToAdd^.SysExLen);
 end else begin
  EventToAdd^.SysEx:=nil;
  EventToAdd^.SysExLen:=0;
 end;
 EventToAdd^.Previous:=nil;
 EventToAdd^.Next:=nil;
 if assigned(Track^.LastEvent) and ((EventToAdd^.Time>=Track^.LastEvent^.Time) or ((EventToAdd^.Time=Track^.LastEvent^.Time) and (EventToAdd^.ID>=Track^.LastEvent^.ID))) then begin
  Event:=Track^.LastEvent;
 end else begin
  Event:=Track^.EventQuery;
 end;
 LastEvent:=Event;
 while assigned(Event) and ((EventToAdd^.Time>Event^.Time) or ((EventToAdd^.Time=Event^.Time) and (EventToAdd^.ID>=Event^.ID))) do begin
  LastEvent:=Event;
  Event:=Event^.Next;
 end;
 if assigned(LastEvent) then begin
  if (EventToAdd^.Time<LastEvent^.Time) or ((EventToAdd^.Time=LastEvent^.Time) and (EventToAdd^.ID<LastEvent^.ID)) then begin
   if LastEvent=Track^.EventQuery then begin
    Track^.EventQuery:=EventToAdd;
    Track^.CurrentEvent:=EventToAdd;
   end;
   EventToAdd^.Next:=LastEvent;
  end else begin
   EventToAdd^.Next:=LastEvent^.Next;
   LastEvent^.Next:=EventToAdd;
   if LastEvent=Track.LastEvent then begin
    Track^.LastEvent:=EventToAdd;
   end;
  end;
 end else begin
  Track^.EventQuery:=EventToAdd;
  Track^.CurrentEvent:=EventToAdd;
  Track^.LastEvent:=EventToAdd;
 end;
end;
{$else}
 procedure Skew(oldparent:PSynthEvent);
 var newp:PSynthEvent;
 begin
{$ifdef VSTi}
  assert(assigned(oldparent));
{$endif}
  newp:=oldparent^.Left;
{$ifdef VSTi}
  assert(assigned(newp));
{$endif}
  if oldparent^.parent^.left=oldparent then begin
   oldparent^.parent^.left:=newp;
  end else begin
   oldparent^.parent^.right:=newp;
  end;
  newp^.parent:=oldparent^.parent;
  oldparent^.parent:=newp;

  oldparent^.left:=newp^.right;
  if assigned(oldparent^.left) then begin
   oldparent^.left^.parent:=oldparent;
  end;
  newp^.right:=oldparent;

  if assigned(oldparent^.left) then begin
   oldparent^.level:=oldparent^.left^.level+1;
  end else begin                                              
   oldparent^.level:=1;
  end;
 end;
 function Split(oldparent:PSynthEvent):boolean;
 var newp:PSynthEvent;
 begin
{$ifdef VSTi}
  assert(assigned(oldparent));
{$endif}
  newp:=oldparent^.Right;
  if assigned(newp) and assigned(newp^.right) and (newp^.right^.level=oldparent^.Level) then begin
   if oldparent^.parent^.left=oldparent then begin
    oldparent^.parent^.left:=newp;
   end else begin
    oldparent^.parent^.right:=newp;
   end;
   newp^.parent:=oldparent^.parent;
   oldparent^.parent:=newp;

   oldparent^.right:=newp^.left;
   if assigned(oldparent^.right) then begin
    oldparent^.right^.parent:=oldparent;
   end;
   newp^.left:=oldparent;

   newp^.level:=oldparent^.level+1;

   result:=true;
  end else begin
   result:=false;
  end;
 end;
 procedure RebalanceAfterLeafAdd(n:PSynthEvent);
 begin
  // n is a node that has just been inserted and is now a leaf node.
  n^.Level:=1;
  n^.Left:=nil;
  n^.Right:=nil;
  n:=n^.Parent;
  while n<>@Track^.BalancedRootEvent do begin
   if (assigned(n^.Left) and (n^.Level<>(n^.Left^.Level+1))) or ((not assigned(n^.Left)) and (n^.Level<>1)) then begin
    // this point the tree is correct, except (AA2) for n->parent
    Skew(n);
    // We handle it (a left add) by changing it into a right add using Skew
    // If the original add was to the left side of a node that is on the
    // right side of a horisontal link, n now points to the rights side
    // of the second horisontal link, which is correct.
    // However if the original add was to the left of node with a horisontal
    // link, we must get to the right side of the second link.
    if (not assigned(n^.Right)) or (n^.Level<>n^.Right^.Level) then begin
     n:=n^.Parent;
    end;
   end;
   if not Split(n^.Parent) then begin
    break;
   end;
   n:=n^.Parent;
  end;
 end;
var EventToAdd,s,n,l:PSynthEvent;
    LessThan,OK:boolean;
    Pool:PSynthEventPool;
begin
 if not assigned(Track) then begin
  exit;
 enD;
 EventToAdd:=nil;
 Pool:=@Track^.EventPool;
 while assigned(Pool) do begin
  if Pool^.Position<EventPoolSize then begin
   EventToAdd:=@Pool^.Events[Pool^.Position];
   inc(Pool^.Position);
   break;
  end else begin
   if not assigned(Pool^.Next) then begin
    GetMemZero(Pool^.Next,sizeof(TSynthEventPool));
    Pool^.Next^.Position:=0;
    Pool^.Next^.Next:=nil;
   end;
   Pool:=Pool^.Next;
  end
 end;
 if not assigned(EventToAdd) then begin
  exit;
 end;
 EventToAdd^:=NewEvent^;
 if assigned(NewEvent^.SysEx) and (NewEvent^.SysExLen>0) then begin
  EventToAdd^.SysEx:=nil;
  EventToAdd^.SysExLen:=NewEvent^.SysExLen;
  GetMemAligned(EventToAdd^.SysEx,EventToAdd^.SysExLen);
  Move(NewEvent^.SysEx^,EventToAdd^.SysEx^,EventToAdd^.SysExLen);
 end else begin
  EventToAdd^.SysEx:=nil;
  EventToAdd^.SysExLen:=0;
 end;
 EventToAdd^.Previous:=nil;
 EventToAdd^.Next:=nil;
 EventToAdd^.Parent:=nil;
 EventToAdd^.Left:=nil;
 EventToAdd^.Right:=nil;
 EventToAdd^.Level:=0;
 s:=@Track^.BalancedRootEvent;
 LessThan:=true;
 n:=nil;
 OK:=true;
 while (LessThan and assigned(s^.Left)) or ((not LessThan) and assigned(s^.Right)) do begin
  if (s<>@Track^.BalancedRootEvent) and ((EventToAdd^.Time=s^.Time) and (EventToAdd^.ID=s^.ID)) then begin
   n:=s;
   OK:=false;
   break;
  end else if LessThan then begin
   s:=s^.Left;
  end else begin
   n:=s;
   s:=s^.Right;
  end;
  LessThan:=(EventToAdd^.Time<s^.Time) or ((EventToAdd^.Time=s^.Time) and (EventToAdd^.ID<s^.ID));
 end;
 if s=@Track^.BalancedRootEvent then begin
  l:=Track^.BalancedRootEvent.Left;
 end else begin
  l:=s;
 end;
 while assigned(l) do begin
  if (EventToAdd^.Time=l^.Time) and (EventToAdd^.ID=l^.ID) then begin
   n:=l;
   OK:=false;
   break;
  end else if (EventToAdd^.Time<l^.Time) or ((EventToAdd^.Time=l^.Time) and (EventToAdd^.ID<l^.ID)) then begin
   l:=l^.Left;
  end else begin
   n:=l;
   l:=l^.Right;
  end;
 end;
 if OK then begin
  if LessThan then begin
   s^.Left:=EventToAdd;
  end else begin
   s^.Right:=EventToAdd;
  end;
  EventToAdd^.Parent:=s;
  RebalanceAfterLeafAdd(EventToAdd);
 end;
 if not assigned(Track^.EventQuery) then begin
  Track^.EventQuery:=EventToAdd;
  Track^.CurrentEvent:=EventToAdd;
  Track^.LastEvent:=EventToAdd;
 end else if (EventToAdd^.Time<Track^.EventQuery^.Time) or ((EventToAdd^.Time=Track^.EventQuery^.Time) and (EventToAdd^.ID<Track^.EventQuery^.ID)) then begin
  EventToAdd^.Next:=Track^.EventQuery;
  EventToAdd^.Previous:=Track^.EventQuery^.Previous;
  if assigned(Track^.EventQuery^.Previous) then begin
   Track^.EventQuery^.Previous^.Next:=EventToAdd;
  end;
  Track^.EventQuery^.Previous:=EventToAdd;
  Track^.EventQuery:=EventToAdd;
  Track^.CurrentEvent:=EventToAdd;
 end else if assigned(Track^.LastEvent) and ((EventToAdd^.Time>=Track^.LastEvent^.Time) or ((EventToAdd^.Time=Track^.LastEvent^.Time) and (EventToAdd^.ID>=Track^.LastEvent^.ID))) then begin
  s:=Track^.LastEvent;
  EventToAdd^.Next:=s^.Next;
  EventToAdd^.Previous:=s;
  if assigned(s^.Next) then begin
   s^.Next^.Previous:=EventToAdd;
  end;
  s^.Next:=EventToAdd;
  if s=Track.LastEvent then begin
   Track^.LastEvent:=EventToAdd;
  end;
 end else begin
  l:=s;
  s:=n;
  while assigned(n) and ((EventToAdd^.Time>n^.Time) or ((EventToAdd^.Time=n^.Time) and (EventToAdd^.ID>=n^.ID))) do begin
   s:=n;
   n:=n^.Next;
  end;
  if not assigned(s) then begin
   if l<>@Track^.BalancedRootEvent then begin
    n:=l;
    s:=n;
    while assigned(n) and ((EventToAdd^.Time>n^.Time) or ((EventToAdd^.Time=n^.Time) and (EventToAdd^.ID>=n^.ID))) do begin
     s:=n;
     n:=n^.Next;
    end;
   end;
   if not assigned(s) then begin
    n:=Track^.EventQuery;
    s:=n;
    while assigned(n) and ((EventToAdd^.Time>n^.Time) or ((EventToAdd^.Time=n^.Time) and (EventToAdd^.ID>=n^.ID))) do begin
     s:=n;
     n:=n^.Next;
    end;
   end;
  end;
  if assigned(s) and ((EventToAdd^.Time<s^.Time) or ((EventToAdd^.Time=s^.Time) and (EventToAdd^.ID<s^.ID))) then begin
   if s=Track^.EventQuery then begin
    Track^.EventQuery:=EventToAdd;
    Track^.CurrentEvent:=EventToAdd;
   end;
   EventToAdd^.Next:=s;
   EventToAdd^.Previous:=s^.Previous;
   if assigned(s^.Previous) then begin
    s^.Previous^.Next:=EventToAdd;
   end;
   s^.Previous:=EventToAdd;
  end else begin
   EventToAdd^.Next:=s^.Next;
   EventToAdd^.Previous:=s;
   if assigned(s^.Next) then begin
    s^.Next^.Previous:=EventToAdd;
   end;
   s^.Next:=EventToAdd;
   if s=Track.LastEvent then begin
    Track^.LastEvent:=EventToAdd;
   end;
  end;
 end;
end;
{$endif}

procedure SynthFreeTrack(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthFreeTrack@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifdef vsti}
var Event,LastEvent:PSynthEvent;
{$else}
var Pool,LastPool:PSynthEventPool;
    Event:PSynthEvent;
    i:longint;
{$endif}
begin
 if not assigned(Track) then exit;
{$ifdef vsti}
 Event:=Track^.EventQuery;
 while assigned(Event) do begin
  if assigned(Event^.SysEx) then begin
   FreeMemAligned(Event^.SysEx);
   Event^.SysEx:=nil;
  end;
  LastEvent:=Event;
  Event:=LastEvent^.Next;
  FreeMemAligned(LastEvent);
 end;
{$else}
 Pool:=@Track^.EventPool;
 while assigned(Pool) do begin
  LastPool:=Pool;
  Pool:=Pool^.Next;
  LastPool^.Next:=nil;
  for i:=0 to LastPool^.Position-1 do begin
   Event:=@LastPool^.Events[i];
   if assigned(Event) and assigned(Event^.SysEx) then begin
    FreeMemAligned(Event^.SysEx);
    Event^.SysEx:=nil;
   end;
  end;
  if LastPool<>@Track^.EventPool then begin
   FreeMemAligned(LastPool);
  end;
 end;
 Track^.EventPool.Position:=0;
 Track^.EventPool.Next:=nil;
{$endif}
 Track^.EventQuery:=nil;
 Track^.CurrentEvent:=nil;
 Track^.LastEvent:=nil;
{$ifndef vsti}
 FillChar(Track^.BalancedRootEvent,sizeof(TSynthEvent),#0);
 Track^.BalancedRootEvent.Level:=$7fffffffffffffff;
{$endif}
end;

procedure SynthClearTrack(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthClearTrack@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var SubTrack,NextSubTrack:PSynthTrack;
begin
 if not assigned(Track) then exit;
 SubTrack:=Track^.LinkRoot;
 while assigned(SubTrack) do begin
  NextSubTrack:=SubTrack^.LinkNext;
  if SubTrack^.LinkContentDestroy then begin
   SynthDestroy(SubTrack);
  end;
  SubTrack:=NextSubTrack;
 end;
 SynthFreeTrack(Track);
end;

{$ifdef VSTi}
procedure SynthFreeEventsVSTi(Track:PSynthTrack;Samples:longint); {$ifdef cpu386}register;{$endif}
var Event,LastEvent:PSynthEvent;
begin
 if not assigned(Track) then exit;
 Event:=Track^.EventQuery;
 while assigned(Event) do begin
  if Event^.Time<Samples then begin
   if assigned(Event^.SysEx) then begin
    FreeMemAligned(Event^.SysEx);
    Event^.SysEx:=nil;
   end;
   LastEvent:=Event;
   Event:=LastEvent^.Next;
   if Track^.EventQuery=LastEvent then begin
    Track^.EventQuery:=Event;
   end;
   if Track^.CurrentEvent=LastEvent then begin
    Track^.CurrentEvent:=Event;
   end;
   if Track^.LastEvent=LastEvent then begin
    Track^.LastEvent:=Event;
   end;
   FreeMemAligned(LastEvent);
  end else begin
   dec(Event^.Time,Samples);
   Event:=Event^.Next;
  end;
 end;
end;
{$endif}

function SynthReadBankInformations(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall; [public,alias:'_SynthReadBankInformations@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var SourcePointer:pbyte;
    DataPosition:longword;
    x:longword;
 function Read(var Buffer;LengthCounter:longword):longword;
 var DestPointer:pbyte;
 begin
  result:=0;
  DestPointer:=@Buffer;
  while (DataPosition<DataSize) and (result<LengthCounter) do begin
   DestPointer^:=SourcePointer^;
   inc(SourcePointer);
   inc(DestPointer);
   inc(DataPosition);
   inc(result);
  end;
 end;
begin
 result:=false;
 if (DataPosition=0) or not assigned(Data) then exit;
 SourcePointer:=Data;
 DataPosition:=0;
 if Read(x,sizeof(longword))<>sizeof(longword) then exit;
 SwapLittleEndianData32(x);
 if x<>BR808SynthesizerVersion then begin
  exit;
 end;
 if Read(x,sizeof(longword))<>sizeof(longword) then exit;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.TrackName,x);
 if Read(Track^.Informations.TrackName^,x)<>x then exit;
 if Read(x,sizeof(longword))<>sizeof(longword) then exit;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.Author,x);
 if Read(Track^.Informations.Author^,x)<>x then exit;
 if Read(x,sizeof(longword))<>sizeof(longword) then exit;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.Comments,x);
 if Read(Track^.Informations.Comments^,x)<>x then exit;
end;

function SynthReadBank(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall; [public,alias:'_SynthReadBank@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var SourcePointer:pbyte;
    DataPosition:longword;
    i,j,k,h:longint;
    x:longword;
    ADPCMIMAState:TSynthADPCMIMAState;
    si:smallint;
    b:byte;
 function Read(var Buffer;LengthCounter:longword):longword;
 var DestPointer:pbyte;
 begin
  result:=0;
  DestPointer:=@Buffer;
  while (DataPosition<DataSize) and (result<LengthCounter) do begin
   DestPointer^:=SourcePointer^;
   inc(SourcePointer);
   inc(DestPointer);
   inc(DataPosition);
   inc(result);
  end;
 end;
begin
 result:=false;
 if (DataSize=0) or not assigned(Data) then exit;
 SourcePointer:=Data;
 DataPosition:=0;
 if Read(x,sizeof(longword))<>sizeof(longword) then begin
  exit;
 end;
 SwapLittleEndianData32(x);
 if x<>BR808SynthesizerVersion then begin
  exit;
 end;
 if Read(x,sizeof(longword))<>sizeof(longword) then begin
  exit;
 end;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.TrackName,x);
 if Read(Track^.Informations.TrackName^,x)<>x then begin
  exit;
 end;
 if Read(x,sizeof(longword))<>sizeof(longword) then begin
  exit;
 end;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.Author,x);
 if Read(Track^.Informations.Author^,x)<>x then begin
  exit;
 end;
 if Read(x,sizeof(longword))<>sizeof(longword) then begin
  exit;
 end;
 SwapLittleEndianData32(x);
 GetMemZero(Track^.Informations.Comments,x);
 if Read(Track^.Informations.Comments^,x)<>x then begin
  exit;
 end;
 if Read(Track^.Global,sizeof(TSynthGlobal))<>sizeof(TSynthGlobal) then begin
  exit;
 end;
 if Track^.Global.Voices.Count<1 then begin
  Track^.Global.Voices.Count:=1;
 end else if Track^.Global.Voices.Count>NumberOfVoices then begin
  Track^.Global.Voices.Count:=NumberOfVoices;
 end;
 for i:=0 to NumberOfVoices-1 do begin
  Track^.Voices[i].Active:=false;
 end;
 SwapLittleEndianData32(Track^.Global.EQ.Octave);
 for i:=0 to MaxEQBands-1 do begin
  SwapLittleEndianData16(Track^.Global.EQ.BandHz[i]);
 end;
 for i:=0 to NumberOfChannels-1 do begin
  if Read(b,1)<>1 then begin
   exit;
  end;
  Track^.ChannelInitialPrograms[i]:=b;
  SynthProgramChange(Track,@Track^.Channels[i],b);
 end;
 for i:=0 to MaxInstruments-1 do begin
  if Read(b,1)<>1 then begin
   exit;
  end;
  if b<>0 then begin

   begin
    j:=ptruint(@Track^.Instruments[i].ModulationMatrixItems)-ptruint(@Track^.Instruments[i].Volume)+1;
    if Read(Track^.Instruments[i],j)<>longword(j) then begin
     exit;
    end;
    for j:=0 to Track^.Instruments[i].ModulationMatrixItems-1 do begin
     if Read(Track^.Instruments[i].ModulationMatrix[j],sizeof(TSynthInstrumentModulationMatrixItem))<>sizeof(TSynthInstrumentModulationMatrixItem) then begin
      exit;
     end;
    end;
    if Track^.Instruments[i].UseTuningTable then begin
     if Read(Track^.Instruments[i].TuningTable,sizeof(TSynthTuningTable))<>sizeof(TSynthTuningTable) then begin
      exit;
     end;
    end;
    SwapLittleEndianData32(Track^.Instruments[i].ChannelEQ.Octave);
    for j:=0 to MaxEQBands-1 do begin
     SwapLittleEndianData16(Track^.Instruments[i].ChannelEQ.BandHz[j]);
    end;
   end;

   begin
    for j:=0 to MaxInstrumentEnvelopes-1 do begin
     if Read(b,1)<>1 then begin
      exit;
     end;
     if b<>0 then begin
      if Read(Track^.Envelopes[i,j].NodesCount,2)<>2 then begin
       exit;
      end;
      SwapLittleEndianData16(Track^.Envelopes[i,j].NodesCount);
      if Read(Track^.Envelopes[i,j].NegValue,1)<>1 then begin
       exit;
      end;
      if Read(Track^.Envelopes[i,j].PosValue,1)<>1 then begin
       exit;
      end;
      if Read(Track^.Envelopes[i,j].LoopStart,1)<>1 then begin
       exit;
      end;
      if Read(Track^.Envelopes[i,j].LoopEnd,1)<>1 then begin
       exit;
      end;
      if Read(Track^.Envelopes[i,j].SustainLoopStart,1)<>1 then begin
       exit;
      end;
      if Read(Track^.Envelopes[i,j].SustainLoopEnd,1)<>1 then begin
       exit;
      end;
      GetMemAligned(Track^.Envelopes[i,j].Nodes,sizeof(TSynthEnvelopeNode)*(Track^.Envelopes[i,j].NodesCount+1)*2);
      Track^.Envelopes[i,j].NodesAllocated:=(Track^.Envelopes[i,j].NodesCount+1)*2;
      if Read(Track^.Envelopes[i,j].Nodes^,sizeof(TSynthEnvelopeNode)*Track^.Envelopes[i,j].NodesCount)<>longword(sizeof(TSynthEnvelopeNode)*Track^.Envelopes[i,j].NodesCount) then begin
       exit;
      end;
      for k:=0 to Track^.Envelopes[i,j].NodesCount-1 do begin
       SwapLittleEndianData16(Track^.Envelopes[i,j].Nodes^[k].Time);
      end;
     end;
    end;
   end;

   begin
    for j:=0 to MaxSamples-1 do begin
     if Read(b,1)<>1 then begin
      exit;
     end;
     if b<>0 then begin
      if Read(Track^.Samples[i,j].Header,sizeof(TSynthSampleHeader))<>sizeof(TSynthSampleHeader) then begin
       exit;
      end;
      if Read(Track^.Samples[i,j].PadSynth,sizeof(TSynthSamplePadSynth))<>sizeof(TSynthSamplePadSynth) then begin
       exit;
      end;
      Track^.Samples[i,j].PadSynth.ToGenerate:=Track^.Samples[i,j].PadSynth.Active;
      if Track^.Samples[i,j].Header.Samples>0 then begin
       GetMemZero(Track^.Samples[i,j].Data,Track^.Samples[i,j].Header.Samples*Track^.Samples[i,j].Header.Channels*sizeof(single));
      end;
      if (Track^.Samples[i,j].Header.Samples>0) and not Track^.Samples[i,j].PadSynth.Active then begin
       for h:=0 to Track^.Samples[i,j].Header.Channels-1 do begin
        ADPCMIMAState.PrevSample:=0;
        ADPCMIMAState.StepIndex:=0;
        b:=0;
        for k:=0 to Track^.Samples[i,j].Header.Samples-1 do begin
         if k=0 then begin
          if Read(si,sizeof(smallint))<>sizeof(smallint) then begin
           exit;
          end;
          SwapLittleEndianData16(si);
          ADPCMIMAState.PrevSample:=si;
          ADPCMIMAState.StepIndex:=0;
         end;
         if (k and 1)=0 then begin
          if Read(b,sizeof(byte))<>sizeof(byte) then begin
           exit;
          end;
          si:=SynthADPCMIMADecompressSample(ADPCMIMAState,b and $f);
         end else begin
          si:=SynthADPCMIMADecompressSample(ADPCMIMAState,b shr 4);
         end;
         psingles(Track^.Samples[i,j].Data)^[(k*Track^.Samples[i,j].Header.Channels)+h]:=si*fCI32768;
        end;
       end;
      end;
     end;
    end;
   end;

   begin
    for j:=0 to MaxSpeechTexts-1 do begin
     if Read(b,1)<>1 then begin
      exit;
     end;
     if b<>0 then begin
      if Read(Track^.SpeechSegmentLists[i,j].ItemCount,sizeof(longint))<>sizeof(longint) then begin
       exit;
      end;
      SwapLittleEndianData32(Track^.SpeechSegmentLists[i,j].ItemCount);
      if Track^.SpeechSegmentLists[i,j].ItemCount>0 then begin
       GetMemZero(Track^.SpeechSegmentLists[i,j].Items,Track^.SpeechSegmentLists[i,j].ItemCount*sizeof(TSynthSpeechSegmentItem));
       for k:=0 to Track^.SpeechSegmentLists[i,j].ItemCount-1 do begin
        if Read(Track^.SpeechSegmentLists[i,j].Items^[k],sizeof(TSynthSpeechSegmentItem))<>sizeof(TSynthSpeechSegmentItem) then begin
         exit;
        end;
        SwapLittleEndianData32(Track^.SpeechSegmentLists[i,j].Items^[k].SegmentIndex);
        SwapLittleEndianData32(Track^.SpeechSegmentLists[i,j].Items^[k].DurationTimeFactor);
        SwapLittleEndianData32(Track^.SpeechSegmentLists[i,j].Items^[k].WaitForEvent);
       end;
      end;
     end;
    end;
   end;

  end;

 end;

 SynthInitSamples(Track);

 result:=true;
end;

function SynthReadSMF(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall; [public,alias:'_SynthReadSMF@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
{$ifdef BR808SMF}
type PImportMIDIEvent=^TImportMIDIEvent;
     TImportMIDIEvent=record
      Previous,Next:PImportMIDIEvent;
      Position:int64;
      Command:byte;
      Data:TSynthEventData;
      SysExLength:longint;
      SysEx:pchar;
     end;

     PMIDITrack=^TMIDITrack;
     TMIDITrack=record
      Previous,Next:PMIDITrack;
      EventFirst,EventLast,CurrentEvent:PImportMIDIEvent;
     end;

     TRIFFSignature=array[1..4] of ansichar;

     TRIFFChunk=packed record
      Signature:TRIFFSignature;
      Size:longword;
     end;

     TRIFFHeaderChunk=packed record
      Chunk:TRIFFChunk;
      ID:TRIFFSignature;
     end;

     TMIDIFile=record
      TrackFirst,TrackLast:PMIDITrack;
      Position:int64;
      TicksPerQuarterNote:longint;
      Tempo:longint;
     end;

var MIDIFile:TMIDIFile;

const EventSizes:array[0..$f] of byte=(0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,0);

 function Swap32Big(const Value:longword):longword; {$ifdef cpu386}assembler; register; {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
 asm
  bswap eax
 end;
 {$else}
 begin
 {$ifdef cpu386}
  result:=((Value and $ff) shl 24) or (((Value and $ff00) shr 8) shl 16) or (((Value and $ff0000) shr 16) shl 8) or ((Value and $ff000000) shr 24);
 {$else}
  result:=Value;
 {$endif}
 end;
 {$endif}

 function Swap16Big(const Value:word):word; {$ifdef cpu386}assembler; register; {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
 asm
  xchg ah,al
 end;
 {$else}
 begin
 {$ifdef cpu386}
  result:=((Value and $ff) shl 8) or ((Value and $ff00) shr 8);
 {$else}
  result:=Value;
 {$endif}
 end;
 {$endif}

 function Swap32Little(const Value:longword):longword; {$ifdef cpu386}assembler; register; {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
 asm
  mov eax,eax
 end;
 {$else}
 begin
 {$ifdef cpu386}
  result:=Value;
 {$else}
  result:=((Value and $ff) shl 24) or (((Value and $ff00) shr 8) shl 16) or (((Value and $ff0000) shr 16) shl 8) or ((Value and $ff000000) shr 24);
 {$endif}
 end;
 {$endif}

 function Swap16Little(const Value:word):word; {$ifdef cpu386}assembler; register; {$ifdef FPC}inline; NOSTACKFRAME;{$endif}
 asm
  mov eax,eax
 end;
 {$else}
 begin
 {$ifdef cpu386}
  result:=Value;
 {$else}
  result:=((Value and $ff) shl 8) or ((Value and $ff00) shr 8);
 {$endif}
 end;
 {$endif}

 procedure EventInsertBefore(var MIDIFile:TMIDITrack;NewEvent,OldEvent:PImportMIDIEvent);
 begin
  NewEvent^.Next:=OldEvent;
  NewEvent^.Previous:=OldEvent^.Previous;
  if assigned(OldEvent^.Previous) then begin
   OldEvent^.Previous^.Next:=NewEvent;
  end;
  OldEvent^.Previous:=NewEvent;
  if OldEvent=MIDIFile.EventFirst then begin
   MIDIFile.EventFirst:=NewEvent;
  end;
 end;

 procedure EventInsertAfter(var MIDIFile:TMIDITrack;OldEvent,NewEvent:PImportMIDIEvent);
 begin
  NewEvent^.Next:=OldEvent^.Next;
  NewEvent^.Previous:=OldEvent;
  if assigned(OldEvent^.Next) then begin
   OldEvent^.Next^.Previous:=NewEvent;
  end;
  OldEvent^.Next:=NewEvent;
  if OldEvent=MIDIFile.EventLast then begin
   MIDIFile.EventLast:=NewEvent;
  end;
 end;

 procedure EventInsert(var MIDIFile:TMIDITrack;NewEvent:PImportMIDIEvent);
 var OldEvent:PImportMIDIEvent;
 begin
  if assigned(MIDIFile.EventFirst) and assigned(MIDIFile.EventLast) then begin
   if MIDIFile.EventLast^.Position<=NewEvent^.Position then begin
    EventInsertAfter(MIDIFile,MIDIFile.EventLast,NewEvent);
   end else begin
    OldEvent:=MIDIFile.EventFirst;
    while assigned(OldEvent) and (OldEvent^.Position<=NewEvent^.Position) do begin
     OldEvent:=OldEvent^.next;
    end;
    if assigned(OldEvent) then begin
     EventInsertBefore(MIDIFile,NewEvent,OldEvent);
    end else begin
     EventInsertAfter(MIDIFile,MIDIFile.EventLast,NewEvent);
    end;
   end;
  end else begin
   MIDIFile.EventFirst:=NewEvent;
   MIDIFile.EventLast:=NewEvent;
  end;
 end;

 procedure AddEventToLinkList(var MIDIFile:TMIDITrack;const NewEvent:TImportMIDIEvent);
 var EventToAdd:PImportMIDIEvent;
 begin
  GetMemAligned(EventToAdd,sizeof(TImportMIDIEvent));
  EventToAdd^:=NewEvent;
  EventToAdd^.Previous:=nil;
  EventToAdd^.Next:=nil;
  EventInsert(MIDIFile,EventToAdd);
 end;

 function ReadMIDIDataStream(Data:pbyte;DataSize:longword):boolean;
 const cMThd:array[1..4] of ansichar='MThd';
       cMTrk:array[1..4] of ansichar='MTrk';
 type TFileHeader=packed record
       Signature:array[1..4] of ansichar;
       HeaderSize:longword;
       FileFormat,CountOfTracks,TicksPerQuarterNote:word;
      end;
      TTrackHeader=packed record
       Signature:array[1..4] of ansichar;
       TrackSize:longword;
      end;
 var SourcePointer:pbyte;
     FileHeader:TFileHeader;
     TrackHeader:TTrackHeader;
     TrackCounter:longint;
     DataPosition:longword;
     TrackPosition,Position,MetaLength:longword;
     TrackData,TrackByte:pbyte;
     Command,LastCommand,Meta:byte;
     Event:TImportMIDIEvent;
     Track:PMIDITrack;
  function Read(var Buffer;LengthCounter:longword):longword;
  var DestPointer:pbyte;
  begin
   result:=0;
   DestPointer:=@Buffer;
   while (DataPosition<DataSize) and (result<LengthCounter) do begin
    DestPointer^:=SourcePointer^;
    inc(SourcePointer);
    inc(DestPointer);
    inc(DataPosition);
    inc(result);
   end;
  end;
  function GetVariableLengthEncodingValue:longword;
  var B:byte;
  begin
   result:=0;
   B:=$ff;
   while ((B and $80)<>0) and (TrackPosition<TrackHeader.TrackSize) do begin
    B:=TrackByte^;
    inc(TrackByte);
    inc(TrackPosition);
    result:=(result shl 7) or (B and $7f);
   end;
  end;
 begin
  result:=false;
  SourcePointer:=Data;
  DataPosition:=0;
  Read(FileHeader,sizeof(TFileHeader));
  FileHeader.HeaderSize:=Swap32Big(FileHeader.HeaderSize);
  FileHeader.FileFormat:=Swap16Big(FileHeader.FileFormat);
  FileHeader.CountOfTracks:=Swap16Big(FileHeader.CountOfTracks);
  FileHeader.TicksPerQuarterNote:=Swap16Big(FileHeader.TicksPerQuarterNote);
  if (FileHeader.TicksPerQuarterNote and $8000)<>0 then begin
   FileHeader.TicksPerQuarterNote:=($100-(FileHeader.TicksPerQuarterNote div $100))*(FileHeader.TicksPerQuarterNote and $ff);
  end;
  MIDIFile.TicksPerQuarterNote:=FileHeader.TicksPerQuarterNote;
  if longword(FileHeader.Signature)=longword(cMThd) then begin
   for TrackCounter:=0 to FileHeader.CountOfTracks-1 do begin
    GetMemAligned(Track,sizeof(TMIDITrack));
    FillChar(Track^,sizeof(TMIDITrack),#0);
    if assigned(MIDIFile.TrackLast) then begin
     MIDIFile.TrackLast^.Next:=Track;
     Track^.Previous:=MIDIFile.TrackLast;
    end else begin
     MIDIFile.TrackFirst:=Track;
    end;
    MIDIFile.TrackLast:=Track;
    Read(TrackHeader,sizeof(TTrackHeader));
    TrackHeader.TrackSize:=Swap32(TrackHeader.TrackSize);
    if longword(TrackHeader.Signature)=longword(cMTrk) then begin
     GetMemAligned(TrackData,TrackHeader.TrackSize);
     Read(TrackData^,TrackHeader.TrackSize);
     TrackByte:=TrackData;
     TrackPosition:=0;
     LastCommand:=0;
     Position:=0;
     while TrackPosition<TrackHeader.TrackSize do begin
      Position:=Position+GetVariableLengthEncodingValue;
      Event.Position:=Position;
      Command:=TrackByte^;
      if (Command and $80)=0 then begin
       Command:=LastCommand;
      end else begin
       inc(TrackByte);
       inc(TrackPosition);
      end;
      LastCommand:=Command;
      Event.SysExLength:=0;
      Event.SysEx:=nil;
      Event.Command:=Command;
      Event.Data[1]:=0;
      Event.Data[2]:=0;
      Event.Data[3]:=0;
      Event.Data[4]:=0;
      if (Command and $f0)=$f0 then begin
       case Command of
        $f0,$f7:begin
         MetaLength:=GetVariableLengthEncodingValue;
         Event.SysExLength:=MetaLength;
         GetMemAligned(Event.SysEx,Event.SysExLength);
         Move(TrackByte^,Event.SysEx^,Event.SysExLength);
         Event.Data[1]:=0;
         inc(TrackByte,MetaLength);
         inc(TrackPosition,MetaLength);
        end;
        $f1:begin
         Event.Data[1]:=TrackByte^;
         inc(TrackByte);
         inc(TrackPosition);
        end;
        $f2:begin
         Event.Data[1]:=TrackByte^;
         inc(TrackByte);
         inc(TrackPosition);
         Event.Data[2]:=TrackByte^;
         inc(TrackByte);
         inc(TrackPosition);
        end;
        $f3:begin
         Event.Data[1]:=TrackByte^;
         inc(TrackByte);
         inc(TrackPosition);
        end;
        $ff:begin
         Meta:=TrackByte^;
         inc(TrackByte);
         inc(TrackPosition);
         MetaLength:=GetVariableLengthEncodingValue;
         Event.SysExLength:=MetaLength;
         GetMemAligned(Event.SysEx,Event.SysExLength);
         Move(TrackByte^,Event.SysEx^,Event.SysExLength);
         Event.Data[1]:=Meta;
         case Meta of
          $2f:TrackPosition:=TrackHeader.TrackSize;
          $51:begin
           Event.Data[2]:=TrackByte^;
           inc(TrackByte);
           inc(TrackPosition);
           Event.Data[3]:=TrackByte^;
           inc(TrackByte);
           inc(TrackPosition);
           Event.Data[4]:=TrackByte^;
           inc(TrackByte);
           inc(TrackPosition);
          end;
          else begin
           inc(TrackByte,MetaLength);
           inc(TrackPosition,MetaLength);
          end;
         end;
        end;
       end;
      end else if EventSizes[Command shr 4]>0 then begin
       Event.Data[1]:=TrackByte^;
       inc(TrackByte);
       inc(TrackPosition);
       if EventSizes[Command shr 4]>1 then begin
        Event.Data[2]:=TrackByte^;
        inc(TrackByte);
        inc(TrackPosition);
       end;
      end;
      AddEventToLinkList(Track^,Event);
     end;
     FreeMemAligned(TrackData);
     result:=true;
    end;
   end;
  end;
 end;

 procedure FreeTracks;
 var Track,NextTrack:PMIDITrack;
     Event,LastMIDIEvent:PImportMIDIEvent;
 begin
  Track:=MIDIFile.TrackFirst;
  while assigned(Track) do begin
   NextTrack:=Track^.Next;
   Event:=Track^.EventFirst;
   while assigned(Event) do begin
    LastMIDIEvent:=Event;
    Event:=LastMIDIEvent^.Next;
    if assigned(LastMIDIEvent^.SysEx) then begin
     FreeMemAligned(LastMIDIEvent^.SysEx);
    end;
    FreeMemAligned(LastMIDIEvent);
   end;
   FreeMemAligned(Track);
   Track:=NextTrack;
  end;
  MIDIFile.TrackFirst:=nil;
  MIDIFile.TrackLast:=nil;
 end;

 procedure EventReset;
 var Track:PMIDITrack;
 begin
  MIDIFile.Position:=0;
  Track:=MIDIFile.TrackFirst;
  while assigned(Track) do begin
   Track^.CurrentEvent:=Track^.EventFirst;
   Track:=Track^.Next;
  end;
 end;

 function EventNext:PImportMIDIEvent;
 var Track:PMIDITrack;
     CurrentEvent:PImportMIDIEvent;
     BestPosition:int64;
 begin
  result:=nil;
  while not assigned(result) do begin
   Track:=MIDIFile.TrackFirst;
   while assigned(Track) do begin
    CurrentEvent:=Track^.CurrentEvent;
    if assigned(CurrentEvent) then begin
     if CurrentEvent^.Position<=MIDIFile.Position then begin
      result:=CurrentEvent;
      Track^.CurrentEvent:=CurrentEvent^.Next;
      break;
     end;
    end;
    Track:=Track^.Next;
   end;
   if assigned(result) then begin
    break;
   end;
   BestPosition:=-1;
   Track:=MIDIFile.TrackFirst;
   while assigned(Track) do begin
    CurrentEvent:=Track^.CurrentEvent;
    if assigned(CurrentEvent) then begin
     if (BestPosition<0) or (CurrentEvent^.Position<BestPosition) then begin
      BestPosition:=CurrentEvent^.Position;
     end;
    end;
    Track:=Track^.Next;
   end;
   if BestPosition<0 then begin
    break;
   end;
   MIDIFile.Position:=BestPosition;
  end;
 end;

 procedure ProcessEvents;
 var Event:PImportMIDIEvent;
     ID:int64;
     MIDIEventItem:TSynthEvent;
 begin
  EventReset;
  Event:=EventNext;
  ID:=0;
  while assigned(Event) do begin
   if (Event^.Command<=$f0) or ((Event^.Command=$ff) and (Event^.Data[1]=$51)) then begin
    FillChar(MIDIEventItem,sizeof(TSynthEvent),#0);
    MIDIEventItem.Time:=Event^.Position;
    MIDIEventItem.ID:=ID;
    MIDIEventItem.Command:=Event^.Command;
    MIDIEventItem.Data:=Event^.Data;
    if (Event^.Command=$ff) and (Event^.Data[1]=$51) then begin
     Event^.Command:=$f7;
     MIDIEventItem.SysEx:=nil;
     MIDIEventItem.SysExLen:=0;
    end else if assigned(Event^.SysEx) and (Event^.SysExLength>0) then begin
     MIDIEventItem.SysEx:=Event^.SysEx;
     MIDIEventItem.SysExLen:=Event^.SysExLength;
    end else begin
     MIDIEventItem.SysEx:=nil;
     MIDIEventItem.SysExLen:=0;
    end;
    SynthAddEvent(Track,@Event);
    inc(ID);
   end;
   Event:=EventNext;
  end;
 end;

const cRIFF:array[1..4] of ansichar='RIFF';
      cRMID:array[1..4] of ansichar='RMID';
      cdata:array[1..4] of ansichar='data';
var RIFFHeader:TRIFFHeaderChunk;
    RIFFChunk:TRIFFChunk;
    SourcePointer:pbyte;
    DataPosition:longword;
 function Read(var Buffer;LengthCounter:longword):longword;
 var DestPointer:pbyte;
 begin
  result:=0;
  DestPointer:=@Buffer;
  while (DataPosition<DataSize) and (result<LengthCounter) do begin
   DestPointer^:=SourcePointer^;
   inc(SourcePointer);
   inc(DestPointer);
   inc(DataPosition);
   inc(result);
  end;
 end;
begin
 DataPosition:=0;
 SourcePointer:=pointer(Data);
 if Read(RIFFHeader,sizeof(TRIFFHeaderChunk))=sizeof(TRIFFHeaderChunk) then begin
  RIFFHeader.Chunk.Size:=Swap32Little(RIFFHeader.Chunk.Size);
  if (longword(RIFFHeader.Chunk.Signature)=longword(cRIFF)) and
     (longword(RIFFHeader.ID)=longword(cRMID)) then begin
   while (DataPosition<DataSize) and (DataPosition<RIFFHeader.Chunk.Size) do begin
    if Read(RIFFChunk,sizeof(TRIFFChunk))<>sizeof(TRIFFChunk) then begin
     break;
    end;
    RIFFChunk.Size:=Swap32Little(RIFFChunk.Size);
    if longword(RIFFChunk.Signature)=longword(cdata) then begin
     result:=SynthReadSMF(Track,SourcePointer,RIFFChunk.Size);
     exit;
    end else begin
     inc(SourcePointer,RIFFChunk.Size);
     inc(DataPosition,RIFFChunk.Size);
    end;
   end;
  end;
 end;
 FillChar(MIDIFile,sizeof(TMIDIFile),#0);
 result:=ReadMIDIDataStream(Data,DataSize);
 if result then begin
  ProcessEvents;
  FreeTracks;
  Track^.TicksPerQuarterNote:=MIDIFile.TicksPerQuarterNote;
  Track^.Tempo:=500000;
  Track^.DifferenceTicksIncrement:=0;
  SynthChangeTempo(Track);
 end;
end;
{$else}
begin
end;
{$endif}

function SynthReadBMFInformations(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall; [public,alias:'_SynthReadBMFInformations@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var PartData,BankData:pbyte;
    BankOffset:longword;
begin
 result:=false;
 if (DataSize=0) or not assigned(Data) then exit;

 PartData:=Data;

 if plongword(PartData)^<>BR808SynthesizerVersion then begin
  exit;
 end;
 inc(PartData,sizeof(longword));

 BankOffset:=plongword(PartData)^;
 if BankOffset<>0 then begin
  BankData:=@PByteArray(Data)^[BankOffset];
  if not SynthReadBank(Track,BankData,DataSize-BankOffset+1) then exit;
 end;

 result:=true;
end;

function SynthReadBMFSampleRate(Data:pbyte;DataSize:longword):longword; {$ifdef csdk}stdcall; [public,alias:'_SynthReadBMFSampleRate@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var PartData:pbyte;
begin
 result:=44100;
 if (DataSize=0) or not assigned(Data) then exit;
 PartData:=Data;
 if plongword(PartData)^<>BR808SynthesizerVersion then begin
  exit;
 end;
 inc(PartData,sizeof(longword));
 inc(PartData,sizeof(longword));
 inc(PartData,sizeof(longword));
 result:=plongword(PartData)^;
end;

function SynthReadBMF(Track:PSynthTrack;Data:pbyte;DataSize:longword):longbool; {$ifdef csdk}stdcall; [public,alias:'_SynthReadBMF@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var StreamCounter:longint;
    PartData,BankData,DataData:pbyte;
    BankOffset,SubTrackOffset,SubTrackLength,EventCount,EventCounter,DataStart,
    DataCount,DataCounter,TimeDataCount,IDDataCount,SysExOffset,UsedStreams,SysExOffsetEx:longword;
    Event:TSynthEvent;
    LastTime,Time,LastID,ID:int64;
    SubTrack:PSynthTrack;
begin
 result:=false;
 if (DataSize=0) or not assigned(Data) then exit;

 SynthClearTrack(Track);

 PartData:=Data;

 if plongword(PartData)^<>BR808SynthesizerVersion then begin
  exit;
 end;
 inc(PartData,sizeof(longword));

 BankOffset:=plongword(PartData)^;
 if BankOffset<>0 then begin
  BankData:=@PByteArray(Data)^[BankOffset];
  if not SynthReadBank(Track,BankData,DataSize-BankOffset+1) then begin
   exit;
  end;
 end;
 inc(PartData,sizeof(longword)); // 4

 SubTrackOffset:=plongword(PartData)^;
 inc(PartData,sizeof(longword)); // 8

 inc(PartData,sizeof(longword)); // 12

 Track^.TicksPerQuarterNote:=plongword(PartData)^;
 inc(PartData,sizeof(longword)); // 16

 Track^.Tempo:=plongword(PartData)^;
 inc(PartData,sizeof(longword)); // 20

 SysExOffset:=plongword(PartData)^;
 inc(PartData,sizeof(longword)); // 24

 UsedStreams:=plongword(PartData)^;
 inc(PartData,sizeof(longword)); // 32

 for StreamCounter:=1 to UsedStreams do begin
  EventCount:=plongword(PartData)^;
  inc(PartData,sizeof(longword));
  if EventCount=0 then continue;

  // Reset delta values
  LastTime:=0;
  LastID:=0;
  FillChar(Event.Data,sizeof(TSynthEventData),#0);

  // Get command byte
  Event.Command:=PartData^;
  inc(PartData);

  // If we are in a controller stream, get the first data byte, and set
  // the correct data start value
  if (Event.Command and $f0)=MIDI_CONTROLCHANGE then begin
   Event.Data[1]:=PartData^;
   inc(PartData);
   DataStart:=2;
  end else begin
   DataStart:=1;
  end;

  // Get time data count byte
  TimeDataCount:=PartData^;
  inc(PartData);

  // Get ID data count byte
  IDDataCount:=PartData^;
  inc(PartData);

  // Get data bytes count
  if (Event.Command and $f0)=MIDI_SYSTEMMESSAGE then begin
   case Event.Command of
    $f0,$f7:begin
     DataCount:=4;
    end;
    $f1,$f3:begin
     DataCount:=1;
    end;
    $f2:begin
     DataCount:=2;
    end;
    else begin
     DataCount:=0;
    end;
   end;
  end else begin
   DataCount:=EventSizes[Event.Command shr 4];
  end;

  for EventCounter:=1 to EventCount do begin
   // Decode time
   Time:=0;
   for DataCounter:=1 to TimeDataCount do begin
    Time:=Time or (PByteArray(PartData)^[(longword(DataCounter-1)*EventCount)+(EventCounter-1)] shl ((DataCounter-1) shl 3));
   end;
   Time:=Time+LastTime;
   LastTime:=Time;
   Event.Time:=Time;

   ID:=0;
   for DataCounter:=1 to IDDataCount do begin
    ID:=ID or (PByteArray(PartData)[(EventCount*TimeDataCount)+(longword(DataCounter-1)*EventCount)+(EventCounter-1)] shl ((DataCounter-1) shl 3));
   end;
   ID:=ID+LastID;
   LastID:=ID;
   Event.ID:=ID;
                                 
   // Decode data bytes
   DataData:=@PByteArray(PartData)^[(EventCount*TimeDataCount)+(EventCount*IDDataCount)];
   for DataCounter:=DataStart to DataCount do begin
    inc(Event.Data[DataCounter],PByteArray(DataData)^[(longword(DataCounter-DataStart)*EventCount)+(EventCounter-1)]);
   end;

   if Event.Command=$f0 then begin
    SysExOffsetEx:=SysExOffset+(Event.Data[1] or (Event.Data[2] shl 8) or (Event.Data[3] shl 8) or (Event.Data[4] shl 8));
    Event.SysExLen:=longword(pointer(@PByteArray(PartData)^[SysExOffsetEx])^);
    GetMemAligned(Event.SysEx,Event.SysExLen);
    Move(PByteArray(PartData)^[SysExOffsetEx+4],Event.SysEx^,Event.SysExLen);
   end else begin
    Event.SysEx:=nil;
    Event.SysExLen:=0;
   end;

   SynthAddEvent(Track,@Event);
  end;

  // Go to next data stream
  inc(PartData,EventCount*(TimeDataCount+IDDataCount+(DataCount-(DataStart-1))));

 end;

 while SubTrackOffset<>0 do begin
  PartData:=Data;
  inc(PartData,SubTrackOffset);
  SubTrackOffset:=plongword(PartData)^;
  inc(PartData,sizeof(longword));
  SubTrackLength:=plongword(PartData)^;
  inc(PartData,sizeof(longword));
  SubTrack:=SynthCreate(Track^.BaseSampleRate,Track^.BaseBufferSamples,false,false);
  SynthLink(SubTrack,Track);
  SynthReadBMF(SubTrack,PartData,SubTrackLength);
  SubTrack^.LinkContentDestroy:=true;
 end;

 Track^.DifferenceTicksIncrement:=0;
 SynthChangeTempo(Track);
 SynthCheckDelayBuffers(Track);
 result:=true;
end;

procedure SynthChangeTempo(Track:PSynthTrack); stdcall; {$ifdef csdk}[public,alias:'_SynthChangeTempo@4'];{$endif}
{$ifdef VSTi}
begin
 Track^.IntervalSamples:=1;
 //Track^.DifferenceTicksIncrement:=1;
end;
{$else}
var TicksPerQuarterNote,Dividier:int64;
begin
 TicksPerQuarterNote:=Track^.TicksPerQuarterNote;
 if TicksPerQuarterNote=0 then TicksPerQuarterNote:=1;
 if Track^.Tempo=0 then begin
  Dividier:=2*TicksPerQuarterNote;
 end else begin
  Dividier:=(1000000*TicksPerQuarterNote) div Track^.Tempo;
 end;
 if Dividier=0 then Dividier:=1;
 Track^.IntervalSamples:=(int64(Track^.InternalSampleRate) shl 32) div Dividier;
end;
{$endif}

procedure SynthChangeTempoEx(Track:PSynthTrack;NewTicksPerQuarterNote,NewTempo:longint); {$ifdef csdk}[public,alias:'_SynthChangeTempoEx@12'];{$endif}
begin
 Track^.TicksPerQuarterNote:=NewTicksPerQuarterNote;
 Track^.Tempo:=NewTempo;
 SynthChangeTempo(Track);
end;

function SynthFindFreeVoice(Track:PSynthTrack;Channel:PSynthChannel;Note:byte;Instrument:PSynthInstrument):PSynthVoice;
var VoiceCounter,BestVelocity,UsedCount:longint;
    BestLifeTime:longword;
begin
 result:=nil;

 if not Channel^.PolyMode then begin
  // find a voice which is playing the same channel as we want to play, and
  // reallocate it
  for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
   if Track^.Voices[VoiceCounter].Channel=Channel then begin
    result:=@Track^.Voices[VoiceCounter];
    exit;
   end;
  end;
 end;

 if assigned(Instrument) then begin
  UsedCount:=0;
  for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
   if Track^.Voices[VoiceCounter].Active and
      (Track^.Voices[VoiceCounter].Channel=Channel) and
      (Track^.Voices[VoiceCounter].Instrument=Instrument) then begin
    inc(UsedCount);
   end;
  end;

  if Channel^.LegatoPedal or (UsedCount>=Instrument^.MaxPolyphony) then begin
   // else: find all voices which are keyed off and reallocate the oldest with
   //       the lowest volume
   BestVelocity:=128;
   BestLifeTime:=0;
   for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
    if Track^.Voices[VoiceCounter].Active and
       (Track^.Voices[VoiceCounter].Channel=Channel) and
       (Track^.Voices[VoiceCounter].Instrument=Instrument) and
       (Track^.Voices[VoiceCounter].Velocity<BestVelocity) and
       Track^.Voices[VoiceCounter].KeyOff and
       (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
     result:=@Track^.Voices[VoiceCounter];
     BestLifeTime:=result^.LifeTime;
     BestVelocity:=result^.Velocity;
    end;
   end;
   if assigned(result) then exit;

   // else: find a voice which is keyed off and playing the same note
   //       as we want to play, and reallocate the oldest
   BestLifeTime:=0;
   for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
    if Track^.Voices[VoiceCounter].Active and
       (Track^.Voices[VoiceCounter].Channel=Channel) and
       (Track^.Voices[VoiceCounter].Instrument=Instrument) and
       (Track^.Voices[VoiceCounter].Note=Note) and
       (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
     result:=@Track^.Voices[VoiceCounter];
     BestLifeTime:=result^.LifeTime;
    end;
   end;
   if assigned(result) then exit;

   // else: reallocate the oldest with the lowest volume
   BestVelocity:=128;
   BestLifeTime:=0;
   for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
    if Track^.Voices[VoiceCounter].Active and
       (Track^.Voices[VoiceCounter].Channel=Channel) and
       (Track^.Voices[VoiceCounter].Instrument=Instrument) and
       (Track^.Voices[VoiceCounter].Velocity<BestVelocity) and
       (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
     result:=@Track^.Voices[VoiceCounter];
     BestLifeTime:=result^.LifeTime;
     BestVelocity:=result^.Velocity;
    end;
   end;
   if assigned(result) then exit;

    // else: reallocate the oldest voice
   BestLifeTime:=0;
   for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
    if Track^.Voices[VoiceCounter].Active and
       (Track^.Voices[VoiceCounter].Channel=Channel) and
       (Track^.Voices[VoiceCounter].Instrument=Instrument) and
       (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
     result:=@Track^.Voices[VoiceCounter];
     BestLifeTime:=result^.LifeTime;
    end;
   end;
   if assigned(result) then exit;
  end;
 end;

 // else: Find a inactive voice
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if not Track^.Voices[VoiceCounter].Active then begin
   result:=@Track^.Voices[VoiceCounter];
   exit;
  end;
 end;

 // else: find a voice which is keyed off and playing the same note
 //       as we want to play, and reallocate the oldest
 BestLifeTime:=0;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if (Track^.Voices[VoiceCounter].Channel=Channel) and
     (Track^.Voices[VoiceCounter].Note=Note) and
      Track^.Voices[VoiceCounter].KeyOff and
     (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
   result:=@Track^.Voices[VoiceCounter];
   BestLifeTime:=result^.LifeTime;
  end;
 end;
 if assigned(result) then exit;

 // else: find all voices which are keyed off and reallocate the oldest with
 //       the lowest volume
 BestVelocity:=128;
 BestLifeTime:=0;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if (Track^.Voices[VoiceCounter].Channel=Channel) and
     (Track^.Voices[VoiceCounter].Velocity<BestVelocity) and
     Track^.Voices[VoiceCounter].KeyOff and
     (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
   result:=@Track^.Voices[VoiceCounter];
   BestVelocity:=result^.Velocity;
   BestLifeTime:=result^.LifeTime;
  end;
 end;
 if assigned(result) then exit;

 // else: find the oldest voice which is playing the same note as we want to play,
 //       and reallocate it
 BestLifeTime:=0;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if (Track^.Voices[VoiceCounter].Channel=Channel) and
     (Track^.Voices[VoiceCounter].Note=Note) and
     (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
   result:=@Track^.Voices[VoiceCounter];
   BestLifeTime:=result^.LifeTime;
  end;
 end;
 if assigned(result) then exit;

 // else: reallocate the oldest voice with the lowest volume
 BestVelocity:=128;
 BestLifeTime:=0;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if (Track^.Voices[VoiceCounter].Velocity<BestVelocity) and
     (Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime) then begin
   result:=@Track^.Voices[VoiceCounter];
   BestVelocity:=result^.Velocity;
   BestLifeTime:=result^.LifeTime;
  end;
 end;
 if assigned(result) then exit;

 // else: reallocate the oldest voice
 BestLifeTime:=0;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  if Track^.Voices[VoiceCounter].LifeTime>=BestLifeTime then begin
   result:=@Track^.Voices[VoiceCounter];
   BestLifeTime:=result^.LifeTime;
  end;
 end;
end;

{
function SynthFindVoice(Track:PSynthTrack;Channel:PSynthChannel;Note,Velocity:byte):PSynthVoice;
var VoiceCounter:longint;
    BestLifeTime:longword;
begin
 result:=nil;
 if Velocity<$80 then begin
  BestLifeTime:=$ffffffff;
  for VoiceCounter:=0 to Track^.Globals.Voices.Count-1 do begin
   if (Track^.Voices[VoiceCounter].Channel=Channel) and
      (Track^.Voices[VoiceCounter].Note=Note) and
      (Track^.Voices[VoiceCounter].Velocity=Velocity) and
      (Track^.Voices[VoiceCounter].LifeTime<=BestLifeTime) then begin
    BestLifeTime:=Track^.Voices[VoiceCounter].LifeTime;
    result:=@Track^.Voices[VoiceCounter];
   end;
  end;
 end;
 if not assigned(result) then begin
  BestLifeTime:=$ffffffff;
  for VoiceCounter:=0 to Track^.Globals.Voices.Count-1 do begin
   if (Track^.Voices[VoiceCounter].Channel=Channel) and
      (Track^.Voices[VoiceCounter].Note=Note) and
      (Track^.Voices[VoiceCounter].LifeTime<=BestLifeTime) then begin
    BestLifeTime:=Track^.Voices[VoiceCounter].LifeTime;
    result:=@Track^.Voices[VoiceCounter];
   end;
  end;
 end;
end;
}

function SynthGetTuningPitch(Track:PSynthTrack;Channel:PSynthChannel;Key:longint):double;
begin
 if assigned(Channel) and (Key in [0..127]) then begin
  if assigned(Channel^.Instrument) and Channel^.Instrument^.UseTuningTable then begin
   result:=Channel^.Instrument^.TuningTable[Key];
  end else begin
   result:=Track^.TuningTables[Channel^.TuningBank and $7f,Channel^.TuningProgram and $7f,Key]+Channel.TuningTable[Key];
  end;
 end else begin
  result:=6000;
 end;
end;

procedure SynthRecalculateVoice(Track:PSynthTrack;Voice:PSynthVoice);
var Counter:longint;
begin
 Voice^.FloatNote:=SynthGetTuningPitch(Track,Voice^.Channel,Voice^.Note)+(((Voice^.Channel^.PitchBend-$2000)*(Voice^.Channel^.PitchBendDepthSemitones+(Voice^.Channel^.PitchBendDepthCents*fCI128)))/$2000);
 for Counter:=0 to MaxInstrumentOscillator-1 do begin
  Voice^.OscillatorData[Counter].NewFrequency:=true;
 end;
end;

procedure SynthRecalculateVoiceNewNote(Track:PSynthTrack;Voice:PSynthVoice);
var Counter:longint;
begin
 SynthRecalculateVoice(Track,Voice);
 for Counter:=0 to MaxInstrumentOscillator-1 do begin
  Voice^.OscillatorData[Counter].NewNote:=true;
 end;
end;

procedure SynthResetVoice(Track:PSynthTrack;Channel:PSynthChannel;Voice:PSynthVoice;Carry:boolean);
begin
 if assigned(Voice^.Channel) and not (Carry and (Channel^.Instrument^.Carry or Channel^.LegatoPedal)) then begin
  Voice^.Channel^.Last.Left:=Voice^.Channel^.Last.Left+Voice^.Last.Left;
  Voice^.Channel^.Last.Right:=Voice^.Channel^.Last.Right+Voice^.Last.Right;
  Voice^.RampingNote.Active:=false;
  Voice^.RampingVelocity.Active:=false;
  Voice^.RampingKeyOffVelocity.Active:=Voice^.RampingKeyOffVelocity.Active and (Voice^.RampingKeyOffVelocity.Current=1);
  Voice^.RampingAfterTouch.Active:=Voice^.RampingAfterTouch.Active and (Voice^.RampingAfterTouch.Current=0);
 end;
 Voice^.Last.Left:=0;
 Voice^.Last.Right:=0;
 Voice^.TempLast.Left:=0;
 Voice^.TempLast.Right:=0;
 Voice^.NeedClickRemoval:=false;
 Voice^.Note:=-1;
 Voice^.Holding:=false;
 Voice^.KeyOff:=false;
 Voice^.KeyOffVelocity:=127;
end;

procedure SynthVoiceKeyOn(Track:PSynthTrack;Channel:PSynthChannel;Voice:PSynthVoice;Carry,CarryEx:boolean);
var Counter:longint;
    InstrumentCarry,LegatoPedal:boolean;
begin
 Voice^.KeyOff:=false;
 Voice^.AfterTouch:=0;
 LegatoPedal:=assigned(Voice^.Channel) and Voice^.Channel^.LegatoPedal;
 InstrumentCarry:=(Voice^.Instrument^.Carry or LegatoPedal) and Carry;
 Voice^.RampingVelocity.Active:=Voice^.RampingVelocity.Active and InstrumentCarry;
 for Counter:=0 to MaxInstrumentOscillator-1 do begin
  SynthProcessOscillatorInit(Track,@Voice^.Instrument^.Oscillator[Counter],@Voice^.OscillatorData[Counter]);
  SynthProcessOscillatorKeyOn(Track,@Voice^.Instrument^.Oscillator[Counter],@Voice^.OscillatorData[Counter],Carry,LegatoPedal);
 end;
{$ifdef BR808ADSR}
 for Counter:=0 to MaxInstrumentADSR-1 do begin
  SynthProcessADSRInit(Track,@Voice^.Instrument^.ADSR[Counter],@Voice^.ADSRData[Counter],nil,nil,nil,nil,nil{,NIL});
  SynthProcessADSRKeyOn(Track,@Voice^.Instrument^.ADSR[Counter],@Voice^.ADSRData[Counter],Carry,LegatoPedal);
 end;
{$endif}
{$ifdef BR808ENVELOPES}
 for Counter:=0 to MaxInstrumentEnvelopes-1 do begin
  SynthProcessEnvelopeInit(Track,@Voice^.Instrument^.Envelope[Counter],@Voice^.EnvelopeData[Counter]);
  SynthProcessEnvelopeKeyOn(Track,@Voice^.Instrument^.Envelope[Counter],@Voice^.EnvelopeData[Counter],Carry,LegatoPedal);
 end;
{$endif}
{$ifdef BR808LFO}
 for Counter:=0 to MaxInstrumentLFO-1 do begin
  SynthProcessLFOInit(Track,@Voice^.Instrument^.LFO[Counter],@Voice^.LFOData[Counter]);
  SynthProcessLFOKeyOn(Track,Channel,Voice,@Voice^.Instrument^.LFO[Counter],@Voice^.LFOData[Counter],CarryEx,LegatoPedal);
 end;
{$endif}
{$ifdef BR808VOICEFILTER}
 for Counter:=0 to MaxInstrumentFilter-1 do begin
  SynthProcessFilterInit(Track,@Voice^.Instrument^.Filter[Counter],@Voice^.FilterData[Counter]);
  SynthProcessFilterKeyOn(Track,@Voice^.Instrument^.Filter[Counter],@Voice^.FilterData[Counter],Carry,LegatoPedal);
 end;
{$endif}
{$ifdef BR808VOICEDISTORTION}
 SynthProcessVoiceDistortionInit(Track,@Voice^.Instrument^.VoiceDistortion,@Voice^.VoiceDistortionData);
 SynthProcessVoiceDistortionKeyOn(Track,@Voice^.Instrument^.VoiceDistortion,@Voice^.VoiceDistortionData,Carry,LegatoPedal);
{$endif}
 Voice^.LifeTime:=0;
 Voice^.WaitForClickRemoval:=false;
end;

procedure SynthVoiceKeyOff(Track:PSynthTrack;Voice:PSynthVoice);
var Counter:longint;
begin
 Voice^.KeyOff:=true;
 if Voice^.Channel^.HoldPedal then begin
  Voice^.Holding:=true;
 end else if not Voice^.Sostenutoing then begin
  for Counter:=0 to MaxInstrumentOscillator-1 do begin
   SynthProcessOscillatorKeyOff(Track,@Voice^.OscillatorData[Counter]);
  end;
{$ifdef BR808ADSR}
  for Counter:=0 to MaxInstrumentADSR-1 do begin
   SynthProcessADSRKeyOff(Track,@Voice^.ADSRData[Counter]);
  end;
{$endif}
{$ifdef BR808ENVELOPES}
  for Counter:=0 to MaxInstrumentEnvelopes-1 do begin
   SynthProcessEnvelopeKeyOff(Track,@Voice^.EnvelopeData[Counter]);
  end;
{$endif}
{$ifdef BR808LFO}
  for Counter:=0 to MaxInstrumentLFO-1 do begin
   SynthProcessLFOKeyOff(Track,@Voice^.LFOData[Counter]);
  end;
{$endif}
{$ifdef BR808VOICEFILTER}
  for Counter:=0 to MaxInstrumentFilter-1 do begin
   SynthProcessFilterKeyOff(Track,@Voice^.FilterData[Counter]);
  end;
{$endif}
{$ifdef BR808VOICEDISTORTION}
  SynthProcessVoiceDistortionKeyOff(Track,@Voice^.VoiceDistortionData);
{$endif}
 end;
end;

procedure SynthProcessRPN(Track:PSynthTrack;Channel:PSynthChannel);
begin
 case Channel^.RPN.Parameter and $7f of
  $00:begin
   Channel^.PitchBendDepthSemitones:=Channel^.RPN.Data shr 7;
   Channel^.PitchBendDepthCents:=Channel^.RPN.Data and $7f;
  end;
  $01:begin
   Channel^.FineTuning:=Channel^.RPN.Data;
  end;
  $02:begin
   Channel^.CoarseTuning:=Channel^.RPN.Data;
  end;
  $03:begin
   Channel^.TuningProgram:=Channel^.RPN.Data and $7f;
  end;
  $04:begin
   Channel^.TuningBank:=Channel^.RPN.Data and $7f;
  end;
 end;
end;

procedure SynthProcessNRPN(Track:PSynthTrack;Channel:PSynthChannel);
begin
 if Track^.GeneralMIDIMode=0 then begin
 end;
end;

procedure SynthAllNotesOff(Track:PSynthTrack);
var Counter:longint;
begin
 Track^.GlobalData.Reverb.LastLowPassLeft:=0;
 Track^.GlobalData.Reverb.LastLowPassRight:=0;
 Track^.GlobalData.Reverb.LeftDelayedCounter:=0;
 Track^.GlobalData.Reverb.RightDelayedCounter:=0;
 Track^.GlobalData.Reverb.LeftCounter:=0;
 Track^.GlobalData.Reverb.RightCounter:=0;
 Track^.GlobalData.Reverb.Ready:=false;
 FillChar(Track^.GlobalData.DelayBuffer^,Track^.DelayBufferSize*sizeof(TSynthBufferSample),#$0);
 FillChar(Track^.GlobalData.ChorusFlangerBuffer^,Track^.ChorusSamples*CHORUS_MAX*sizeof(TSynthBufferSample),#0);
 FillChar(Track^.GlobalData.CompressorBuffer^,Track^.POTBufferSize*sizeof(TSynthBufferSample),#0);
 FillChar(Track^.GlobalData.Reverb.LeftBuffer^,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue),#0);
 FillChar(Track^.GlobalData.Reverb.RightBuffer^,Track^.InternalSampleRate*2*sizeof(TSynthFloatValue),#0);
 FillChar(Track^.GlobalData.Reverb.Counter,sizeof(Track^.GlobalData.Reverb.Counter),#0);
 for Counter:=0 to MaxReverbAllPassFilters-1 do begin
  FillChar(Track^.GlobalData.Reverb.AllPassBuffer[Counter]^,Track^.InternalSampleRate*2*sizeof(TSynthBufferSample),#0);
 end;
 for Counter:=0 to Track^.Global.Voices.Count-1 do begin
  SynthVoiceKeyOff(Track,@Track^.Voices[Counter]);
  if assigned(Track^.Voices[Counter].Instrument) and (Track^.Voices[Counter].Instrument^.ChannelSpeech.Active) and Track^.Voices[Counter].Active then begin
   if assigned(Track^.Voices[Counter].Channel) then begin
    SynthResetVoice(Track,@Track^.Voices[Counter].Channel,@Track^.Voices[Counter],false);
   end;
   Track^.Voices[Counter].Active:=false;
  end;
 end;
 for Counter:=0 to NumberOfChannels-1 do begin
  Track^.Channels[Counter].SpeechInstance.SegmentList.Position:=-1;
  Track^.Channels[Counter].SpeechInstance.FrameRemain:=0;
  Track^.Channels[Counter].SpeechInstance.TimeRemain:=0;
 end;
end;

procedure SynthChannelAllSoundsOff(Track:PSynthTrack;Channel:PSynthChannel);
var Counter:longint;
begin
 for Counter:=0 to Track^.Global.Voices.Count-1 do begin
  if Track^.Voices[Counter].Channel=Channel then begin
   SynthVoiceKeyOff(Track,@Track^.Voices[Counter]);
   if Track^.Voices[Counter].Active then begin
    if assigned(Track^.Voices[Counter].Channel) then begin
     SynthResetVoice(Track,@Track^.Voices[Counter].Channel,@Track^.Voices[Counter],false);
    end;
    Track^.Voices[Counter].Active:=false;
   end;
  end;
 end;
 Channel^.SpeechInstance.SegmentList.Position:=-1;
 Channel^.SpeechInstance.FrameRemain:=0;
 Channel^.SpeechInstance.TimeRemain:=0;
end;

procedure SynthChannelResetControllers(Track:PSynthTrack;Channel:PSynthChannel;All:boolean);
var Counter:longint;
begin
 Channel^.PitchBendDepthSemitones:=2;
 Channel^.PitchBendDepthCents:=0;
 Channel^.PitchBend:=$2000;
 Channel^.RPN.NParameter:=0;
 Channel^.RPN.Parameter:=0;
 Channel^.RPN.Data:=0;
 Channel^.NRPNSelect:=0;
 Channel^.Modulation:=0;
 Channel^.Expression:=127 shl 7;
 if Track^.GeneralMIDIMode<>0 then begin
  Channel^.Balance:=64 shl 7;
 end;
 Channel^.HoldPedal:=false;
 Channel^.PortamentoPedal:=false;
 Channel^.SostenutoPedal:=false;
 Channel^.SoftPedal:=false;
 Channel^.LegatoPedal:=false;
 Channel^.Hold2Pedal:=false;
 Channel^.SpeechInstance.SegmentList.Position:=-1;
 Channel^.SpeechInstance.FrameRemain:=0;
 Channel^.SpeechInstance.TimeRemain:=0;
 for Counter:=0 to Track^.Global.Voices.Count-1 do begin
  if Track^.Voices[Counter].Channel=Channel then begin
   Track^.Voices[Counter].AfterTouch:=0;
   if Track^.Voices[Counter].Active then begin
    SynthRecalculateVoice(Track,@Track^.Voices[Counter]);
   end;
  end;
 end;
 if All then begin
  FillChar(Channel^.NRPNControllers,sizeof(TSynthNRPNControllers),#0);
  FillChar(Channel^.Controllers,sizeof(TSynthControllers),#0);
  FillChar(Channel^.WorkControllers,sizeof(TSynthControllers),#0);
  if Track^.GeneralMIDIMode<>0 then begin
   Channel^.MainVolume:=100 shl 7;
  end else begin
   Channel^.MainVolume:=127 shl 7;
  end;
  Channel^.Panning:=64 shl 7;
  if Track^.GeneralMIDIMode<>0 then begin
   Channel^.TuningBank:=0;
   Channel^.TuningProgram:=0;
   Channel^.CoarseTuning:=$2000;
   Channel^.FineTuning:=$2000;
  end;
 end;
end;

procedure SynthChannelAllNotesOff(Track:PSynthTrack;Channel:PSynthChannel);
var Counter:longint;
begin
 for Counter:=0 to Track^.Global.Voices.Count-1 do begin
  if Track^.Voices[Counter].Channel=Channel then begin
   SynthVoiceKeyOff(Track,@Track^.Voices[Counter]);
  end;
 end;
end;

procedure SynthNoteOff(Track:PSynthTrack;Channel:PSynthChannel;Note,Velocity:byte);
var VoiceCounter:longint;
    Voice:PSynthVoice;
    First:boolean;
begin
 First:=true;
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  Voice:=@Track^.Voices[VoiceCounter];
  if (Voice^.Channel=Channel) and assigned(Channel^.Instrument) and (Voice^.Note=Note) and Voice^.Active and not Voice^.KeyOff then begin
   Channel^.LastVoice:=Voice;
   Voice^.KeyOffVelocity:=Velocity;
   SynthVoiceKeyOff(Track,Voice);
   if First then begin
    First:=false;
{$ifdef BR808SPEECH}
    if Channel^.Instrument^.ChannelSpeech.Active then begin
     if Channel^.SpeechInstance.WaitForEvent=wfeNOTEOFF then begin
      Channel^.SpeechInstance.WaitForEvent:=wfeNONE;
      with Channel^.SpeechInstance do begin
{      FillChar(LastSegmentItem,SIZEOF(TSynthSpeechSegmentItem),#0);
       FillChar(CurrentSegmentItem,SIZEOF(TSynthSpeechSegmentItem),#0);}
       FillChar(NewSegmentItem,sizeof(TSynthSpeechSegmentItem),#0);
{      LastSegment:=@SpeechSegmentsArray[ssiEND];
       CurrentSegment:=@SpeechSegmentsArray[ssiEND];}
       NewSegment:=@SpeechSegmentsArray[ssiEND];
      end;
     end;
    end;
{$endif}
   end;
  end;
 end;
end;

procedure SynthNoteOn(Track:PSynthTrack;Channel:PSynthChannel;Note,Velocity:byte);
var Counter:longint;
    Voice:PSynthVoice;
    Carry,CarryEx:boolean;
    LFOPhaseLeftBuffer,LFOPhaseRightBuffer:PSynthFloatValue;
begin
 if Velocity=0 then begin
  SynthNoteOff(Track,Channel,Note,$7f);
 end else begin
{$ifdef textdebug}
  if Track^.DebugWait then begin
   Track^.DebugWait:=false;
   Track^.TimeDebug:=0;
  end;
{$endif}
  Voice:=SynthFindFreeVoice(Track,Channel,Note,Channel^.Instrument);
  if assigned(Voice) and assigned(Channel^.Instrument) then begin
   if Channel^.SoftPedal then begin
    Velocity:=Velocity shr 1;
    if Velocity=0 then Velocity:=1;
   end;
   Channel^.LastVoice:=Voice;
   Voice^.Channel:=Channel;
   Voice^.Instrument:=Channel^.Instrument;
   Voice^.Patch:=Channel^.Patch;
   CarryEx:=(Voice^.Instrument=Channel^.LastVoiceInstrument) and (Voice^.Instrument=Voice^.LastInstrument);
   Carry:=CarryEx and Voice^.Active; 
   Channel^.LastVoiceInstrument:=Channel^.Instrument;
   if Voice^.Instrument^.ChannelChorusFlanger.Active then begin
    LFOPhaseLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[0,0];
    LFOPhaseRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[0,1];
    for Counter:=0 to MaxModulationMatrixMemory-1 do begin
     Track^.ModulationMatrixMemoryBuffers[0,Counter]:=@Track^.WorkBuffers^.MemoryBuffers[0,Counter];
     SynthProcessModulationMatrix(Track,0,Track^.ModulationMatrixMemoryBuffers[0,Counter],Voice^.Instrument,Voice^.Channel,Voice,mmoMEMORY,Counter,1,nil);
    end;
    SynthProcessModulationMatrix(Track,0,LFOPhaseLeftBuffer,Voice^.Instrument,Channel,Voice,mmoChannelChorusFlangerLFOPhaseLeft,0,1,Track^.F1D0Buffer);
    SynthProcessModulationMatrix(Track,0,LFOPhaseRightBuffer,Voice^.Instrument,Channel,Voice,mmoChannelChorusFlangerLFOPhaseRight,0,1,Track^.F1D0Buffer);
{$ifdef BR808CHORUSFLANGER}
    SynthProcessChorusFlangerKeyOn(Track,@Voice^.Instrument^.ChannelChorusFlanger,@Channel^.ChannelChorusFlangerData,CarryEx,Channel^.LegatoPedal,LFOPhaseLeftBuffer,LFOPhaseRightBuffer);
{$endif}
   end;
   SynthResetVoice(Track,Channel,Voice,Carry);
   Voice^.Carry:=Carry;
   Voice^.Active:=true;
   Voice^.Note:=Note;
   Voice^.Velocity:=Velocity;
   SynthRecalculateVoiceNewNote(Track,Voice);
   SynthVoiceKeyOn(Track,Channel,Voice,Carry,CarryEx);
{$ifdef BR808SPEECH}
   if Channel^.Instrument^.ChannelSpeech.Active then begin
    if Channel^.SpeechInstance.WaitForEvent=wfeNONE then begin
     if assigned(Channel^.SpeechInstance.SegmentList.List) and (Channel^.SpeechInstance.SegmentList.Position>=Channel^.SpeechInstance.SegmentList.List^.ItemCount) then begin
      Channel^.SpeechInstance.SegmentList.Position:=0;
     end;
    end else if Channel^.SpeechInstance.WaitForEvent=wfeNOTEON then begin
     Channel^.SpeechInstance.WaitForEvent:=wfeNONE;
     if assigned(Channel^.SpeechInstance.SegmentList.List) and (Channel^.SpeechInstance.SegmentList.Position>=Channel^.SpeechInstance.SegmentList.List^.ItemCount) then begin
      Channel^.SpeechInstance.SegmentList.Position:=0;
     end;
    end;
   end;
{$endif}
  end;
 end;
end;

procedure SynthKeyAfterTouch(Track:PSynthTrack;Channel:PSynthChannel;Note,Velocity:byte);
var VoiceCounter:longint;
    Voice:PSynthVoice;
begin
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  Voice:=@Track^.Voices[VoiceCounter];
  if (Voice^.Channel=Channel) and (Voice^.Note=Note) and Voice^.Active then begin
   Channel^.LastVoice:=Voice;
   Voice^.AfterTouch:=Velocity;
  end;
 end;
end;

procedure SynthControlChange(Track:PSynthTrack;Channel:PSynthChannel;Controller,Value:byte);
var VoiceCounter,Counter,OscillatorCounter,FineMask,InvFineMask:longint;
    Voice:PSynthVoice;
    ModulationMatrixItem:PSynthInstrumentModulationMatrixItem;
    DoProcess:boolean;
begin
 DoProcess:=true;
 FineMask:=$7f;
 InvFineMask:=$00;
 Channel^.WorkControllers[Controller]:=Value;
 if assigned(Channel^.Instrument) then begin
  for Counter:=0 to Channel^.Instrument^.ModulationMatrixItems-1 do begin
   ModulationMatrixItem:=@Channel^.Instrument^.ModulationMatrix[Counter];
   if ModulationMatrixItem^.Source=mmiCONTROLLER then begin
    if ModulationMatrixItem^.SourceIndex=Controller then begin
     if ModulationMatrixItem^.Target in [mmoTranspose,mmoOscTranspose,mmoOscGlide] then begin
      for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
       Voice:=@Track^.Voices[VoiceCounter];
       if Voice^.Active and (Voice^.Channel=Channel) then begin
        for OscillatorCounter:=0 to MaxInstrumentOscillator-1 do begin
         Voice^.OscillatorData[OscillatorCounter].NewFrequency:=true;
        end;
       end;
      end;
     end;
     Channel^.Controllers[Controller]:=Value;
     DoProcess:=false;
    end else if (ModulationMatrixItem^.SourceIndex in [$00..$1f]) and ((ModulationMatrixItem^.SourceIndex+$20)=Controller) then begin
     DoProcess:=false;
    end else if (ModulationMatrixItem^.SourceIndex in [$20..$3f]) and (ModulationMatrixItem^.SourceIndex=(Controller+$20)) then begin
     FineMask:=$00;
     InvFineMask:=$7f;
    end;
   end;
  end;                                                                           
  if (Controller in [$00..$3f]) and ((Channel^.Instrument.Controller7BitFlags and (1 shl (Controller and $1f)))=0) then begin
   FineMask:=$00;
   InvFineMask:=$7f;
  end;
 end;
 if DoProcess then begin
  case Controller of
   $00:begin
    Channel^.Bank:=((Value shl 7) or (Channel^.Bank and FineMask)) or (Value and InvFineMask);
   end;
   $20:begin
    Channel^.Bank:=((Value and FineMask) or (Channel^.Bank and $3f80)) or ((Channel^.Bank shr 7) and InvFineMask);
   end;

   $01:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Modulation:=((Value shl 7) or (Channel^.Modulation and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $21:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Modulation:=((Value and FineMask) or (Channel^.Modulation and $3f80)) or ((Channel^.Modulation shr 7) and InvFineMask);
    end;
   end;

   $02:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Breath:=((Value shl 7) or (Channel^.Breath and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $22:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Breath:=((Value and FineMask) or (Channel^.Breath and $3f80)) or ((Channel^.Breath shr 7) and InvFineMask);
    end;
   end;

   $04:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.FootPedal:=((Value shl 7) or (Channel^.FootPedal and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $24:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.FootPedal:=((Value and FineMask) or (Channel^.FootPedal and $3f80)) or ((Channel^.FootPedal shr 7) and InvFineMask);
    end;
   end;

   $05:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.PortamentoTime:=((Value shl 7) or (Channel^.PortamentoTime and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $25:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.PortamentoTime:=((Value and FineMask) or (Channel^.PortamentoTime and $3f80)) or ((Channel^.PortamentoTime shr 7) and InvFineMask);
    end;
   end;

   $06,$36,$60,$61:begin
    case Controller of
     $06:begin
      Channel^.RPN.Data:=(Value shl 7) or (Channel^.RPN.Data and $7f);
      if ((Channel^.WorkControllers[$62]=120) and (Channel^.WorkControllers[$63]<100)) and ((Channel^.NRPNSelect>=0) and (Channel^.NRPNSelect<=$ff)) then begin
       if assigned(Channel^.Instrument) then begin
        for Counter:=0 to Channel^.Instrument^.ModulationMatrixItems-1 do begin
         ModulationMatrixItem:=@Channel^.Instrument^.ModulationMatrix[Counter];
         if ModulationMatrixItem^.Source=mmiNRPN then begin
          if ModulationMatrixItem^.SourceIndex=Controller then begin
           if ModulationMatrixItem^.Target in [mmoTranspose,mmoOscTranspose,mmoOscGlide] then begin
            for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
             Voice:=@Track^.Voices[VoiceCounter];
             if Voice^.Active and (Voice^.Channel=Channel) then begin
              for OscillatorCounter:=0 to MaxInstrumentOscillator-1 do begin
               Voice^.OscillatorData[OscillatorCounter].NewFrequency:=true;
              end;
             end;
            end;
           end;
          end;
         end;
        end;
       end;
       Channel^.NRPNControllers[Channel^.NRPNSelect]:=Channel^.RPN.Data;
      end;
     end;
     $26:begin
      Channel^.RPN.Data:=Value or (Channel^.RPN.Data and $3f80);
     end;
     $60:begin
      if Channel^.RPN.Parameter in [2,3,4] then begin
       inc(Channel^.RPN.Data,128);
      end else begin
       inc(Channel^.RPN.Data,1);
      end;
     end;
     $61:begin
      if Channel^.RPN.Parameter in [2,3,4] then begin
       dec(Channel^.RPN.Data,128);
      end else begin
       dec(Channel^.RPN.Data,1);
      end;
     end;
    end;
    SynthProcessRPN(Track,Channel);
    SynthProcessNRPN(Track,Channel);
   end;

   $07:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.MainVolume:=((Value shl 7) or (Channel^.MainVolume and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $27:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.MainVolume:=((Value and FineMask) or (Channel^.MainVolume and $3f80)) or ((Channel^.MainVolume shr 7) and InvFineMask);
    end;
   end;

   $08:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Balance:=((Value shl 7) or (Channel^.Balance and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $28:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Balance:=((Value and FineMask) or (Channel^.Balance and $3f80)) or ((Channel^.Balance shr 7) and InvFineMask);
    end;
   end;

   $0a:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Panning:=((Value shl 7) or (Channel^.Panning and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $2a:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Panning:=((Value and FineMask) or (Channel^.Panning and $3f80)) or ((Channel^.Panning shr 7) and InvFineMask);
    end;
   end;

   $0b:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Expression:=((Value shl 7) or (Channel^.Expression and FineMask)) or (Value and InvFineMask);
    end;
   end;
   $2b:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Expression:=((Value and FineMask) or (Channel^.Expression and $3f80)) or ((Channel^.Expression shr 7) and InvFineMask);
    end;
   end;

   $40:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.HoldPedal:=(Value and 64)<>0;
    end;
   end;

   $41:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.PortamentoPedal:=(Value and 64)<>0;
    end;
   end;

   $42:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.SostenutoPedal:=(Value and 64)<>0;
     if Channel^.SostenutoPedal then begin
      for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
       Voice:=@Track^.Voices[VoiceCounter];
       if Voice^.Active and (Voice^.Channel=Channel) then begin
        Voice^.Sostenutoing:=true;
       end;
      end;
     end;
    end;
   end;

   $43:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.SoftPedal:=(Value and 64)<>0;
    end;
   end;

   $44:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.LegatoPedal:=(Value and 64)<>0;
    end;
   end;

   $45:begin
    if Track^.GeneralMIDIMode<>0 then begin
     Channel^.Hold2Pedal:=(Value and 64)<>0;
    end;
   end;

   $62:begin
    Channel^.RPN.NParameter:=Value or (Channel^.RPN.NParameter and $3f80);
    Channel^.RPN.Parameter:=0;
    Channel^.WorkControllers[$63]:=0;
    Channel^.NRPNSelect:=0;
   end;
   $63:begin
    Channel^.RPN.NParameter:=(Value shl 7) or (Channel^.RPN.NParameter and $7f);
    Channel^.RPN.Parameter:=0;
    if Channel^.WorkControllers[$62]=120 then begin
     case Value of
      100:begin
       inc(Channel^.NRPNSelect,100);
      end;
      101:begin
       inc(Channel^.NRPNSelect,1000);
      end;
      102:begin
       inc(Channel^.NRPNSelect,10000);
      end;
      else begin
       if Value<100 then begin
        inc(Channel^.NRPNSelect,Value);
       end;
      end;
     end;
    end;
   end;
   $64:begin
    Channel^.RPN.Parameter:=Value or (Channel^.RPN.Parameter and $3f80);
    Channel^.RPN.NParameter:=0;
   end;
   $65:begin
    Channel^.WorkControllers[$62]:=0;
    Channel^.WorkControllers[$63]:=0;
    Channel^.NRPNSelect:=0;
    Channel^.RPN.Parameter:=(Value shl 7) or (Channel^.RPN.Parameter and $7f);
    Channel^.RPN.NParameter:=0;
   end;
   $78:begin
    SynthChannelAllSoundsOff(Track,Channel);
   end;
   $79:begin
    SynthChannelResetControllers(Track,Channel,(Value=127) or (Track^.GeneralMIDIMode<=1));
   end;
   $7b:begin
    SynthChannelAllNotesOff(Track,Channel);
   end;
   $7c,$7d:begin
    if Track^.GeneralMIDIMode<>0 then begin
     SynthChannelAllNotesOff(Track,Channel);
     Channel^.OmniMode:=Controller=$7d;
     Track^.OmniMode:=Controller=$7d;
     if not Track^.OmniMode then begin
      Track^.OmniChannel:=Channel^.Number;
     end;
    end;
   end;
   $7e,$7f:begin
    if Track^.GeneralMIDIMode<>0 then begin
     SynthChannelAllNotesOff(Track,Channel);
     Channel^.PolyMode:=Controller=$7f;
    end;
   end;
  end;
 end;
end;

procedure SynthProgramChange(Track:PSynthTrack;Channel:PSynthChannel;Data:byte);
begin
 Channel^.Instrument:=@Track^.Instruments[Data and $7f];
 Channel^.Patch:=Data;
 Track^.ChannelInitialPrograms[Channel^.Number and $f]:=Data;
end;

procedure SynthChannelAfterTouch(Track:PSynthTrack;Channel:PSynthChannel;Data:byte);
var VoiceCounter:longint;
    Voice:PSynthVoice;
begin
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  Voice:=@Track^.Voices[VoiceCounter];
  if Voice^.Active and (Voice^.Channel=Channel) then begin
   Voice^.AfterTouch:=Data;
  end;
 end;
end;

procedure SynthPitchBend(Track:PSynthTrack;Channel:PSynthChannel;Data1,Data2:byte);
var VoiceCounter:longint;
    Voice:PSynthVoice;
begin
 Channel^.PitchBend:=(Data1 and $7f)+((Data2 and $7f) shl 7);
 for VoiceCounter:=0 to Track^.Global.Voices.Count-1 do begin
  Voice:=@Track^.Voices[VoiceCounter];
  if Voice^.Channel=Channel then begin
   SynthRecalculateVoice(Track,Voice);
  end;
 end;
end;

procedure SynthExtendedCommand(Track:PSynthTrack;Channel:PSynthChannel;Command,Data1,Data2,Data3,Data4:byte;SysEx:pansichar;SysExLength:longint);
var TuningProgramNumber,TuningBankNumber:byte;
    i,j,k,Count,ChannelMap,n:longint;
begin
 case Command and $f of
  0:begin
   if (SysExLength>0) and assigned(sysEx) then begin
    if (SysExLength>=8) and
       (byte(SysEx[0])=$43) and // Yamaha ID
       (byte(SysEx[2])=$4C) and // XG model id
       (((byte(SysEx[1])<$10) and (byte(SysEx[5])=$02)) or // Bulk dump
        ((byte(SysEx[1])>=$10) and (byte(SysEx[3])=$02))) then begin // Parameter change
     // XG effects 1 or Multi-EQ
    end else if (SysExLength>=8) and
                (byte(SysEx[0])=$43) and // Yamaha ID
                (byte(SysEx[2])=$4C) and // XG model id
                (((byte(SysEx[1])<$10) and (byte(SysEx[5])=$03)) or // Bulk dump
                 ((byte(SysEx[1])>=$10) and (byte(SysEx[3])=$03))) then begin // Parameter change
     // XG effects 2 (Insertion effects)
    end else if (SysExLength>=10) and
                (byte(SysEx[0])=$43) and // Yamaha ID
                (byte(SysEx[2])=$4C) and // XG model id
                (((byte(SysEx[1])<$10) and (byte(SysEx[5])=$08) and ((byte(SysEx[4])) in [$29,$3f])) or // Bulk dump
                 ((byte(SysEx[1])>=$10) and (byte(SysEx[3])=$08))) then begin // Parameter change
     // XG multi part data parameter change
    end else if (SysExLength>=10) and
                (byte(SysEx[0])=$43) and // Yamaha ID
                (byte(SysEx[2])=$4C) and // XG model id
                (((byte(SysEx[1])<$10) and ((byte(SysEx[5]) and $f0)=$30)) or // Bulk dump
                 ((byte(SysEx[1])>=$10) and ((byte(SysEx[3]) and $f0)=$30))) then begin // Parameter change
     // XG drum setup
    end else if (SysExLength>9) and
                (byte(SysEx[0])=$41) and // Roland ID
                (byte(SysEx[1])=$10) and // Device ID
                (byte(SysEx[2])=$42) and // GS model id
                (byte(SysEx[3])=$12) then begin // Data set command
     // GS system exclusive message
     // sysex[4]=Parameter address(High)
     // sysex[5]=Parameter address(Middle)
     // sysex[6]=Parameter address(Low)
     // sysex[7..]=Data...
     // sysex[last]=Checksum(== 128 - (sum of addresses&data bytes % 128))
    end else if (SysExLength>4) and (byte(SysEx[0]) in [$7e,$7f]) then begin
     // Non-realtime / Realtime universal sysex messages
     // $7e=non-realtime / $7f=realTime
     // 1 Sysex device ID. Could be from $00 to $7f.
     //   $7f means disregard device.
     // 2 Sub ID
     // ...
     // E $f7
     case byte(SysEx[2]) of
      $01:begin
       // Sample dump header
      end;
      $02:begin
       // Sample dump packet
      end;
      $03:begin
       // Dump request
      end;
      $04:begin
       // Device control
       if SysExLength>=3 then begin
        case byte(SysEx[2]) of
         $01:begin
          // Master volume
          if SysExLength>=5 then begin
           Track^.MasterVolume:=((byte(SysEx[4]) and $7f) shl 7) or (byte(SysEx[3]) and $7f);
          end;
         end;
         $02:begin
          // Master balance
          if SysExLength>=5 then begin
           Track^.MasterBalance:=((byte(SysEx[4]) and $7f) shl 7) or (byte(SysEx[3]) and $7f);
          end;
         end;
         $03:begin
          // Master fine tuning
          if SysExLength>=5 then begin
           Track^.MasterFineTuning:=(((byte(SysEx[4]) and $7f) shl 7) or (byte(SysEx[3]) and $7f))/16384;
          end;
         end;
         $04:begin
          // Master coarse tuning
          if SysExLength>=5 then begin
           Track^.MasterCoarseTuning:=(((byte(SysEx[4]) and $7f) shl 7) or (byte(SysEx[3]) and $7f))/16384;
          end;
         end;
         $05:begin
          // Global parameter control
          if SysExLength>=6 then begin
{          SlotPathLen:=byte(SysEx[4]);
           ParamWidth:=byte(SysEx[5]);
           ValueWidth:=byte(SysEx[6]);
           SlotPath:=nil;
           setlength(SlotPath,SlotPathLen);
           j:=7;
           for i:=0 to SlotPathLen-1 do begin
            SlotPath[i]:=((byte(SysEx[j]) and $7f) shl 7) or (byte(SysEx[j+1]) and $7f);
            inc(j,2);
           end;
           Params:=nil;
           Values:=nil;
           if (ParamWidth+ValueWidth)>0 then begin
            ParamCount:=(SysExLength-1-j) div (ParamWidth+ValueWidth);
            setlength(Params,ParamCount);
            setlength(Values,ParamCount);
            for i:=0 to ParamCount-1 do begin
             Values[i]:=0;
             Params[i]:=0;
             for k:=0 to ParamWidth-1 do begin
              Params[i]:=(Params[i] shl 7) or (byte(SysEx[j]) and $7f);
              inc(j);
             end;
             for k:=0 to ValueWidth-1 do begin
              Values[i]:=(Values[i] shl 7) or (byte(SysEx[j]) and $7f);
              inc(j);
             end;
            end;
            Synth.GlobalParameterControlChange(SlotPath,Params,Values);
           end;
           setlength(SlotPath,0);
           setlength(Params,0);
           setlength(Values,0);}
          end;
         end;
        end;
       end;
      end;
      $05:begin
       // Sample dump extensions
      end;
      $06:begin
       // Inquiry Message
      end;
      $07:begin
       // File dump
      end;
      $08:begin
       // MIDI tuning standard
       case byte(SysEx[3]) of
        $00:begin
         // Bulk tuning dump request
        end;
        $01:begin
         if (byte(SysEx[0])=$7e) and (SysExLength>=405) then begin
          // Bulk tuning dump (non real-time)
          TuningProgramNumber:=byte(SysEx[4]);
          for i:=0 to 127 do begin
           if (byte(SysEx[21+(i*3)])<>$7f) and
              (byte(SysEx[21+(i*3)+1])<>$7f) and
              (byte(SysEx[21+(i*3)+2])<>$7f) then begin
            j:=byte(SysEx[21+(i*3)]) and $7f;
            k:=((byte(SysEx[21+(i*3)+1]) and $7f) shl 7) or (byte(SysEx[21+(i*3)+2]) and $7f);
            Track^.TuningTables[Channel^.TuningBank,TuningProgramNumber,i]:=j+(k*fCI16384);
           end;
          end;
         end;
        end;
        $02:begin
         if (byte(SysEx[0])=$7f) and (SysExLength>=5) then begin
          // Single note tuning change (real-time)
          TuningProgramNumber:=byte(SysEx[4]);
          Count:=byte(SysEx[5]);
          for i:=0 to Count do begin
           if ((6*(i*4)+3)<=SysExLength) and
              (byte(SysEx[6+(i*4)]) in [$0..$7f]) and
              (byte(SysEx[6+(i*4)+1])<>$7f) and
              (byte(SysEx[6+(i*4)+2])<>$7f) and
              (byte(SysEx[6+(i*4)+3])<>$7f) then begin
            j:=byte(SysEx[6+(i*4)+1]) and $7f;
            k:=((byte(SysEx[6+(i*4)+2]) and $7f) shl 7) or (byte(SysEx[6+(i*4)+3]) and $7f);
            Track^.TuningTables[Channel^.TuningBank,TuningProgramNumber,byte(SysEx[6+(i*4)]) and $7f]:=j+(k*fCI16384);
           end;
          end;
         end;
        end;
        $04:begin
         if (byte(SysEx[0])=$7e) and (SysExLength>=406) then begin
          // Key-based tuning dump (non real-time)
          TuningBankNumber:=byte(SysEx[4]);
          TuningProgramNumber:=byte(SysEx[5]);
          for i:=0 to 127 do begin
           if (byte(SysEx[22+(i*3)])<>$7f) and
              (byte(SysEx[22+(i*3)+1])<>$7f) and
              (byte(SysEx[22+(i*3)+2])<>$7f) then begin
            j:=byte(SysEx[22+(i*3)]) and $7f;
            k:=((byte(SysEx[22+(i*3)+1]) and $7f) shl 7) or (byte(SysEx[22+(i*3)+2]) and $7f);
            Track^.TuningTables[TuningBankNumber,TuningProgramNumber,i]:=j+(k*fCI16384);
           end;
          end;
         end;
        end;
        $05:begin
         if (byte(SysEx[0])=$7e) and (SysExLength>=34) then begin
          // Scale/octave tuning dump (non real-time, 1 byte format)
          TuningBankNumber:=byte(SysEx[4]);
          TuningProgramNumber:=byte(SysEx[5]);
          k:=0;
          for i:=0 to 127 do begin
           j:=(byte(SysEx[21+k]) and $7f)-$40;
           inc(k);
           if k>=12 then begin
            k:=0;
           end;
           Track^.TuningTables[TuningBankNumber,TuningProgramNumber,i]:={Synth.TuningTables[TuningBankNumber,TuningProgramNumber,i]}i+(j*fCI100);
          end;
         end;
        end;
        $06:begin
         if (byte(SysEx[0])=$7e) and (SysExLength>=46) then begin
          // Scale/octave tuning dump (non real-time, 2 byte format)
          TuningBankNumber:=byte(SysEx[4]);
          TuningProgramNumber:=byte(SysEx[5]);
          k:=0;
          for i:=0 to 127 do begin
           j:=(((byte(SysEx[21+(k*2)]) and $7f) shl 7) or (byte(SysEx[21+(k*2)+1]) and $7f))-$2000;
           inc(k);
           if k>=12 then begin
            k:=0;
           end;
           Track^.TuningTables[TuningBankNumber,TuningProgramNumber,i]:={Synth.TuningTables[TuningBankNumber,TuningProgramNumber,i]}i+(j*fCI8192);
          end;
         end;
        end;
        $07:begin
         if SysExLength>=6 then begin
          // Single note tuning change (bank)
          TuningBankNumber:=byte(SysEx[4]);
          TuningProgramNumber:=byte(SysEx[5]);
          Count:=byte(SysEx[6]);
          for i:=0 to Count do begin
           if ((7*(i*4)+3)<=SysExLength) and
              (byte(SysEx[7+(i*4)]) in [$0..$7f]) and
              (byte(SysEx[7+(i*4)+1])<>$7f) and
              (byte(SysEx[7+(i*4)+2])<>$7f) and
              (byte(SysEx[7+(i*4)+3])<>$7f) then begin
            j:=byte(SysEx[7+(i*4)+1]) and $7f;
            k:=((byte(SysEx[7+(i*4)+2]) and $7f) shl 7) or (byte(SysEx[7+(i*4)+3]) and $7f);
            Track^.TuningTables[TuningBankNumber,TuningProgramNumber,byte(SysEx[7+(i*4)]) and $7f]:=j+(k*fCI16384);
           end;
          end;
         end;
        end;
        $08:begin     
         if SysExLength>=19 then begin
          // Scale/octave tuning 1-byte form
          ChannelMap:=(((byte(SysEx[4]) and 3) shl 14) or ((byte(SysEx[5]) and $7f) shl 7) or (byte(SysEx[6]) and $7f));// shl ((byte(SysEx[4]) shr 2) shl 4);
          k:=0;
          for i:=0 to 127 do begin
           j:=(byte(SysEx[7+(k*2)]) and $7f)-$40;
           inc(k);
           if k>=12 then begin
            k:=0;
           end;
           for n:=0 to NumberOfChannels-1 do begin
            if (ChannelMap and (1 shl n))<>0 then begin
             Track^.Channels[n].TuningTable[i]:=j*fCI100;
            end;
           end;
          end;
         end;
        end;
        $09:begin
         if SysExLength>=31 then begin
          // Scale/octave tuning 2-byte form
          ChannelMap:=(((byte(SysEx[4]) and 3) shl 14) or ((byte(SysEx[5]) and $7f) shl 7) or (byte(SysEx[6]) and $7f));// shl ((byte(SysEx[4]) shr 2) shl 4);
          k:=0;
          for i:=0 to 127 do begin
           j:=(((byte(SysEx[7+(k*2)]) and $7f) shl 7) or (byte(SysEx[7+(k*2)+1]) and $7f))-$2000;
           inc(k);
           if k>=12 then begin
            k:=0;
           end;
           for n:=0 to NumberOfChannels-1 do begin
            if (ChannelMap and (1 shl n))<>0 then begin
             Track^.Channels[n].TuningTable[i]:=j*fCI8192;
            end;
           end;
          end;
         end;
        end;
       end;
       if SysExLength>=1 then begin
        if byte(SysEx[0])=$7f then begin
         for i:=1 to Synth.NumberOfVoices do begin
          if Track^.Voices[i].Active then begin
           SynthRecalculateVoice(Track,@Track.Voices[i]);
          end;
         end;
        end;
       end;
      end;
      $09:begin
       // General MIDI message
       if SysExLength>=4 then begin
        case byte(SysEx[3]) of
         $01:begin
          // General midi 1 on
          Track^.GeneralMIDIMode:=1;
         end;
         $02:begin
          // General midi off
          Track^.GeneralMIDIMode:=0;
         end;
         $03:begin
          // General midi 2 on
          Track^.GeneralMIDIMode:=2;
         end;
        end;
       end;
      end;
      $0a:begin
       // DLS message
       if SysExLength>=4 then begin
        case byte(SysEx[3]) of
         $01:begin
          // DLS on
          if Track^.GeneralMIDIMode=0 then begin
           Track^.GeneralMIDIMode:=1;
          end;
          Track^.VoiceAllocationAlgorithm:=1;
         end;
         $02:begin
          // DLS off
          Track^.GeneralMIDIMode:=0;
          Track^.VoiceAllocationAlgorithm:=0;
         end;
         $03:begin
          // DLS static voice allocation mode off
          Track^.VoiceAllocationAlgorithm:=0;
         end;
         $04:begin
          // DLS static voice allocation mode on
          Track^.VoiceAllocationAlgorithm:=1;
         end;
        end;
       end;
      end;
      $7b:begin
       // End of file
      end;
      $7c:begin
       // Handshaking message: Wait
      end;
      $7d:begin
       // Handshaking message: Cancel
      end;
      $7e:begin
       // Handshaking message: NAK
      end;
      $7f:begin
       // Handshaking message: ACK
      end;
     end;
    end;
   end;
  end;
  $7:begin
   case Data1 of
    $51:begin
     Track^.Tempo:=(Data2 shl 16) or (Data3 shl 8) or Data4;
     SynthChangeTempo(Track);
    end;
   end;
  end;
  $f:begin     
   SynthResetChannels(Track);
   SynthResetVoices(Track);
  end;
 end;
end;

procedure SynthProcessEvent(Track:PSynthTrack;Event:PSynthEvent;StartChannel:longint=-1;CurrentChannel:longint=-1;Remain:longint=NumberOfChannels);
var Command:byte;
    Channel:PSynthChannel;
begin
 if Remain>0 then begin
  Command:=Event^.Command;
  case Command of
   MIDI_ALLNOTESOFF:begin
    SynthAllNotesOff(Track);
   end;
   else begin
    if CurrentChannel<0 then begin
     Channel:=@Track^.Channels[Command and $0f];
     StartChannel:=Command and $0f;
    end else begin
     Channel:=@Track^.Channels[CurrentChannel and $f];
    end;
    if StartChannel<>CurrentChannel then begin
     case Command and $f0 of
      MIDI_NOTEON:begin
       SynthNoteOn(Track,Channel,Event^.Data[1],Event^.Data[2]);
      end;
      MIDI_NOTEOFF:begin
       SynthNoteOff(Track,Channel,Event^.Data[1],Event^.Data[2]);
      end;
      MIDI_KEYAFTERTOUCH:begin
       SynthKeyAfterTouch(Track,Channel,Event^.Data[1],Event^.Data[2]);
      end;
      MIDI_CONTROLCHANGE:begin
       SynthControlChange(Track,Channel,Event^.Data[1],Event^.Data[2]);
      end;
      MIDI_PROGRAMCHANGE:begin
       SynthProgramChange(Track,Channel,Event^.Data[1]);
      end;
      MIDI_CHANNELAFTERTOUCH:begin
       SynthChannelAfterTouch(Track,Channel,Event^.Data[1]);
      end;
      MIDI_PITCHBEND:begin
       SynthPitchBend(Track,Channel,Event^.Data[1],Event^.Data[2]);
      end;
      MIDI_BEGINSYSEX:begin
       SynthExtendedCommand(Track,Channel,Command,Event^.Data[1],Event^.Data[2],Event^.Data[3],Event^.Data[4],Event^.SysEx,Event^.SysExLen);
      end;
     end;
     if (((assigned(Channel^.Instrument) and (Channel^.Instrument^.Link.Active and ((Channel^.Instrument^.Link.Channel>=0) and (Channel^.Instrument^.Link.Channel<=$f)))) and
         ((Command and $f0) in [MIDI_NOTEON,MIDI_NOTEOFF,MIDI_KEYAFTERTOUCH,MIDI_CONTROLCHANGE,MIDI_PROGRAMCHANGE,MIDI_CHANNELAFTERTOUCH,MIDI_PITCHBEND])) and
         ((Channel^.Instrument^.Link.ProgramNr<0) or ((Command and $f0)<>MIDI_PROGRAMCHANGE))) and
         (CurrentChannel<>(Channel^.Instrument^.Link.Channel and $f)) then begin
      if (Channel^.Instrument^.Link.ProgramNr>=0) and
         ((Track^.Channels[Channel^.Instrument^.Link.Channel and $f].Instrument<>@Track^.Instruments[Channel^.Instrument^.Link.ProgramNr and $7f]) or
          (Track^.Channels[Channel^.Instrument^.Link.Channel and $f].Patch<>(Channel^.Instrument^.Link.ProgramNr and $7f))) then begin
       SynthProgramChange(Track,@Track^.Channels[Channel^.Instrument^.Link.Channel and $f],Channel^.Instrument^.Link.ProgramNr and $7f);
      end;
      SynthProcessEvent(Track,Event,StartChannel,Channel^.Instrument^.Link.Channel and $f,Remain-1);
     end;
    end;
   end;
  end;
 end;
end;

{$ifdef UseSSE}
procedure SynthMixToBufferSSE(Src,Dest:PSynthBufferSample;SamplesCount:longint); assembler; register;
asm
 mov eax,dword ptr Src
 mov edx,dword ptr Dest
 xchg eax,edx

 mov ecx,dword ptr SamplesCount
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        addps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        addps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        addps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     addps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     addps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     addps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    addss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthMixToBuffer(Src,Dest:PSynthBufferSample;SamplesCount:longint);
var SamplesCounter:longint;
begin
 for SamplesCounter:=1 to SamplesCount shr 2 do begin
  Dest^.Left:=Dest^.Left+Src^.Left;
  Dest^.Right:=Dest^.Right+Src^.Right;
  inc(Src);
  inc(Dest);
  Dest^.Left:=Dest^.Left+Src^.Left;
  Dest^.Right:=Dest^.Right+Src^.Right;
  inc(Src);
  inc(Dest);
  Dest^.Left:=Dest^.Left+Src^.Left;
  Dest^.Right:=Dest^.Right+Src^.Right;
  inc(Src);
  inc(Dest);
  Dest^.Left:=Dest^.Left+Src^.Left;
  Dest^.Right:=Dest^.Right+Src^.Right;
  inc(Src);
  inc(Dest);
 end;
 for SamplesCounter:=1 to SamplesCount and 3 do begin
  Dest^.Left:=Dest^.Left+Src^.Left;
  Dest^.Right:=Dest^.Right+Src^.Right;
  inc(Src);
  inc(Dest);
 end;
end;

{$ifdef UseSSE}
procedure SynthCopyAndMulOnlyBufferSSE(Src,Dest:PSynthBufferSample;MulBuf:PSynthFloatValue;SamplesCount:longint); assembler;
asm
 push esi

 mov eax,dword ptr Src
 mov edx,dword ptr Dest
 mov esi,dword ptr MulBuf

 mov ecx,dword ptr SamplesCount
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movlps xmm5,[esi]
        shufps xmm5,xmm5,$50
        mulps xmm0,xmm5

        movaps xmm1,[eax+16]
        movlps xmm5,[esi+8]
        shufps xmm5,xmm5,$50
        mulps xmm1,xmm5

        movaps xmm2,[eax+32]
        movlps xmm5,[esi+16]
        shufps xmm5,xmm5,$50
        mulps xmm2,xmm5

        movaps xmm3,[eax+48]
        movlps xmm5,[esi+24]
        shufps xmm5,xmm5,$50
        mulps xmm3,xmm5

        movaps [edx],xmm0
        movaps [edx+16],xmm1
        movaps [edx+32],xmm2
        movaps [edx+48],xmm3

        add eax,64
        add edx,64
        add esi,32
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movlps xmm5,[esi]
        shufps xmm5,xmm5,$50
        mulps xmm0,xmm5
        movaps [edx],xmm0
        add eax,16
        add edx,16
        add esi,8
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movlps xmm5,[esi]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm7
     mulps xmm0,xmm5

     movups xmm1,[eax+16]
     movlps xmm5,[esi+8]
     shufps xmm5,xmm5,$50
     mulps xmm1,xmm5

     movups xmm2,[eax+32]
     movlps xmm5,[esi+16]
     shufps xmm5,xmm5,$50
     mulps xmm2,xmm5

     movups xmm3,[eax+48]
     movlps xmm5,[esi+24]
     shufps xmm5,xmm5,$50
     mulps xmm3,xmm5

     movups [edx],xmm0
     movups [edx+16],xmm1
     movups [edx+32],xmm2
     movups [edx+48],xmm3

     add eax,64
     add edx,64
     add esi,32
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movlps xmm5,[esi]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm5
     movups [edx],xmm0
     add eax,16
     add edx,16
     add esi,8
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   shr ecx,1
   jecxz @Done
   @SmallInnerLoop:
    movss xmm2,dword ptr [esi]
    movss xmm0,dword ptr [eax]
    movss xmm1,dword ptr [eax+4]
    mulss xmm0,xmm2
    mulss xmm1,xmm2
    movss dword ptr [edx],xmm0
    movss dword ptr [edx+4],xmm1
    add eax,8
    add edx,8
    add esi,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:

 pop esi
end;

procedure SynthCopyAndMulBufferSSE(Src,Dest:PSynthBufferSample;MulBuf:PSynthFloatValue;Amp:single;SamplesCount:longint); assembler;
asm
 push esi

 mov eax,dword ptr Src
 mov edx,dword ptr Dest
 mov esi,dword ptr MulBuf

 mov ecx,dword ptr SamplesCount
 test ecx,ecx
 jz @Done

  add ecx,ecx

  movss xmm7,dword ptr Amp
  shufps xmm7,xmm7,0

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movlps xmm5,[esi]
        shufps xmm5,xmm5,$50
        mulps xmm0,xmm7
        mulps xmm0,xmm5

        movaps xmm1,[eax+16]
        movlps xmm5,[esi+8]
        shufps xmm5,xmm5,$50
        mulps xmm1,xmm7
        mulps xmm1,xmm5

        movaps xmm2,[eax+32]
        movlps xmm5,[esi+16]
        shufps xmm5,xmm5,$50
        mulps xmm2,xmm7
        mulps xmm2,xmm5

        movaps xmm3,[eax+48]
        movlps xmm5,[esi+24]
        shufps xmm5,xmm5,$50
        mulps xmm3,xmm7
        mulps xmm3,xmm5

        movaps [edx],xmm0
        movaps [edx+16],xmm1
        movaps [edx+32],xmm2
        movaps [edx+48],xmm3

        add eax,64
        add edx,64
        add esi,32
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movlps xmm5,[esi]
        shufps xmm5,xmm5,$50
        mulps xmm0,xmm7
        mulps xmm0,xmm5
        movaps [edx],xmm0
        add eax,16
        add edx,16
        add esi,8
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movlps xmm5,[esi]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm7
     mulps xmm0,xmm5

     movups xmm1,[eax+16]
     movlps xmm5,[esi+8]
     shufps xmm5,xmm5,$50
     mulps xmm1,xmm7
     mulps xmm1,xmm5

     movups xmm2,[eax+32]
     movlps xmm5,[esi+16]
     shufps xmm5,xmm5,$50
     mulps xmm2,xmm7
     mulps xmm2,xmm5

     movups xmm3,[eax+48]
     movlps xmm5,[esi+24]
     shufps xmm5,xmm5,$50
     mulps xmm3,xmm7
     mulps xmm3,xmm5

     movups [edx],xmm0
     movups [edx+16],xmm1
     movups [edx+32],xmm2
     movups [edx+48],xmm3

     add eax,64
     add edx,64
     add esi,32
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movlps xmm5,[esi]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm7
     mulps xmm0,xmm5
     movups [edx],xmm0
     add eax,16
     add edx,16
     add esi,8
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   shr ecx,1
   jecxz @Done
   @SmallInnerLoop:
    movss xmm2,dword ptr [esi]
    movss xmm0,dword ptr [eax]
    movss xmm1,dword ptr [eax+4]
    mulss xmm0,xmm7
    mulss xmm0,xmm2
    mulss xmm1,xmm7
    mulss xmm1,xmm2
    movss dword ptr [edx],xmm0
    movss dword ptr [edx+4],xmm1
    add eax,8
    add edx,8
    add esi,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:

 pop esi
end;
{$endif}

procedure SynthCopyAndMulBuffer(Src,Dest:PSynthBufferSample;MulBuf:PSynthFloatValue;Amp:single;SamplesCount:longint);
var SamplesCounter:longint;
begin
 for SamplesCounter:=1 to SamplesCount shr 2 do begin
  Dest^.Left:=(Src^.Left*Amp)*MulBuf^;
  Dest^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(Dest);
  inc(MulBuf);
  Dest^.Left:=(Src^.Left*Amp)*MulBuf^;
  Dest^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(Dest);
  inc(MulBuf);
  Dest^.Left:=(Src^.Left*Amp)*MulBuf^;
  Dest^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(Dest);
  inc(MulBuf);
  Dest^.Left:=(Src^.Left*Amp)*MulBuf^;
  Dest^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(Dest);
  inc(MulBuf);
 end;
 for SamplesCounter:=1 to SamplesCount and 3 do begin
  Dest^.Left:=(Src^.Left*Amp)*MulBuf^;
  Dest^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(Dest);
  inc(MulBuf);
 end;
end;

{$ifdef UseSSE}
procedure SynthOnlyMulBufferSSE(Src:PSynthBufferSample;MulBuf:PSynthFloatValue;Amp:single;SamplesCount:longint); assembler;
asm
 mov eax,dword ptr Src
 mov edx,dword ptr MulBuf

 mov ecx,dword ptr SamplesCount
 test ecx,ecx
 jz @Done

  add ecx,ecx

  movss xmm7,dword ptr Amp
  shufps xmm7,xmm7,0

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       movlps xmm5,[edx]
       shufps xmm5,xmm5,$50
       mulps xmm0,xmm7
       mulps xmm0,xmm5

       movaps xmm1,[eax+16]
       movlps xmm5,[edx+8]
       shufps xmm5,xmm5,$50
       mulps xmm1,xmm7
       mulps xmm1,xmm5

       movaps xmm2,[eax+32]
       movlps xmm5,[edx+16]
       shufps xmm5,xmm5,$50
       mulps xmm2,xmm7
       mulps xmm2,xmm5

       movaps xmm3,[eax+48]
       movlps xmm5,[edx+24]
       shufps xmm5,xmm5,$50
       mulps xmm3,xmm7
       mulps xmm3,xmm5

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       add edx,32
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       movlps xmm5,[edx]
       shufps xmm5,xmm5,$50
       mulps xmm0,xmm7
       mulps xmm0,xmm5
       movaps [eax],xmm0
       add eax,16
       add edx,8
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movlps xmm5,[edx]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm7
     mulps xmm0,xmm5

     movups xmm1,[eax+16]
     movlps xmm5,[edx+8]
     shufps xmm5,xmm5,$50
     mulps xmm1,xmm7
     mulps xmm1,xmm5

     movups xmm2,[eax+32]
     movlps xmm5,[edx+16]
     shufps xmm5,xmm5,$50
     mulps xmm2,xmm7
     mulps xmm2,xmm5

     movups xmm3,[eax+48]
     movlps xmm5,[edx+24]
     shufps xmm5,xmm5,$50
     mulps xmm3,xmm7
     mulps xmm3,xmm5

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,32
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movlps xmm5,[edx]
     shufps xmm5,xmm5,$50
     mulps xmm0,xmm7
     mulps xmm0,xmm5
     movups [eax],xmm0
     add eax,16
     add edx,8
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   shr ecx,1
   jecxz @Done
   @SmallInnerLoop:
    movss xmm2,dword ptr [edx]
    movss xmm0,dword ptr [eax]
    movss xmm1,dword ptr [eax+4]
    mulss xmm0,xmm7
    mulss xmm0,xmm2
    mulss xmm1,xmm7
    mulss xmm1,xmm2
    movss dword ptr [eax],xmm0
    movss dword ptr [eax+4],xmm1
    add eax,8
    add edx,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:
end;
{$endif}

procedure SynthOnlyMulBuffer(Src:PSynthBufferSample;MulBuf:PSynthFloatValue;Amp:single;SamplesCount:longint);
var SamplesCounter:longint;
begin
 for SamplesCounter:=1 to SamplesCount shr 2 do begin
  Src^.Left:=(Src^.Left*Amp)*MulBuf^;
  Src^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(MulBuf);
  Src^.Left:=(Src^.Left*Amp)*MulBuf^;
  Src^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(MulBuf);
  Src^.Left:=(Src^.Left*Amp)*MulBuf^;
  Src^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(MulBuf);
  Src^.Left:=(Src^.Left*Amp)*MulBuf^;
  Src^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(MulBuf);
 end;
 for SamplesCounter:=1 to SamplesCount and 3 do begin
  Src^.Left:=(Src^.Left*Amp)*MulBuf^;
  Src^.Right:=(Src^.Right*Amp)*MulBuf^;
  inc(Src);
  inc(MulBuf);
 end;
end;

type TSynthLastBufferUseFunc=function(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}

function SynthLastBufferUse(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}
begin
 result:=(LastBuffer^.Left+LastBuffer^.Right)*0.5;
end;

function SynthLastBufferNoUse(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}
begin
 result:=0;
end;

const SynthLastBufferUseFuncs:array[boolean] of TSynthLastBufferUseFunc=(SynthLastBufferNoUse,SynthLastBufferUse);

type TSynthLastBufferMulUseFunc=function(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}

function SynthLastBufferMulUse(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}
begin
 result:=(LastBuffer^.Left+LastBuffer^.Right)*0.5;
end;

function SynthLastBufferMulNoUse(const LastBuffer:PSynthBufferSample):single; {$ifdef cpu386}register;{$endif}
begin
 result:=1;
end;

const SynthLastBufferMulUseFuncs:array[boolean] of TSynthLastBufferMulUseFunc=(SynthLastBufferMulNoUse,SynthLastBufferMulUse);

type TSynthPMFMExtendedModeFunc=function(const Value:TSynthFloatValue):single; {$ifdef cpu386}register;{$endif}

function SynthPMFMExtendedModeOn(const Value:TSynthFloatValue):single; {$ifdef cpu386}register;{$endif}
begin
 result:=Value;
end;

function SynthPMFMExtendedModeOff(const Value:TSynthFloatValue):single; {$ifdef cpu386}register;{$endif}
begin
 result:=1;
end;

const SynthPMFMExtendedModeFuncs:array[boolean] of TSynthPMFMExtendedModeFunc=(SynthPMFMExtendedModeOff,SynthPMFMExtendedModeOn);

type TSynthOscillatorGenerateWaveFormProc=procedure(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);

procedure SynthOscillatorGenerateWaveFormNone(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
begin
end;

procedure SynthOscillatorGenerateWaveFormSine(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,LastBufferAssignedPMM,
    LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and not
    (assigned(LastTarget) or Oscillator^.HardSync) then begin
  Buffer:=Target;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   Value:=sin(2*PI*frac(Phase+(Value*FeedBack)));
   Phase:=frac(Phase+PhaseIncrement);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end else begin
  PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
  LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
  LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
  LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
  LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
  Buffer:=Target;
  LastBuffer:=LastTarget;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   TempValue:=PhaseIncrement*PitchBuffer^;
   Value:=sin(2*PI*frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer))));
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(FeedBackBuffer);
   inc(PitchBuffer);
   inc(HardSyncActiveBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormTriangle(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,
    WidthModulation,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if Oscillator^.Color=0 then begin
  WidthModulation:=0.5;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
  if Oscillator^.Color=0 then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=Phase+(Value*FeedBack);
    Value:=(abs(frac(PhaseEx+0.5)-0.5)*4)-1;
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=(sqr((frac(PhaseEx+0.5)-0.5)*2)-0.5)-(sqr((frac((PhaseEx+0.5)-WidthModulation)-0.5)*2)-0.5);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
  for SampleCounter:=1 to Samples do begin
   TempValue:=PhaseIncrement*PitchBuffer^;
   inc(PitchBuffer);
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
   Value:=(sqr((frac(PhaseEx+0.5)-0.5)*2)-0.5)-(sqr((frac((PhaseEx+0.5)-Clip(WidthModulation*ColorBuffer^,0,1))-0.5)*2)-0.5);
   inc(ColorBuffer);
   inc(FeedBackBuffer);
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   inc(HardSyncActiveBuffer);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormParabola(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,TempValue,PhaseEx:single;
    LastBufferAssignedPM,LastBufferAssignedFM,LastBufferAssignedPMM,
    LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and not
    (assigned(LastTarget) or Oscillator^.HardSync) then begin
  Buffer:=Target;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   PhaseEx:=Phase+(Value*FeedBack);
   Value:=(sqr((frac(PhaseEx+0.5)-0.5)*2)-0.5)*2;
   Phase:=frac(Phase+PhaseIncrement);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end else begin
  PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
  LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
  LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
  LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
  LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
  Buffer:=Target;
  LastBuffer:=LastTarget;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   TempValue:=PhaseIncrement*PitchBuffer^;
   PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
   Value:=(sqr((frac(PhaseEx+0.5)-0.5)*2)-0.5)*2;
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(FeedBackBuffer);
   inc(PitchBuffer);
   inc(HardSyncActiveBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormPulse(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter,NewPhaseValue:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,NewPhase,
    WidthModulation,TempValue:single;
    NewPhaseCasted:longword absolute NewPhase;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if Oscillator^.Color=0 then begin
  WidthModulation:=0.5;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   NewPhase:=frac(Phase+(Value*FeedBack));
   NewPhase:=(NewPhase+longword(plongword(@NewPhase)^ shr 31))-WidthModulation;
   Phase:=frac(Phase+PhaseIncrement);
   NewPhaseValue:=1-longint(longword(longword(longword(NewPhaseCasted) shr 31) shl 1));
   Value:=NewPhaseValue;
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
 end else begin
  for SampleCounter:=1 to Samples do begin
   TempValue:=PhaseIncrement*PitchBuffer^;
   inc(PitchBuffer);
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   NewPhase:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)))-Clip(WidthModulation*ColorBuffer^,0,1);
   inc(ColorBuffer);
   inc(FeedBackBuffer);
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   inc(HardSyncActiveBuffer);
   NewPhaseValue:=1-longint(longword(longword(longword(NewPhaseCasted) shr 31) shl 1));
   Value:=NewPhaseValue;
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormSawUp(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,TempValue,PhaseEx:single;
    LastBufferAssignedPM,LastBufferAssignedFM,LastBufferAssignedPMM,
    LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and not
    (assigned(LastTarget) or Oscillator^.HardSync) then begin
  Buffer:=Target;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   PhaseEx:=Phase+(Value*FeedBack);
   Value:=(frac(PhaseEx)-0.5)*2;
   Phase:=frac(Phase+PhaseIncrement);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end else begin
  PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
  LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
  LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
  LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
  LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
  Buffer:=Target;
  LastBuffer:=LastTarget;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   TempValue:=PhaseIncrement*PitchBuffer^;
   PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
   Value:=(frac(PhaseEx)-0.5)*2;
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(FeedBackBuffer);
   inc(PitchBuffer);
   inc(HardSyncActiveBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormSawDown(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,TempValue,PhaseEx:single;
    LastBufferAssignedPM,LastBufferAssignedFM,LastBufferAssignedPMM,
    LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and not
    (assigned(LastTarget) or Oscillator^.HardSync) then begin
  Buffer:=Target;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   PhaseEx:=Phase+(Value*FeedBack);
   Value:=-((frac(PhaseEx)-0.5)*2);
   Phase:=frac(Phase+PhaseIncrement);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end else begin
  PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
  LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
  LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
  LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
  LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
  Buffer:=Target;
  LastBuffer:=LastTarget;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   TempValue:=PhaseIncrement*PitchBuffer^;
   PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
   Value:=-((frac(PhaseEx)-0.5)*2);
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(FeedBackBuffer);
   inc(PitchBuffer);
   inc(HardSyncActiveBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end;
 OscillatorData^.Last:=Value;
end;

function SynthGetSawTriValueA(const NewPhaseEx,NewPhase,WidthFactorA,WidthFactorB:single):single;
begin
 result:=1-(NewPhase*WidthFactorB);
end;

function SynthGetSawTriValueB(const NewPhaseEx,NewPhase,WidthFactorA,WidthFactorB:single):single;
begin
 result:=NewPhaseEx*WidthFactorA;
end;

type TSynthGetSawTriValueFunc=function(const NewPhaseEx,NewPhase,WidthFactorA,WidthFactorB:single):single;

const SynthGetSawTriValueFuncs:array[boolean] of TSynthGetSawTriValueFunc=(SynthGetSawTriValueA,SynthGetSawTriValueB);

procedure SynthOscillatorGenerateWaveFormSawtoothTriangle(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter,Sign:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,NewPhase,NewPhaseEx,PhaseIncrement,FeedBack,Value,
    WidthModulation,WidthFactorA,WidthFactorB,ColorFactor,OldColorFactor,
    TempValue:single;
    NewPhaseCasted:longword absolute NewPhase;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
    RealWidthModulation:single;
 procedure RecalcuateColorValues;
 begin
  RealWidthModulation:=Clip(WidthModulation*ColorFactor,0,1);
  WidthFactorA:=1/RealWidthModulation;
  WidthFactorB:=1/(1-RealWidthModulation);
  longword(pointer(@WidthFactorA)^):=longword(pointer(@WidthFactorA)^) and longword($ffffffff+longword(((((longword(pointer(@WidthFactorA)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  longword(pointer(@WidthFactorB)^):=longword(pointer(@WidthFactorB)^) and longword($ffffffff+longword(((((longword(pointer(@WidthFactorB)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 end;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if ((Oscillator^.Color in [0,64]) or (Oscillator^.Color=-64)) and (ColorBuffer=Track^.F1D0Buffer) then begin
  case Oscillator^.Color of
   0:begin
    if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
       (HardSyncActiveBuffer=Track^.F1D0Buffer) and not (assigned(LastTarget) or Oscillator^.HardSync) then begin
     for SampleCounter:=1 to Samples do begin
      plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
      NewPhaseEx:=frac(Phase+(Value*FeedBack));
      NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
      Value:=(abs(NewPhaseEx-0.5)*4)-1;
      Phase:=frac(Phase+PhaseIncrement);
      Buffer^.Left:=Value;
      Buffer^.Right:=Value;
      inc(Buffer);
      inc(HardSyncBuffer);
     end;
    end else begin
     for SampleCounter:=1 to Samples do begin
      TempValue:=PhaseIncrement*PitchBuffer^;
      inc(PitchBuffer);
      plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
      NewPhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
      NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
      inc(FeedBackBuffer);
      OldPhase:=Phase;
      Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
      HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
      inc(HardSyncActiveBuffer);
      Value:=(abs(NewPhaseEx-0.5)*4)-1;
      Buffer^.Left:=Value;
      Buffer^.Right:=Value;
      inc(Buffer);
      inc(LastBuffer);
      inc(HardSyncBuffer);
     end;
    end;
   end;
   -64,64:begin
    Sign:=longint(1-((longint(Oscillator^.Color) shr 31) shl 1));
    if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
       (HardSyncActiveBuffer=Track^.F1D0Buffer) and not (assigned(LastTarget) or Oscillator^.HardSync) then begin
     for SampleCounter:=1 to Samples do begin
      plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
      NewPhaseEx:=frac(Phase+(Value*FeedBack));
      NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
      Value:=((NewPhaseEx-0.5)*2)*Sign;
      Phase:=frac(Phase+PhaseIncrement);
      Buffer^.Left:=Value;
      Buffer^.Right:=Value;
      inc(Buffer);
      inc(HardSyncBuffer);
     end;
    end else begin
     for SampleCounter:=1 to Samples do begin
      TempValue:=PhaseIncrement*PitchBuffer^;
      inc(PitchBuffer);
      plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
      NewPhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
      NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
      inc(FeedBackBuffer);
      OldPhase:=Phase;
      Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
      HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
      inc(HardSyncActiveBuffer);
      Value:=((NewPhaseEx-0.5)*2)*Sign;
      Buffer^.Left:=Value;
      Buffer^.Right:=Value;
      inc(Buffer);
      inc(LastBuffer);
      inc(HardSyncBuffer);
     end;
    end;
   end;
  end;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
  ColorFactor:=1;
  OldColorFactor:=1;
  RecalcuateColorValues;
  if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
     (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
     not (assigned(LastTarget) or Oscillator^.HardSync) then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    NewPhaseEx:=frac(Phase+(Value*FeedBack));
    NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
    NewPhase:=NewPhaseEx-RealWidthModulation;
    Value:=(SynthGetSawTriValueFuncs[boolean(longword(NewPhaseCasted) shr 31)](NewPhaseEx,NewPhase,WidthFactorA,WidthFactorB)*2)-1;
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    Phase:=frac(Phase+PhaseIncrement);
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    ColorFactor:=ColorBuffer^;
    inc(ColorBuffer);
    if plongword(@ColorFactor)^<>plongword(@OldColorFactor)^ then begin
     OldColorFactor:=ColorFactor;
     RecalcuateColorValues;
    end;
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    NewPhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    NewPhaseEx:=NewPhaseEx+longword(plongword(@NewPhaseEx)^ shr 31);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    NewPhase:=NewPhaseEx-RealWidthModulation;
    Value:=(SynthGetSawTriValueFuncs[boolean(longword(NewPhaseCasted) shr 31)](NewPhaseEx,NewPhase,WidthFactorA,WidthFactorB)*2)-1;
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormWhiteNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value:single;
    Seed:longword;
begin
 OscillatorData^.NoiseMode:=1;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 for Counter:=1 to Samples do begin
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@Value)^):=((Seed shr 9) and $7fffff) or $40000000;
  Value:=Value-3;
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
end;

procedure SynthOscillatorGenerateWaveFormPinkNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value:single;
    Seed:longword;
    State:PSynthFloatValues;
begin
 OscillatorData^.NoiseMode:=2;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 State:=@OscillatorData^.PinkNoiseStates[0];
 for Counter:=1 to Samples do begin
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@Value)^):=((Seed shr 9) and $7fffff) or $40000000;
  Value:=Value-3;
  Seed:=(Seed*1664525)+1013904223;
  if Seed<8504035 then begin // pSum=0.00198
   State^[0]:=Value*0.2398022249690977; // 3.80240/15.8564
  end else if Seed<63479616 then begin // pSum=0.01478
   State^[1]:=Value*0.1872682323856613; // 2.96940/15.8564
  end else if Seed<273933024 then begin // pSum=0.06378
   State^[2]:=Value*0.1637824474660074; // 2.59700/15.8564
  end else if Seed<1004077440 then begin // pSum=0.23378
   State^[3]:=Value*0.1946847960444994; // 3.08700/15.8564
  end else if Seed<3933245184 then begin // pSum=0.91578
   State^[4]:=Value*0.2144622991347342; // 3.40060/15.8564
  end;
  Value:=State^[0]+State^[1]+State^[2]+State^[3]+State^[4];
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
end;

procedure SynthOscillatorGenerateWaveFormGrayNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value:single;
    State:longint;
    States:PSynthTauss88NoiseStates;
begin
 if OscillatorData^.NoiseMode<>3 then begin
  OscillatorData^.NoiseMode:=3;
  OscillatorData^.GrayNoiseState:=(OscillatorData^.Seed shr 16) xor (OscillatorData^.Seed shl 16);
  Tauss88NoiseInit(OscillatorData^.GrayNoiseStates,OscillatorData^.Seed);
 end;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 States:=@OscillatorData^.GrayNoiseStates;
 State:=OscillatorData^.GrayNoiseState;
 for Counter:=1 to Samples do begin
  States^[0]:=(((States^[0] and 4294967294) shl 12) xor (((States^[0] shl 13) xor States^[0]) shr 19));
  States^[1]:=(((States^[1] and 4294967288) shl 4) xor (((States^[1] shl 2) xor States^[1]) shr 25));
  States^[2]:=(((States^[2] and 4294967280) shl 17) xor (((States^[2] shl 3) xor States^[2]) shr 11));
  longword(State):=longword(State) xor longword(1 shl ((States[0] xor States[1] xor States[2]) and 31));
  Value:=State*(4.6566128730773926e-10); // 1.0/(1 shl 31);
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.GrayNoiseState:=State;
end;

procedure SynthOscillatorGenerateWaveFormBrownNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value,Last:single;
    Seed:longword;
begin
 OscillatorData^.NoiseMode:=4;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 Last:=OscillatorData^.NoiseLast;
 for Counter:=1 to Samples do begin
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@Value)^):=(Seed shr 9) or $3e800000;
  Last:=Last+(Value-0.375);
  if Last>1 then begin
   Last:=2-Last;
  end else if Last<-1 then begin
   Last:=-(2+Last);
  end;
  Value:=Last;
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
 OscillatorData^.NoiseLast:=Last;
end;

procedure SynthOscillatorGenerateWaveFormBlueNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value,Last:single;
    Seed:longword;
begin
 OscillatorData^.NoiseMode:=5;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 Last:=OscillatorData^.NoiseLast;
 for Counter:=1 to Samples do begin
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@Value)^):=((Seed shr 9) and $7fffff) or $40000000;
  Value:=(Value-3)-Last;
  Value:=(abs(Value+1)-abs(Value-1))*0.5;
  Last:=Value;
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
 OscillatorData^.NoiseLast:=Last;
end;

procedure SynthOscillatorGenerateWaveFormClipNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value:single;
    Seed:longword;
begin
 OscillatorData^.NoiseMode:=6;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 for Counter:=1 to Samples do begin
  Seed:=(Seed*1664525)+1013904223;
  longword(pointer(@Value)^):=(Seed and $80000000) or $3f800000;
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
end;

procedure SynthOscillatorGenerateWaveFormGaussianNoise(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var Counter:longint;
    Buffer:PSynthBufferSample;
    Value,Next,x1,x2,w:single;
    Seed:longword;
    State:longbool;
begin
 if OscillatorData^.NoiseMode<>7 then begin
  OscillatorData^.NoiseMode:=7;
  OscillatorData^.GaussianNoiseState:=false;
  OscillatorData^.GaussianNoiseNext:=0;
 end;
 Buffer:=Target;
 Value:=OscillatorData^.Last;
 Seed:=OscillatorData^.Seed;
 State:=OscillatorData^.GaussianNoiseState;
 Next:=OscillatorData^.GaussianNoiseNext;
 for Counter:=1 to Samples do begin
  if State then begin
   Value:=Next;
  end else begin
   repeat
    Seed:=(Seed*1664525)+1013904223;
    longword(pointer(@x1)^):=((Seed shr 9) and $7fffff) or $40000000;
    x1:=x1-3;
    Seed:=(Seed*1664525)+1013904223;
    longword(pointer(@x2)^):=((Seed shr 9) and $7fffff) or $40000000;
    x2:=x2-3;
    w:=sqr(x1)+sqr(x2);
   until w<1.0;
   w:=FastSQRT((1e-9)-((2*ln(w))/w));
   Value:=x1*w;
   Next:=x2*w;
  end;
  State:=not State;
  Buffer^.Left:=Value;
  Buffer^.Right:=Value;
  inc(Buffer);
 end;
 OscillatorData^.Last:=Value;
 OscillatorData^.Seed:=Seed;
 OscillatorData^.GaussianNoiseState:=State;
 OscillatorData^.GaussianNoiseNext:=Next;
end;

procedure SynthOscillatorGenerateWaveFormBandlimitedTriangle(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,
    WidthModulation,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if Oscillator^.Color=0 then begin
  WidthModulation:=0.5;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=(SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx-WidthModulation,PhaseIncrement))*0.5;
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=(SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx-WidthModulation,PhaseIncrement))*0.5;
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=(SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx-Clip(WidthModulation*ColorBuffer^,0,1),PhaseIncrement))*0.5;
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=(SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx-Clip(WidthModulation*ColorBuffer^,0,1),PhaseIncrement))*0.5;
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormBandlimitedParabola(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));                                                            
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormBandlimitedPulse(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,
    WidthModulation,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if Oscillator^.Color=0 then begin
  WidthModulation:=0.5;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx-WidthModulation,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx-WidthModulation,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx-Clip(WidthModulation*ColorBuffer^,0,1),PhaseIncrement);
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx-Clip(WidthModulation*ColorBuffer^,0,1),PhaseIncrement);
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormBandlimitedSawUp(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormBandlimitedSawDown(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,PhaseEx,TempValue:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    not (assigned(LastTarget) or Oscillator^.HardSync) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(Phase+(Value*FeedBack));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end;
 end else begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end else{$endif}begin
   for SampleCounter:=1 to Samples do begin
    TempValue:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    PhaseEx:=frac(((Phase+(Value*(FeedBack*FeedBackBuffer^))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer)));
    Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,PhaseEx,PhaseIncrement);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormSuperOsc(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
const PulseOsc:array[boolean] of single=(1,-1);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,
    WidthModulation,WidthModulationEx,TempPhaseInc,Detune,p1,p2,p3:single;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,PMFMExtendedMode:boolean;
    MixFactors:array[boolean] of single;
    Highpass:boolean;
 function SuperOsc(PhaseMod,PhaseModMul:single):single;
 const SVFResonance=0.75; //2*cos(power(0.15,0.1)*pi*0.5);
       SVFScale=0.857;//sqrt(WorkSubOscillator.Resonance); //sqrt((Resonance*0.5)+0.01);
 var i:longint;
     Phase,PhaseInc,Value,SVFCutOff:single;
 begin
  result:=0;
  for i:=0 to Oscillator^.SuperOscCount-1 do begin
   Phase:=frac((OscillatorData^.SuperOscPhases[i]+PhaseMod)*PhaseModMul);
   PhaseInc:=TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,i]));
   OscillatorData^.SuperOscPhases[i]:=frac(OscillatorData^.SuperOscPhases[i]+PhaseInc);
   case Oscillator^.SuperOscWaveform of
    sowfSAWUP,sowfHPSAWUP:begin
     Value:=(Phase-0.5)*2;
    end;
    sowfSAWDOWN,sowfHPSAWDOWN:begin
     Value:=-((Phase-0.5)*2);
    end;
    sowfSINE,sowfHPSINE,sowfBLSINE:begin
     Value:=sin(Phase*2*pi);
    end;
    oswfTRIANGLE,oswfHPTRIANGLE:begin
     Value:=(sqr((frac(Phase+0.5)-0.5)*2)-0.5)-(sqr((frac((Phase+0.5)-WidthModulationEx)-0.5)*2)-0.5);
    end;
    sowfPULSE,sowfHPPULSE:begin
     Value:=PulseOsc[Phase<=WidthModulationEx];
    end;
    sowfPARABOLA,sowfHPPARABOLA:begin
     Value:=(sqr((frac(Phase+0.5)-0.5)*2)-0.5)*2;
    end;
    sowfBLSAWUP:begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      Value:=-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,Phase,PhaseInc);
     end else{$endif}begin
      Value:=-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,Phase,PhaseInc);
     end;
    end;
    sowfBLSAWDOWN:begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,Phase,PhaseInc);
     end else{$endif}begin
      Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,Phase,PhaseInc);
     end;
    end;
    oswfBLTRIANGLE:begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      Value:=(SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,Phase,PhaseInc)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,Phase-WidthModulationEx,PhaseInc))*0.5;
     end else{$endif}begin
      Value:=(SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,Phase,PhaseInc)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,Phase-WidthModulationEx,PhaseInc))*0.5;
     end;
    end;
    sowfBLPULSE:begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,Phase,PhaseInc)-SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedSaw,Phase-WidthModulationEx,PhaseInc);
     end else{$endif}begin
      Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,Phase,PhaseInc)-SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedSaw,Phase-WidthModulationEx,PhaseInc);
     end;
    end;
    sowfBLPARABOLA:begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      Value:=SynthGetBandlimitedWavetableSSE(Track,@Track^.BandlimitedParabola,Phase,PhaseInc);
     end else{$endif}begin
      Value:=SynthGetBandlimitedWavetable(Track,@Track^.BandlimitedParabola,Phase,PhaseInc);
     end;
    end;
    else begin
     Value:=0;
    end;
   end;
   if Highpass then begin
    SVFCutOff:=2*sin(pi*(PhaseInc*1.189207077{power(2,0.25)}));
    OscillatorData^.SuperOscSVF[i,1]:=(Value*SVFScale)-(OscillatorData^.SuperOscSVF[i,0]+(OscillatorData^.SuperOscSVF[i,2]*SVFResonance));
    OscillatorData^.SuperOscSVF[i,2]:=OscillatorData^.SuperOscSVF[i,2]+(OscillatorData^.SuperOscSVF[i,1]*SVFCutOff);
    OscillatorData^.SuperOscSVF[i,0]:=OscillatorData^.SuperOscSVF[i,0]+(OscillatorData^.SuperOscSVF[i,2]*SVFCutOff);
    longword(pointer(@OscillatorData^.SuperOscSVF[i,0])^):=longword(pointer(@OscillatorData^.SuperOscSVF[i,0])^) and longword($ffffffff+longword(((((longword(pointer(@OscillatorData^.SuperOscSVF[i,0])^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    Value:=OscillatorData^.SuperOscSVF[i,1];
   end;
   result:=result+(Value*MixFactors[i<>0]);
  end;
 end;
 function SuperOsc7SAW(PhaseMod,PhaseModMul:single):single;
 begin
  OscillatorData^.SuperOscPhases[0]:=frac(OscillatorData^.SuperOscPhases[0]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,0]))));
  OscillatorData^.SuperOscPhases[1]:=frac(OscillatorData^.SuperOscPhases[1]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,1]))));
  OscillatorData^.SuperOscPhases[2]:=frac(OscillatorData^.SuperOscPhases[2]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,2]))));
  OscillatorData^.SuperOscPhases[3]:=frac(OscillatorData^.SuperOscPhases[3]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,3]))));
  OscillatorData^.SuperOscPhases[4]:=frac(OscillatorData^.SuperOscPhases[4]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,4]))));
  OscillatorData^.SuperOscPhases[5]:=frac(OscillatorData^.SuperOscPhases[5]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,5]))));
  OscillatorData^.SuperOscPhases[6]:=frac(OscillatorData^.SuperOscPhases[6]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,6]))));
  result:=(((frac((OscillatorData^.SuperOscPhases[0]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[false])+
          (((frac((OscillatorData^.SuperOscPhases[1]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true])+
          (((frac((OscillatorData^.SuperOscPhases[2]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true])+
          (((frac((OscillatorData^.SuperOscPhases[3]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true])+
          (((frac((OscillatorData^.SuperOscPhases[4]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true])+
          (((frac((OscillatorData^.SuperOscPhases[5]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true])+
          (((frac((OscillatorData^.SuperOscPhases[6]+PhaseMod)*PhaseModMul)-0.5)*2)*MixFactors[true]);
 end;
begin
 Buffer:=Target;
 Phase:=OscillatorData^.Phase;
 PhaseIncrement:=OscillatorData^.PhaseIncrement;
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 if Oscillator^.Color=0 then begin
  WidthModulation:=0.5;
 end else begin
  WidthModulation:=(Oscillator^.Color+$40)*fCI128;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 Highpass:=Oscillator^.SuperOscWaveform in [sowfHPSAWUP..sowfHPPARABOLA];
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 if (Oscillator^.SuperOscWaveform=sowfSAWUP) and (Oscillator^.SuperOscCount=7) then begin
  if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
     (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
     (SuperOscDetuneBuffer=Track^.F1D0Buffer) and (SuperOscMixBuffer=Track^.F1D0Buffer) and
     not (assigned(LastTarget) or Oscillator^.HardSync) then begin
   TempPhaseInc:=PhaseIncrement;
   WidthModulationEx:=WidthModulation;
   Detune:=LinearToDetune(Oscillator^.SuperOscDetune*fCI255);
   MixFactors[false]:=LinearToCenterOscAmp(Oscillator^.SuperOscMix*fCI255);
   MixFactors[true]:=LinearToSideOscAmp(Oscillator^.SuperOscMix*fCI255);
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    OscillatorData^.SuperOscPhases[0]:=frac(OscillatorData^.SuperOscPhases[0]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,0]))));
    OscillatorData^.SuperOscPhases[1]:=frac(OscillatorData^.SuperOscPhases[1]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,1]))));
    OscillatorData^.SuperOscPhases[2]:=frac(OscillatorData^.SuperOscPhases[2]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,2]))));
    OscillatorData^.SuperOscPhases[3]:=frac(OscillatorData^.SuperOscPhases[3]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,3]))));
    OscillatorData^.SuperOscPhases[4]:=frac(OscillatorData^.SuperOscPhases[4]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,4]))));
    OscillatorData^.SuperOscPhases[5]:=frac(OscillatorData^.SuperOscPhases[5]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,5]))));
    OscillatorData^.SuperOscPhases[6]:=frac(OscillatorData^.SuperOscPhases[6]+(TempPhaseInc*(1+(Detune*soDetuneCoefficients[Oscillator^.SuperOscMode,6]))));
    Value:=Value*FeedBack;
    Value:=((frac((OscillatorData^.SuperOscPhases[0]+Value)-0.5)*2)*MixFactors[false])+
            ((frac((OscillatorData^.SuperOscPhases[1]+Value)-0.5)*2)*MixFactors[true])+
            ((frac((OscillatorData^.SuperOscPhases[2]+Value)-0.5)*2)*MixFactors[true])+
            ((frac((OscillatorData^.SuperOscPhases[3]+Value)-0.5)*2)*MixFactors[true])+
            ((frac((OscillatorData^.SuperOscPhases[4]+Value)-0.5)*2)*MixFactors[true])+
            ((frac((OscillatorData^.SuperOscPhases[5]+Value)-0.5)*2)*MixFactors[true])+
            ((frac((OscillatorData^.SuperOscPhases[6]+Value)-0.5)*2)*MixFactors[true]);
//  Value:=SuperOsc7SAW(Value*FeedBack,1);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else begin
   p1:=Oscillator^.SuperOscDetune*fCI255;
   p2:=Oscillator^.SuperOscMix*fCI255;
   for SampleCounter:=1 to Samples do begin
    WidthModulationEx:=Clip(WidthModulation*ColorBuffer^,0,1);
    Detune:=LinearToDetune(Clip(p1*SuperOscDetuneBuffer^,0,1));
    p3:=Clip(p2*SuperOscMixBuffer^,0,1);
    MixFactors[false]:=LinearToCenterOscAmp(p3);
    MixFactors[true]:=LinearToSideOscAmp(p3);
    TempPhaseInc:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    Value:=SuperOsc7SAW((Value*(FeedBack*FeedBackBuffer^)+SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempPhaseInc)),SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer));
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempPhaseInc+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempPhaseInc)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
    inc(SuperOscDetuneBuffer);
    inc(SuperOscMixBuffer);
   end;
  end;
 end else begin
  if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
     (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
     (SuperOscDetuneBuffer=Track^.F1D0Buffer) and (SuperOscMixBuffer=Track^.F1D0Buffer) and
     not (assigned(LastTarget) or Oscillator^.HardSync) then begin
   TempPhaseInc:=PhaseIncrement;
   WidthModulationEx:=WidthModulation;
   Detune:=LinearToDetune(Oscillator^.SuperOscDetune*fCI255);
   MixFactors[false]:=LinearToCenterOscAmp(Oscillator^.SuperOscMix*fCI255);
   MixFactors[true]:=LinearToSideOscAmp(Oscillator^.SuperOscMix*fCI255);
   for SampleCounter:=1 to Samples do begin
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    Value:=SuperOsc(Value*FeedBack,1);
    Phase:=frac(Phase+PhaseIncrement);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(HardSyncBuffer);
   end;
  end else begin
   p1:=Oscillator^.SuperOscDetune*fCI255;
   p2:=Oscillator^.SuperOscMix*fCI255;
   for SampleCounter:=1 to Samples do begin
    WidthModulationEx:=Clip(WidthModulation*ColorBuffer^,0,1);
    Detune:=LinearToDetune(Clip(p1*SuperOscDetuneBuffer^,0,1));
    p3:=Clip(p2*SuperOscMixBuffer^,0,1);
    MixFactors[false]:=LinearToCenterOscAmp(p3);
    MixFactors[true]:=LinearToSideOscAmp(p3);
    TempPhaseInc:=PhaseIncrement*PitchBuffer^;
    inc(PitchBuffer);
    plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
    Value:=SuperOsc((Value*(FeedBack*FeedBackBuffer^)+SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempPhaseInc)),SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer));
    inc(ColorBuffer);
    inc(FeedBackBuffer);
    OldPhase:=Phase;
    Phase:=frac(Phase+((TempPhaseInc+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempPhaseInc)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
    inc(HardSyncActiveBuffer);
    Buffer^.Left:=Value;
    Buffer^.Right:=Value;
    inc(Buffer);
    inc(LastBuffer);
    inc(HardSyncBuffer);
    inc(SuperOscDetuneBuffer);
    inc(SuperOscMixBuffer);
   end;
  end;
 end;
 OscillatorData^.Phase:=Phase;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormPluckedString(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    Phase,OldPhase,PhaseIncrement,FeedBack,Value,TempValue,ReflectionFactor,Pick,PickUp,InsertFactor,v:single;
    LastBufferAssignedPM,LastBufferAssignedFM,LastBufferAssignedPMM,
    LastBufferAssignedFMM,PMFMExtendedMode:boolean;
begin
 Value:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 InsertFactor:=Oscillator^.Color*fCI128;
 ReflectionFactor:=Oscillator^.PluckedStringReflection*fCI256;
 Pick:=Oscillator^.PluckedStringPick*fCI256;
 PickUp:=Oscillator^.PluckedStringPickUp*fCI256;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (PluckedStringReflectionBuffer=Track^.F1D0Buffer) and
    (PluckedStringPickBuffer=Track^.F1D0Buffer) and (PluckedStringPickUpBuffer=Track^.F1D0Buffer) and not
    (assigned(LastTarget) or Oscillator^.HardSync) then begin
  Buffer:=Target;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  OscillatorData^.PluckedString.ReflectionFactor:=ReflectionFactor;//0.5;//2*sin(pi*ReflectionFactor*(22050*Track^.InternalSampleRateFactor));
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   SynthPluckedStringNoteOn(Track,OscillatorData^.PluckedString,OscillatorData^.PhaseIncrement*Track^.InternalSampleRate,Pick,PickUp,OscillatorData^.NewNoteEx,Oscillator^.PluckedStringDelayLineMode);
   OscillatorData^.NewNoteEx:=false;
   OscillatorData^.NewFrequencyEx:=false;
   Value:=SynthPluckedStringProcess(Track,OscillatorData^.PluckedString,Oscillator^.PluckedStringDelayLineWidth,Value*FeedBack);
   Phase:=frac(Phase+PhaseIncrement);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(HardSyncBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end else begin
  PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
  LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
  LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
  LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
  LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
  Buffer:=Target;
  LastBuffer:=LastTarget;
  Phase:=OscillatorData^.Phase;
  PhaseIncrement:=OscillatorData^.PhaseIncrement;
  for SampleCounter:=1 to Samples do begin
   plongword(@Phase)^:=plongword(@Phase)^ and (-ord(not HardSyncBuffer^));
   TempValue:=PhaseIncrement*PitchBuffer^;
   OscillatorData^.PluckedString.ReflectionFactor:=Clip(ReflectionFactor*PluckedStringReflectionBuffer^,0,1);//2*sin(pi*ReflectionFactor*ColorBuffer^*(22050*Track^.InternalSampleRateFactor));
   v:=(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue))*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer);
   SynthPluckedStringNoteOn(Track,OscillatorData^.PluckedString,((OscillatorData^.PhaseIncrement*PitchBuffer^)+v)*Track^.InternalSampleRate,Clip(Pick*PluckedStringPickBuffer^,0,1),Clip(PickUp*PluckedStringPickUpBuffer^,0,1),OscillatorData^.NewNoteEx or HardSyncBuffer^,Oscillator^.PluckedStringDelayLineMode);
   OscillatorData^.NewNoteEx:=false;
   OscillatorData^.NewFrequencyEx:=false;
   if assigned(LastTarget) then begin
    v:=((LastBuffer^.Left+LastBuffer^.Right)*0.5)*InsertFactor*ColorBuffer^;
   end else begin
    v:=0;
   end;
   Value:=SynthPluckedStringProcess(Track,OscillatorData^.PluckedString,Oscillator^.PluckedStringDelayLineWidth,v+(Value*(FeedBack*FeedBackBuffer^)));
   OldPhase:=Phase;
   Phase:=frac(Phase+((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer)));
   HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (plongword(@Phase)^<plongword(@OldPhase)^);
   Buffer^.Left:=Value;
   Buffer^.Right:=Value;
   inc(Buffer);
   inc(ColorBuffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(FeedBackBuffer);
   inc(PitchBuffer);
   inc(HardSyncActiveBuffer);
   inc(PluckedStringReflectionBuffer);
   inc(PluckedStringPickBuffer);
   inc(PluckedStringPickUpBuffer);
  end;
  OscillatorData^.Phase:=Phase;
 end;
 OscillatorData^.Last:=Value;
end;

procedure SynthOscillatorGenerateWaveFormSample(Track:PSynthTrack;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;HardSyncBuffer:pboolean;Samples:longint);
{$ifdef BR808SAMPLES}
const Mask12=$3f800000;
      MaskMantissa=(1 shl 23)-1;
      Div32Bits:single=1/$100000000;
var SampleCounter:longint;
    Buffer,LastBuffer:PSynthBufferSample;
    FeedBack,ValueLeft,ValueRight,
    Frequency,TempValue:single;
    SampleSpeedFactor:double;
    LastBufferAssignedPM,LastBufferAssignedFM,
    LastBufferAssignedPMM,LastBufferAssignedFMM,OldSampleBackwards,
    PMFMExtendedMode:boolean;
    Sample,NewSample:PSynthSample;
    SampleIndex,OldSampleIndex,SampleIncrement:int64;
    SubArray:PSynthSINCSubArray;
    RealPos:longword;
 procedure ProcessLoop(const Loop:TSynthSampleLoop);
 var SmpLen,SmpLoopStart,SmpLoopEnd:int64;
 begin
  SmpLen:=int64(Sample^.Header.Samples) shl 32;
  SmpLoopStart:=int64(Loop.StartSample) shl 32;
  SmpLoopEnd:=int64(Loop.EndSample) shl 32;
  if Loop.Mode<>slNONE then begin
   if SampleIndex<SmpLoopStart then begin
    if OscillatorData^.SampleBackwards then begin
     if Loop.Mode=slPINGPONG then begin
      SampleIndex:=SmpLoopStart-(SmpLoopStart-SampleIndex);
      OscillatorData^.SampleBackwards:=false;
      if (SampleIndex<SmpLoopStart) or (SampleIndex>=((SmpLoopStart+SmpLoopEnd) div 2)) then begin
       SampleIndex:=SmpLoopStart;
      end;
     end else if Loop.Mode=slBACKWARD then begin
      SampleIndex:=SmpLen-(SmpLoopStart-SampleIndex);
      if SampleIndex>=SmpLoopEnd then begin
       SampleIndex:=SampleIndex+(SmpLoopStart-SmpLoopEnd);
       if SampleIndex<SmpLoopStart then begin
        SampleIndex:=SmpLoopStart;
       end;
      end;
     end else begin
      SampleIndex:=SmpLoopEnd-(SmpLoopStart-SampleIndex);
      OscillatorData^.SampleBackwards:=false;
      if SampleIndex>=SmpLoopEnd then begin
       SampleIndex:=SampleIndex+(SmpLoopStart-SmpLoopEnd);
       if SampleIndex<SmpLoopStart then begin
        SampleIndex:=SmpLoopStart;
       end;
      end;
     end;
    end else begin
     if SampleIndex<0 then begin
      SampleIndex:=0;
     end;
    end;
   end else if SampleIndex>=SmpLoopEnd then begin
    if Loop.Mode=slBACKWARD then begin
     OscillatorData^.SampleBackwards:=true;
    end else if Loop.Mode=slPINGPONG then begin
     SampleIndex:=SmpLoopEnd-(SampleIndex-SmpLoopEnd);
     OscillatorData^.SampleBackwards:=true;
     if (SampleIndex<SmpLoopStart) or (SampleIndex>=((SmpLoopStart+SmpLoopEnd) div 2)) then begin
      SampleIndex:=SmpLoopStart;
     end;
    end else begin
     SampleIndex:=SampleIndex+(SmpLoopStart-SmpLoopEnd);
     if SampleIndex<SmpLoopStart then begin
      SampleIndex:=SmpLoopStart;
     end;
     OscillatorData^.SampleBackwards:=false;
    end;
   end;
  end;
 end;
{$endif}
begin
{$ifdef BR808SAMPLES}
 Buffer:=Target;
 ValueLeft:=OscillatorData^.Last;
 ValueRight:=OscillatorData^.Last;
 FeedBack:=OscillatorData^.FeedBack;
 Sample:=OscillatorData^.Sample;
 if assigned(ColorBuffer) and (ColorBuffer<>Track^.F1D0Buffer) then begin
  NewSample:=@Track^.Samples[OscillatorData^.Patch,SoftTRUNC((Oscillator^.Color+$40)*ColorBuffer^) and $7f];
 end else begin
  NewSample:=@Track^.Samples[OscillatorData^.Patch,(Oscillator^.Color+$40) and $7f];
 end;
 if Sample<>NewSample then begin
  Sample:=NewSample;
  if Sample^.Header.RandomStartPosition then begin
   OscillatorData^.SampleIndex:=round64((abs(RandomFloat(OscillatorData^.Seed))*(Sample^.Header.Samples-1))*PositionFactor);
  end else begin
   OscillatorData^.SampleIndex:=0;
  end;
 end;
 PMFMExtendedMode:=Oscillator^.PMFMExtendedMode;
 LastBuffer:=LastTarget;
 LastBufferAssignedPM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseModulation);
 LastBufferAssignedFM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyModulation);
 LastBufferAssignedPMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stPhaseMulModulation);
 LastBufferAssignedFMM:=assigned(LastTarget) and (Oscillator^.SynthesisType=stFrequencyMulModulation);
 Frequency:=440*power(2,((Sample^.Header.Note-69)-(Sample^.Header.FineTune/$100000000))*fCI12);
 SampleSpeedFactor:=Sample^.Header.SampleRate/Frequency;
 if (FeedBackBuffer=Track^.F1D0Buffer) and (PitchBuffer=Track^.F1D0Buffer) and
    (HardSyncActiveBuffer=Track^.F1D0Buffer) and (ColorBuffer=Track^.F1D0Buffer) and
    (FeedBack=0) and not (assigned(LastTarget) or Oscillator^.HardSync) then begin
  if assigned(Sample^.Data) and assigned(Sample^.WorkData) and (Sample^.Header.Samples>0) and OscillatorData^.SampleActive then begin
   SampleIndex:=OscillatorData^.SampleIndex;
   if (Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff then begin
    ProcessLoop(Sample^.Header.SustainLoop);
   end else if Sample^.Header.Loop.Mode<>slNONE then begin
    ProcessLoop(Sample^.Header.Loop);
   end;
   OscillatorData^.SampleActive:=longword(SampleIndex shr 32)<longword(Sample^.Header.Samples);
   if OscillatorData^.SampleActive then begin
    if (Sample^.Header.Loop.Mode<>slNONE) or ((Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff) then begin
     if Sample^.Header.Channels=2 then begin
      while (Samples>0) and OscillatorData^.SampleActive do begin
       SubArray:=@Track^.SINCTable[(longword(SampleIndex and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
       RealPos:=((SampleIndex shr PositionShift) shl 1)+SampleFixUp;
       Buffer^.Left:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                      SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-12]+
                      SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-10]+
                      SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-8]+
                      SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-6]+
                      SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-4]+
                      SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-2]+
                      SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                      SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+2]+
                      SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+4]+
                      SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+6]+
                      SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+8]+
                      SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+10]+
                      SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+12]+
                      SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+14]+
                      SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+16]);
       Buffer^.Right:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                       SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-11]+
                       SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-9]+
                       SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-7]+
                       SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-5]+
                       SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-3]+
                       SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                       SubArray^[7]*psingles(Sample^.WorkData)^[RealPos+1]+
                       SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+3]+
                       SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+5]+
                       SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+7]+
                       SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+9]+
                       SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+11]+
                       SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+13]+
                       SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+15]+
                       SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+17]);
       inc(Buffer);
       SampleIncrement:=ROUND64((OscillatorData^.PhaseIncrement*SampleSpeedFactor)*I32);
       if OscillatorData^.SampleBackwards then begin
        dec(SampleIndex,SampleIncrement);
       end else begin
        inc(SampleIndex,SampleIncrement);
       end;
       if (Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff then begin
        ProcessLoop(Sample^.Header.SustainLoop);
       end else if Sample^.Header.Loop.Mode<>slNONE then begin
        ProcessLoop(Sample^.Header.Loop);
       end;
       OscillatorData^.SampleActive:=longword(SampleIndex shr 32)<longword(Sample^.Header.Samples);
       dec(Samples);
      end;
     end else begin
      while (Samples>0) and OscillatorData^.SampleActive do begin
       SubArray:=@Track^.SINCTable[(longword(SampleIndex and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
       RealPos:=(SampleIndex shr PositionShift)+SampleFixUp;
       ValueLeft:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-7]+
                   SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-6]+
                   SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-5]+
                   SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-4]+
                   SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-3]+
                   SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-2]+
                   SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                   SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                   SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+1]+
                   SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+2]+
                   SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+3]+
                   SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+4]+
                   SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+5]+
                   SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+6]+
                   SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+7]+
                   SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+8]);
       Buffer^.Left:=ValueLeft;
       Buffer^.Right:=ValueLeft;
       inc(Buffer);
       SampleIncrement:=ROUND64((OscillatorData^.PhaseIncrement*SampleSpeedFactor)*I32);
       if OscillatorData^.SampleBackwards then begin
        dec(SampleIndex,SampleIncrement);
       end else begin
        inc(SampleIndex,SampleIncrement);
       end;
       if (Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff then begin
        ProcessLoop(Sample^.Header.SustainLoop);
       end else if Sample^.Header.Loop.Mode<>slNONE then begin
        ProcessLoop(Sample^.Header.Loop);
       end;
       OscillatorData^.SampleActive:=longword(SampleIndex shr 32)<longword(Sample^.Header.Samples);
       dec(Samples);
      end;
     end;
    end else begin
     if Sample^.Header.Channels=2 then begin
      while (Samples>0) and OscillatorData^.SampleActive do begin
       SubArray:=@Track^.SINCTable[(longword(SampleIndex and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
       RealPos:=((SampleIndex shr PositionShift) shl 1)+SampleFixUp;
       Buffer^.Left:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                      SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-12]+
                      SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-10]+
                      SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-8]+
                      SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-6]+
                      SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-4]+
                      SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-2]+
                      SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                      SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+2]+
                      SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+4]+
                      SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+6]+
                      SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+8]+
                      SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+10]+
                      SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+12]+
                      SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+14]+
                      SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+16]);
       Buffer^.Right:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                       SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-11]+
                       SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-9]+
                       SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-7]+
                       SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-5]+
                       SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-3]+
                       SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                       SubArray^[7]*psingles(Sample^.WorkData)^[RealPos+1]+
                       SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+3]+
                       SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+5]+
                       SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+7]+
                       SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+9]+
                       SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+11]+
                       SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+13]+
                       SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+15]+
                       SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+17]);
       inc(Buffer);
       SampleIncrement:=ROUND64((OscillatorData^.PhaseIncrement*SampleSpeedFactor)*I32);
       if OscillatorData^.SampleBackwards then begin
        dec(SampleIndex,SampleIncrement);
       end else begin
        inc(SampleIndex,SampleIncrement);
       end;
       OscillatorData^.SampleActive:=longword(SampleIndex shr 32)<longword(Sample^.Header.Samples);
       dec(Samples);
      end;
     end else begin
      while (Samples>0) and OscillatorData^.SampleActive do begin
       SubArray:=@Track^.SINCTable[(longword(SampleIndex and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
       RealPos:=(SampleIndex shr PositionShift)+SampleFixUp;
       ValueLeft:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-7]+
                   SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-6]+
                   SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-5]+
                   SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-4]+
                   SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-3]+
                   SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-2]+
                   SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                   SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                   SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+1]+
                   SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+2]+
                   SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+3]+
                   SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+4]+
                   SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+5]+
                   SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+6]+
                   SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+7]+
                   SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+8]);
       Buffer^.Left:=ValueLeft;
       Buffer^.Right:=ValueLeft;
       inc(Buffer);
       SampleIncrement:=ROUND64((OscillatorData^.PhaseIncrement*SampleSpeedFactor)*I32);
       if OscillatorData^.SampleBackwards then begin
        dec(SampleIndex,SampleIncrement);
       end else begin
        inc(SampleIndex,SampleIncrement);
       end;
       OscillatorData^.SampleActive:=longword(SampleIndex shr 32)<longword(Sample^.Header.Samples);
       dec(Samples);
      end;
     end;
    end;
    OscillatorData^.SampleIndex:=SampleIndex;
   end;
  end;
  while Samples>0 do begin
   Buffer^.Left:=0;
   Buffer^.Right:=0;
   inc(Buffer);
   dec(Samples);
  end;
 end else begin
  for SampleCounter:=1 to Samples do begin
   if assigned(ColorBuffer) then begin
    NewSample:=@Track^.Samples[OscillatorData^.Patch,SoftTRUNC((Oscillator^.Color+$40)*ColorBuffer^) and $7f];
    if NewSample<>Sample then begin
     Sample:=NewSample;
     if Sample^.Header.RandomStartPosition then begin
      OscillatorData^.SampleIndex:=round64((abs(RandomFloat(OscillatorData^.Seed))*(Sample^.Header.Samples-1))*PositionFactor);
     end else begin
      OscillatorData^.SampleIndex:=0;
     end;
     Frequency:=440*power(2,((Sample^.Header.Note-69)-(Sample^.Header.FineTune/$100000000))*fCI12);
     SampleSpeedFactor:=Sample^.Header.SampleRate/Frequency;
    end;
    inc(ColorBuffer);
   end;
   if assigned(Sample^.Data) and assigned(Sample^.WorkData) and (Sample^.Header.Samples>0) and OscillatorData^.SampleActive then begin
    TempValue:=OscillatorData^.PhaseIncrement*PitchBuffer^;
    SampleIncrement:=ROUND64(((((TempValue+(SynthLastBufferUseFuncs[LastBufferAssignedFM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue))))*SynthLastBufferMulUseFuncs[LastBufferAssignedFMM](LastBuffer))*SampleSpeedFactor)*I32);
    if HardSyncBuffer^ then begin
     OscillatorData^.SampleIndex:=0;
    end;
    if LastBufferAssignedPMM then begin
     SampleIndex:=OscillatorData^.SampleIndex-(int64(Sample^.Header.PhaseSamples) shl 32)+ROUND64((((((FeedBack*FeedBackBuffer^*((ValueLeft+ValueRight)*0.5))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue))))+1)*SynthLastBufferMulUseFuncs[LastBufferAssignedPMM](LastBuffer))*(int64(Sample^.Header.PhaseSamples) shl 32));
    end else begin
     SampleIndex:=OscillatorData^.SampleIndex+ROUND64(((((FeedBack*FeedBackBuffer^*((ValueLeft+ValueRight)*0.5))+(SynthLastBufferUseFuncs[LastBufferAssignedPM](LastBuffer)*SynthPMFMExtendedModeFuncs[PMFMExtendedMode](TempValue)))))*(int64(Sample^.Header.PhaseSamples) shl 32));
    end;
    inc(FeedBackBuffer);
    OldSampleBackwards:=OscillatorData^.SampleBackwards;
    if (Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff then begin
     ProcessLoop(Sample^.Header.SustainLoop);
    end else if Sample^.Header.Loop.Mode<>slNONE then begin
     ProcessLoop(Sample^.Header.Loop);
    end;
    OscillatorData^.SampleBackwards:=OldSampleBackwards;
    if SampleIndex<0 then begin
     SampleIndex:=0;
     ValueLeft:=0;
     ValueRight:=0;
     OscillatorData^.SampleActive:=false;
    end else if (SampleIndex shr 32)>=Sample^.Header.Samples then begin
     SampleIndex:=(Sample^.Header.Samples-1) shl 32;
     ValueLeft:=0;
     ValueRight:=0;
     OscillatorData^.SampleActive:=false;
    end else begin
     SubArray:=@Track^.SINCTable[(longword(SampleIndex and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
     if Sample^.Header.Channels=2 then begin
      RealPos:=((SampleIndex shr PositionShift) shl 1)+SampleFixUp;
      ValueLeft:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                  SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-12]+
                  SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-10]+
                  SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-8]+
                  SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-6]+
                  SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-4]+
                  SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-2]+
                  SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                  SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+2]+
                  SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+4]+
                  SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+6]+
                  SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+8]+
                  SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+10]+
                  SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+12]+
                  SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+14]+
                  SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+16]);
      ValueRight:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-14]+
                  SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-11]+
                  SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-9]+
                  SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-7]+
                  SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-5]+
                  SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-3]+
                  SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                  SubArray^[7]*psingles(Sample^.WorkData)^[RealPos+1]+
                  SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+3]+
                  SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+5]+
                  SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+7]+
                  SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+9]+
                  SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+11]+
                  SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+13]+
                  SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+15]+
                  SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+17]);
     end else begin
      RealPos:=(SampleIndex shr PositionShift)+SampleFixUp;
      ValueLeft:=(SubArray^[0]*psingles(Sample^.WorkData)^[RealPos-7]+
                  SubArray^[1]*psingles(Sample^.WorkData)^[RealPos-6]+
                  SubArray^[2]*psingles(Sample^.WorkData)^[RealPos-5]+
                  SubArray^[3]*psingles(Sample^.WorkData)^[RealPos-4]+
                  SubArray^[4]*psingles(Sample^.WorkData)^[RealPos-3]+
                  SubArray^[5]*psingles(Sample^.WorkData)^[RealPos-2]+
                  SubArray^[6]*psingles(Sample^.WorkData)^[RealPos-1]+
                  SubArray^[7]*psingles(Sample^.WorkData)^[RealPos]+
                  SubArray^[8]*psingles(Sample^.WorkData)^[RealPos+1]+
                  SubArray^[9]*psingles(Sample^.WorkData)^[RealPos+2]+
                  SubArray^[10]*psingles(Sample^.WorkData)^[RealPos+3]+
                  SubArray^[11]*psingles(Sample^.WorkData)^[RealPos+4]+
                  SubArray^[12]*psingles(Sample^.WorkData)^[RealPos+5]+
                  SubArray^[13]*psingles(Sample^.WorkData)^[RealPos+6]+
                  SubArray^[14]*psingles(Sample^.WorkData)^[RealPos+7]+
                  SubArray^[15]*psingles(Sample^.WorkData)^[RealPos+8]);
      ValueRight:=ValueLeft;
     end;
    end;

    SampleIndex:=OscillatorData^.SampleIndex;
    OldSampleIndex:=SampleIndex;
    if OscillatorData^.SampleBackwards then begin
     dec(SampleIndex,SampleIncrement);
    end else begin
     inc(SampleIndex,SampleIncrement);
    end;
    if (Sample^.Header.SustainLoop.Mode<>slNONE) and not OscillatorData^.KeyOff then begin
     ProcessLoop(Sample^.Header.SustainLoop);
    end else if Sample^.Header.Loop.Mode<>slNONE then begin
     ProcessLoop(Sample^.Header.Loop);
    end;
    HardSyncBuffer^:=(Oscillator^.HardSync and (plongword(HardSyncActiveBuffer)^<>0)) and (((SampleIndex<OldSampleIndex) and not OscillatorData^.SampleBackwards) or ((SampleIndex>OldSampleIndex) and OscillatorData^.SampleBackwards));
    inc(HardSyncActiveBuffer);
    OscillatorData^.SampleIndex:=SampleIndex;

   end else begin
    ValueLeft:=0;
    ValueRight:=0;
   end;

   Buffer^.Left:=ValueLeft;
   Buffer^.Right:=ValueRight;
   inc(Buffer);
   inc(LastBuffer);
   inc(HardSyncBuffer);
   inc(PitchBuffer);
  end;
 end;
 OscillatorData^.Last:=(ValueLeft+ValueRight)*0.5;
 OscillatorData^.Sample:=Sample;
{$endif}
end;

{

      wfNONE=0;
      wfSINE=1;
      wfTRIANGLE=2;
      wfPARABOLA=3;
      wfPULSE=4;
      wfSAWUP=5;
      wfSAWDOWN=6;
      wfSAWTRI=7;
      wfWHITENOISE=8;
      wfPINKNOISE=9;
      wfGRAYNOISE=10;
      wfBROWNNOISE=11;
      wfBLUENOISE=12;
      wfCLIPNOISE=13;
      wfGAUSSIANNOISE=14;
      wfBLTRI=15;
      wfBLPARABOLA=16;
      wfBLPULSE=17;
      wfBLSAWUP=18;
      wfBLSAWDOWN=19;
      wfPLUCKEDSTRING=20;
      wfSUPEROSC=21;
      wfSAMPLE=22;

}
const SynthOscillatorGenerateWaveFormProcs:array[wfNONE..wfSAMPLE] of TSynthOscillatorGenerateWaveFormProc=
       (SynthOscillatorGenerateWaveFormNone,
        SynthOscillatorGenerateWaveFormSine,
        SynthOscillatorGenerateWaveFormTriangle,
        SynthOscillatorGenerateWaveFormParabola,
        SynthOscillatorGenerateWaveFormPulse,
        SynthOscillatorGenerateWaveFormSawUp,
        SynthOscillatorGenerateWaveFormSawDown,
        SynthOscillatorGenerateWaveFormSawtoothTriangle,
        SynthOscillatorGenerateWaveFormWhiteNoise,
        SynthOscillatorGenerateWaveFormPinkNoise,
        SynthOscillatorGenerateWaveFormGrayNoise,
        SynthOscillatorGenerateWaveFormBrownNoise,
        SynthOscillatorGenerateWaveFormBlueNoise,
        SynthOscillatorGenerateWaveFormClipNoise,
        SynthOscillatorGenerateWaveFormGaussianNoise,
        SynthOscillatorGenerateWaveFormBandlimitedTriangle,
        SynthOscillatorGenerateWaveFormBandlimitedParabola,
        SynthOscillatorGenerateWaveFormBandlimitedPulse,
        SynthOscillatorGenerateWaveFormBandlimitedSawUp,
        SynthOscillatorGenerateWaveFormBandlimitedSawDown,
        SynthOscillatorGenerateWaveFormPluckedString,
        SynthOscillatorGenerateWaveFormSuperOsc,
        SynthOscillatorGenerateWaveFormSample);

type TSynthProcessOscillatorModulation=procedure(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}

procedure SynthProcessOscillatorNone(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
begin
end;

{$ifdef UseSSE}
procedure SynthProcessOscillatorRingModulationSSE(Target,LastTarget:PSynthBufferSample;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        mulps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        mulps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessOscillatorRingModulation(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^.Left:=Target^.Left*LastTarget^.Left;
  Target^.Right:=Target^.Right*LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left*LastTarget^.Left;
  Target^.Right:=Target^.Right*LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left*LastTarget^.Left;
  Target^.Right:=Target^.Right*LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left*LastTarget^.Left;
  Target^.Right:=Target^.Right*LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^.Left:=Target^.Left*LastTarget^.Left;
  Target^.Right:=Target^.Right*LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessOscillatorAmplitudeModulationSSE(Target,LastTarget:PSynthBufferSample;Samples:longint); assembler; register;
const ANDMask:array[0..3] of longword=($7fffffff,$7fffffff,$7fffffff,$7fffffff);
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  add ecx,ecx

  movups xmm5,[ANDMask]

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        andps xmm0,xmm5
        movaps xmm4,[edx]
        mulps xmm0,xmm4

        movaps xmm1,[eax+16]
        andps xmm1,xmm5
        movaps xmm4,[edx+16]
        mulps xmm1,xmm4

        movaps xmm2,[eax+32]
        andps xmm2,xmm5
        movaps xmm4,[edx+32]
        mulps xmm2,xmm4

        movaps xmm3,[eax+48]
        andps xmm3,xmm5
        movaps xmm4,[edx+48]
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        andps xmm0,xmm5
        movaps xmm4,[edx]
        mulps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     andps xmm0,xmm5
     movups xmm4,[edx]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     andps xmm1,xmm5
     movups xmm4,[edx+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     andps xmm2,xmm5
     movups xmm4,[edx+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     andps xmm3,xmm5
     movups xmm4,[edx+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     andps xmm0,xmm5
     movups xmm4,[edx]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   xorps xmm0,xmm0
   @SmallInnerLoop:
    movss xmm0,dword ptr [eax]
    andps xmm0,xmm5
    mulss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:
end;
{$endif}

procedure SynthProcessOscillatorAmplitudeModulation(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^.Left:=LastTarget^.Left*abs(Target^.Left);
  Target^.Right:=LastTarget^.Right*abs(Target^.Right);
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left*abs(Target^.Left);
  Target^.Right:=LastTarget^.Right*abs(Target^.Right);
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left*abs(Target^.Left);
  Target^.Right:=LastTarget^.Right*abs(Target^.Right);
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left*abs(Target^.Left);
  Target^.Right:=LastTarget^.Right*abs(Target^.Right);
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^.Left:=LastTarget^.Left*abs(Target^.Left);
  Target^.Right:=LastTarget^.Right*abs(Target^.Right);
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessOscillatorAdditiveSSE(Target,LastTarget:PSynthBufferSample;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        addps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        addps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        addps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     addps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     addps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     addps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    addss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessOscillatorAdditive(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^.Left:=Target^.Left+LastTarget^.Left;
  Target^.Right:=Target^.Right+LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left+LastTarget^.Left;
  Target^.Right:=Target^.Right+LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left+LastTarget^.Left;
  Target^.Right:=Target^.Right+LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=Target^.Left+LastTarget^.Left;
  Target^.Right:=Target^.Right+LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^.Left:=Target^.Left+LastTarget^.Left;
  Target^.Right:=Target^.Right+LastTarget^.Right;
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessOscillatorSubtractiveSSE(Target,LastTarget:PSynthBufferSample;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  add ecx,ecx

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[edx]
        movaps xmm4,[eax]
        subps xmm0,xmm4

        movaps xmm1,[edx+16]
        movaps xmm4,[eax+16]
        subps xmm1,xmm4

        movaps xmm2,[edx+32]
        movaps xmm4,[eax+32]
        subps xmm2,xmm4

        movaps xmm3,[edx+48]
        movaps xmm4,[eax+48]
        subps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[edx]
        movaps xmm4,[eax]
        subps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[edx]
     movups xmm4,[eax]
     subps xmm0,xmm4

     movups xmm1,[edx+16]
     movups xmm4,[eax+16]
     subps xmm1,xmm4

     movups xmm2,[edx+32]
     movups xmm4,[eax+32]
     subps xmm2,xmm4

     movups xmm3,[edx+48]
     movups xmm4,[eax+48]
     subps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[edx]
     movups xmm4,[eax]
     subps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [edx]
    subss xmm0,dword ptr [eax]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessOscillatorSubtractive(Target,LastTarget:PSynthBufferSample;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^.Left:=LastTarget^.Left-Target^.Left;
  Target^.Right:=LastTarget^.Right-Target^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left-Target^.Left;
  Target^.Right:=LastTarget^.Right-Target^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left-Target^.Left;
  Target^.Right:=LastTarget^.Right-Target^.Right;
  inc(Target);
  inc(LastTarget);
  Target^.Left:=LastTarget^.Left-Target^.Left;
  Target^.Right:=LastTarget^.Right-Target^.Right;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^.Left:=LastTarget^.Left-Target^.Left;
  Target^.Right:=LastTarget^.Right-Target^.Right;
  inc(Target);
  inc(LastTarget);
 end;
end;

const SynthProcessOscillatorModulation:array[stNone..stFrequencyMulModulation] of TSynthProcessOscillatorModulation=(SynthProcessOscillatorNone,SynthProcessOscillatorNone,SynthProcessOscillatorRingModulation,SynthProcessOscillatorAmplitudeModulation,SynthProcessOscillatorAdditive,SynthProcessOscillatorSubtractive,SynthProcessOscillatorNone,SynthProcessOscillatorNone,SynthProcessOscillatorNone);
{$ifdef UseSSE}
      SynthProcessOscillatorModulationSSE:array[stNone..stFrequencyMulModulation] of TSynthProcessOscillatorModulation=(SynthProcessOscillatorNone,SynthProcessOscillatorNone,SynthProcessOscillatorRingModulationSSE,SynthProcessOscillatorAmplitudeModulationSSE,SynthProcessOscillatorAdditiveSSE,SynthProcessOscillatorSubtractiveSSE,SynthProcessOscillatorNone,SynthProcessOscillatorNone,SynthProcessOscillatorNone);
{$endif}

procedure SynthProcessRamping(Track:PSynthTrack;var Ramping:TSynthRamping;DestBuf,DestSqrBuf:PSynthFloatValue;Samples,RampingSamples,RampingMode:longint;NewValue:single;CanHaveFullBuffer:longbool);
var CanBufferAlreadyFill:boolean;
begin         
 Ramping.HasBufferAlreadyFilled:=Ramping.HasBufferAlreadyFilled and Ramping.Active;
 CanBufferAlreadyFill:=true;
 if (not Ramping.Active) or (abs(Ramping.Current-NewValue)<1E-18) or (RampingSamples=0) then begin
  plongword(@Ramping.Current)^:=plongword(@NewValue)^;
  plongword(@Ramping.Dest)^:=plongword(@NewValue)^;
  plongword(@Ramping.Step)^:=0;
  Ramping.Remain:=0;
 end else if plongword(@Ramping.Dest)^<>plongword(@NewValue)^ then begin
  plongword(@Ramping.Dest)^:=plongword(@NewValue)^;
  Ramping.Remain:=RampingSamples;
  Ramping.Factor:=1-exp(-(1/Ramping.Remain));
  Ramping.Step:=(Ramping.Dest-Ramping.Current)/Ramping.Remain;
  Ramping.HasBufferAlreadyFilled:=false;
  CanBufferAlreadyFill:=false;
 end;
 Ramping.Active:=true;
 if (Ramping.Remain>0) and (Samples>0) then begin
  Ramping.HasBufferAlreadyFilled:=false;
  CanBufferAlreadyFill:=false;
  SynthKillDenormal(Ramping.Step);
  SynthKillDenormal(Ramping.Current);
  case RampingMode of
   rmEXP:begin
    if abs(Ramping.Current-Ramping.Dest)<1e-6 then begin
     plongword(@Ramping.Current)^:=plongword(@Ramping.Dest)^;
     Ramping.Remain:=0;
    end else begin
     if assigned(DestSqrBuf) then begin
      while Samples>0 do begin
       Ramping.Current:=Ramping.Current+((Ramping.Dest-Ramping.Current)*Ramping.Factor);
       DestBuf^:=Ramping.Current;
       DestSqrBuf^:=sqr(Ramping.Current);
       inc(DestBuf);
       inc(DestSqrBuf);
       dec(Samples);
      end;
     end else begin
      while Samples>0 do begin
       Ramping.Current:=Ramping.Current+((Ramping.Dest-Ramping.Current)*Ramping.Factor);
       DestBuf^:=Ramping.Current;
       inc(DestBuf);
       dec(Samples);
      end;
     end;
     Samples:=0;
    end;
   end;
   else begin
    if assigned(DestSqrBuf) then begin
     while (Ramping.Remain>0) and (Samples>0) do begin
      Ramping.Current:=Ramping.Current+Ramping.Step;
      DestBuf^:=Ramping.Current;
      DestSqrBuf^:=sqr(Ramping.Current);
      inc(DestBuf);
      inc(DestSqrBuf);
      dec(Ramping.Remain);
      dec(Samples);
     end;
    end else begin
     while (Ramping.Remain>0) and (Samples>0) do begin
      Ramping.Current:=Ramping.Current+Ramping.Step;
      DestBuf^:=Ramping.Current;
      inc(DestBuf);
      dec(Ramping.Remain);
      dec(Samples);
     end;
    end;
   end;
  end;
 end;
 if Samples>0 then begin
  if CanBufferAlreadyFill and CanHaveFullBuffer then begin
   if (not (Ramping.HasBufferAlreadyFilled and (plongword(@Ramping.BufferAlreadyFilledValue)^=plongword(@Ramping.Dest)^))) or (Ramping.BufferAlreadyFilledSamples<Samples) then begin
    if assigned(DestSqrBuf) then begin
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthFillFloatSSE(DestSqrBuf,sqr(Ramping.Dest),Samples);
     end else{$endif} begin
      SynthFillFloat(DestSqrBuf,sqr(Ramping.Dest),Samples);
     end;
    end;
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthFillFloatSSE(DestBuf,Ramping.Dest,Samples);
    end else{$endif} begin
     SynthFillFloat(DestBuf,Ramping.Dest,Samples);
    end;
    plongword(@Ramping.BufferAlreadyFilledValue)^:=plongword(@Ramping.Dest)^;
    Ramping.BufferAlreadyFilledSamples:=Samples;
    Ramping.HasBufferAlreadyFilled:=true;
   end;
  end else begin
   Ramping.HasBufferAlreadyFilled:=false;
   if assigned(DestSqrBuf) then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthFillFloatSSE(DestSqrBuf,sqr(Ramping.Dest),Samples);
    end else{$endif} begin
     SynthFillFloat(DestSqrBuf,sqr(Ramping.Dest),Samples);
    end;
   end;
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthFillFloatSSE(DestBuf,Ramping.Dest,Samples);
   end else{$endif} begin
    SynthFillFloat(DestBuf,Ramping.Dest,Samples);
   end;
  end;
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModMulSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        mulps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        mulps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        mulps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessModMul(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^*LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^*LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModMulAbsSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
const ANDMask:array[0..3] of longword=($7fffffff,$7fffffff,$7fffffff,$7fffffff);
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  movups xmm5,[ANDMask]

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        andps xmm4,xmm5
        mulps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        andps xmm4,xmm5
        mulps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        andps xmm4,xmm5
        mulps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        andps xmm4,xmm5
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        andps xmm4,xmm5
        mulps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     andps xmm4,xmm5
     mulps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     andps xmm4,xmm5
     mulps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     andps xmm4,xmm5
     mulps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     andps xmm4,xmm5
     mulps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     andps xmm4,xmm5
     mulps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   xorps xmm4,xmm4
   @SmallInnerLoop:
    movss xmm0,dword ptr [eax]
    movss xmm4,dword ptr [edx]
    andps xmm4,xmm5
    mulss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:
end;
{$endif}

procedure SynthProcessModMulAbs(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^*abs(LastTarget^);
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*abs(LastTarget^);
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*abs(LastTarget^);
  inc(Target);
  inc(LastTarget);
  Target^:=Target^*abs(LastTarget^);
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^*abs(LastTarget^);
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModAddSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        addps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        addps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        addps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        addps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     addps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     addps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     addps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     addps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    addss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessModAdd(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^+LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^+LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^+LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^+LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^+LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModSubSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        subps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        subps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        subps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        subps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        subps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     subps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     subps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     subps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     subps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     subps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    subss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessModSub(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^-LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^-LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^-LastTarget^;
  inc(Target);
  inc(LastTarget);
  Target^:=Target^-LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^-LastTarget^;
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModDivSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        divps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        divps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        divps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        mulps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        divps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     divps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     divps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     divps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     divps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     divps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    divss xmm0,dword ptr [edx]
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop

 @Done:
end;
{$endif}

procedure SynthProcessModDiv(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^/LastTarget^;
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/LastTarget^;
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/LastTarget^;
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/LastTarget^;
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^/LastTarget^;
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModDivAbsSSE(Target,LastTarget:PSynthFloatValue;Samples:longint); assembler; register;
const ANDMask:array[0..3] of longword=($7fffffff,$7fffffff,$7fffffff,$7fffffff);
asm
 mov eax,dword ptr Target
 mov edx,dword ptr LastTarget

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  movups xmm5,[ANDMask]

  test eax,15
  jnz @Unaligned
   test edx,15
   jnz @Unaligned
    @Aligned:
     push ecx
      shr ecx,4
      jz @SkipHurgeLoopAligned
       @HurgeLoopAligned:

        movaps xmm0,[eax]
        movaps xmm4,[edx]
        andps xmm4,xmm5
        divps xmm0,xmm4

        movaps xmm1,[eax+16]
        movaps xmm4,[edx+16]
        andps xmm4,xmm5
        divps xmm1,xmm4

        movaps xmm2,[eax+32]
        movaps xmm4,[edx+32]
        andps xmm4,xmm5
        divps xmm2,xmm4

        movaps xmm3,[eax+48]
        movaps xmm4,[edx+48]
        andps xmm4,xmm5
        divps xmm3,xmm4

        movaps [eax],xmm0
        movaps [eax+16],xmm1
        movaps [eax+32],xmm2
        movaps [eax+48],xmm3

        add eax,64
        add edx,64
        dec ecx
       jnz @HurgeLoopAligned
      @SkipHurgeLoopAligned:
     pop ecx
     and ecx,15
     jz @Done

     push ecx
      shr ecx,2
      jz @SkipLargeLoopAligned
       @LargeLoopAligned:
        movaps xmm0,[eax]
        movaps xmm4,[edx]
        andps xmm4,xmm5
        divps xmm0,xmm4
        movaps [eax],xmm0
        add eax,16
        add edx,16
        dec ecx
       jnz @LargeLoopAligned
      @SkipLargeLoopAligned:
     pop ecx
     and ecx,3
     jz @Done
     jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     movups xmm4,[edx]
     andps xmm4,xmm5
     divps xmm0,xmm4

     movups xmm1,[eax+16]
     movups xmm4,[edx+16]
     andps xmm4,xmm5
     divps xmm1,xmm4

     movups xmm2,[eax+32]
     movups xmm4,[edx+32]
     andps xmm4,xmm5
     divps xmm2,xmm4

     movups xmm3,[eax+48]
     movups xmm4,[edx+48]
     andps xmm4,xmm5
     divps xmm3,xmm4

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     movups xmm4,[edx]
     andps xmm4,xmm5
     divps xmm0,xmm4
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
   xorps xmm4,xmm4
   @SmallInnerLoop:
    movss xmm0,dword ptr [eax]
    movss xmm4,dword ptr [edx]
    andps xmm4,xmm5
    divss xmm0,xmm4
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallInnerLoop

 @Done:
end;
{$endif}

procedure SynthProcessModDivAbs(Target,LastTarget:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=Target^/abs(LastTarget^);
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/abs(LastTarget^);
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/abs(LastTarget^);
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
  Target^:=Target^/abs(LastTarget^);
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=Target^/abs(LastTarget^);
  longword(pointer(Target)^):=longword(pointer(Target)^) and longword($ffffffff+longword(((((longword(pointer(Target)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(LastTarget);
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessModSqrSSE(Target:PSynthFloatValue;Samples:longint); assembler; register;
asm
 mov eax,dword ptr Target

 mov ecx,dword ptr Samples
 test ecx,ecx
 jz @Done

  test eax,15
  jnz @Unaligned
   @Aligned:
    push ecx
     shr ecx,4
     jz @SkipHurgeLoopAligned
      @HurgeLoopAligned:

       movaps xmm0,[eax]
       mulps xmm0,xmm0

       movaps xmm1,[eax+16]
       mulps xmm1,xmm1

       movaps xmm2,[eax+32]
       mulps xmm2,xmm2

       movaps xmm3,[eax+48]
       mulps xmm3,xmm3

       movaps [eax],xmm0
       movaps [eax+16],xmm1
       movaps [eax+32],xmm2
       movaps [eax+48],xmm3

       add eax,64
       add edx,64
       dec ecx
      jnz @HurgeLoopAligned
     @SkipHurgeLoopAligned:
    pop ecx
    and ecx,15
    jz @Done

    push ecx
     shr ecx,2
     jz @SkipLargeLoopAligned
      @LargeLoopAligned:
       movaps xmm0,[eax]
       mulps xmm0,xmm0
       movaps [eax],xmm0
       add eax,16
       add edx,16
       dec ecx
      jnz @LargeLoopAligned
     @SkipLargeLoopAligned:
    pop ecx
    and ecx,3
    jz @Done
    jmp @SmallLoop

  @Unaligned:

  push ecx
   shr ecx,4
   jz @SkipHurgeLoop
    @HurgeLoop:

     movups xmm0,[eax]
     mulps xmm0,xmm0

     movups xmm1,[eax+16]
     mulps xmm1,xmm1

     movups xmm2,[eax+32]
     mulps xmm2,xmm2

     movups xmm3,[eax+48]
     mulps xmm3,xmm3

     movups [eax],xmm0
     movups [eax+16],xmm1
     movups [eax+32],xmm2
     movups [eax+48],xmm3

     add eax,64
     add edx,64
     dec ecx
    jnz @HurgeLoop
   @SkipHurgeLoop:
  pop ecx
  and ecx,15
  jz @Done

  push ecx
   shr ecx,2
   jz @SkipLargeLoop
    @LargeLoop:
     movups xmm0,[eax]
     mulps xmm0,xmm0
     movups [eax],xmm0
     add eax,16
     add edx,16
     dec ecx
    jnz @LargeLoop
   @SkipLargeLoop:
  pop ecx
  and ecx,3
  jz @Done

  @SmallLoop:
    movss xmm0,dword ptr [eax]
    mulss xmm0,xmm0
    movss dword ptr [eax],xmm0
    add eax,4
    add edx,4
   dec ecx
  jnz @SmallLoop
                 
 @Done:
end;
{$endif}

procedure SynthProcessModSqr(Target:PSynthFloatValue;Samples:longint);{$ifdef cpu386}register;{$endif}
var Counter:longint;
begin
 for Counter:=1 to Samples shr 2 do begin
  Target^:=sqr(Target^);
  inc(Target);
  Target^:=sqr(Target^);
  inc(Target);
  Target^:=sqr(Target^);
  inc(Target);
  Target^:=sqr(Target^);
  inc(Target);
 end;
 for Counter:=1 to Samples and 3 do begin
  Target^:=sqr(Target^);
  inc(Target);
 end;
end;

procedure SynthProcessModulationMatrix(Track:PSynthTrack;ThreadNumber:longint;var DestBuf:PSynthFloatValue;Instrument:PSynthInstrument;Channel:PSynthChannel;Voice:PSynthVoice;Target,TargetIndex:byte;Samples:longint;DefaultBuffer:PSynthFloatValue);
var Counter,ActiveCount,i:longint;
    Item,LastItem:PSynthInstrumentModulationMatrixItem;
    Value:single;
    SrcBuf,SrcBufSqr,TempBuf:PSynthFloatValue;
begin
 if not assigned(Instrument) then begin
  DestBuf:=DefaultBuffer;
 end else begin
  ActiveCount:=0;
  LastItem:=nil;
  for Counter:=0 to Instrument^.ModulationMatrixItems-1 do begin
   Item:=@Instrument^.ModulationMatrix[Counter];
   if (Item^.Source<>mmiNONE) and (Item^.Target=Target) and (Item^.TargetIndex=TargetIndex) and (Item^.Polarity in [mmpMUL..mmpDIVABS]) then begin
    LastItem:=Item;
    inc(ActiveCount);
   end;
  end;
  if ActiveCount=0 then begin
   DestBuf:=DefaultBuffer;
  end else begin
   if not ((ActiveCount=1) and (assigned(LastItem) and (LastItem^.Polarity=mmpADD))) then begin
    FillChar(DestBuf^,Samples*sizeof(single),#0);
   end;
   for Counter:=0 to Instrument^.ModulationMatrixItems-1 do begin
    Item:=@Instrument^.ModulationMatrix[Counter];
    if (Item^.Source<>mmiNONE) and (Item^.Target=Target) and (Item^.TargetIndex=TargetIndex) and (Item^.Polarity in [mmpMUL..mmpDIVABS]) then begin
     TempBuf:=@Track^.WorkBuffers^.TempModulationMatrixBuffers[ThreadNumber];
     SrcBuf:=TempBuf;
     SrcBufSqr:=nil;
     case Item^.Source of
      mmiADSR:begin
       if Item^.SourceIndex in [0..MaxInstrumentADSR-1] then begin
        if Track^.ADSRBuffersActive[ThreadNumber,Item^.SourceIndex] then begin
         SrcBuf:=@Track^.WorkBuffers^.ADSRBuffers[ThreadNumber,Item^.SourceIndex];
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiENV:begin
       if Item^.SourceIndex in [0..MaxInstrumentEnvelopes-1] then begin
        if Track^.EnvelopeBuffersActive[ThreadNumber,Item^.SourceIndex] then begin
         SrcBuf:=@Track^.WorkBuffers^.EnvelopeBuffers[ThreadNumber,Item^.SourceIndex];
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiLFO:begin
       if Item^.SourceIndex in [0..MaxInstrumentLFO-1] then begin
        if Track^.LFOBuffersActive[ThreadNumber,Item^.SourceIndex] then begin
         SrcBuf:=@Track^.WorkBuffers^.LFOBuffers[ThreadNumber,Item^.SourceIndex];
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiVALUE:begin
       SrcBuf:=@Track^.WorkBuffers^.Values8BitBuffers[Item^.SourceIndex and $ff];
       SrcBufSqr:=@Track^.WorkBuffers^.Values8BitSqrBuffers[Item^.SourceIndex and $ff];
      end;
      mmiCONTROLLER:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingControllers[Item^.SourceIndex].Active and Channel^.RampingControllers[Item^.SourceIndex].HasBufferAlreadyFilled and ((Channel^.RampingControllers[Item^.SourceIndex].BufferAlreadyFilledValue=0) or (Channel^.RampingControllers[Item^.SourceIndex].BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingControllers[Item^.SourceIndex].BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelControllersBuffer[Channel^.Number,Item^.SourceIndex,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelControllersBuffer[Channel^.Number,Item^.SourceIndex,1];
        end;
       end else begin
        SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[Channel^.Controllers[Item^.SourceIndex] and $7f];
        SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[Channel^.Controllers[Item^.SourceIndex] and $7f];
       end;
      end;
      mmiNOTE:begin
       if assigned(Voice) then begin
        if (Item^.SourceFlags and 2)<>0 then begin
         SrcBuf:=@Track^.WorkBuffers^.VoiceNoteBuffer[Voice^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.VoiceNoteBuffer[Voice^.Number,1];
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[Voice^.Note and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[Voice^.Note and $7f];
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiVELOCITY:begin
       if assigned(Voice) then begin
        if (Item^.SourceFlags and 2)<>0 then begin
         SrcBuf:=@Track^.WorkBuffers^.VoiceVelocityBuffer[Voice^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.VoiceVelocityBuffer[Voice^.Number,1];
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[Voice^.Velocity and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[Voice^.Velocity and $7f];
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiKEYOFFVELOCITY:begin
       if assigned(Voice) then begin
        if (Item^.SourceFlags and 2)<>0 then begin
         SrcBuf:=@Track^.WorkBuffers^.VoiceKeyOffVelocityBuffer[Voice^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.VoiceKeyOffVelocityBuffer[Voice^.Number,1];
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[Voice^.KeyOffVelocity and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[Voice^.KeyOffVelocity and $7f];
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiAFTERTOUCH:begin
       if assigned(Voice) then begin
        if (Item^.SourceFlags and 2)<>0 then begin
         SrcBuf:=@Track^.WorkBuffers^.VoiceAfterTouchBuffer[Voice^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.VoiceAfterTouchBuffer[Voice^.Number,1];
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[Voice^.AfterTouch and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[Voice^.AfterTouch and $7f];
        end;
       end else begin
        SrcBuf:=nil;
       end;
      end;
      mmiMODULATION:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingModulation.Active and Channel^.RampingModulation.HasBufferAlreadyFilled and ((Channel^.RampingModulation.BufferAlreadyFilledValue=0) or (Channel^.RampingModulation.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingModulation.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelModulationBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelModulationBuffer[Channel^.Number,1];
        end;
       end else begin
        if (Channel^.Modulation and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.Modulation shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.Modulation shr 7) and $7f];
        end else if (Channel^.Modulation and $7f)=((Channel^.Modulation shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.Modulation shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.Modulation shr 7) and $7f];
        end else begin
         Value:=Channel^.Modulation*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiBREATH:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingBreath.Active and Channel^.RampingBreath.HasBufferAlreadyFilled and ((Channel^.RampingBreath.BufferAlreadyFilledValue=0) or (Channel^.RampingBreath.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingBreath.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelBreathBuffer[Channel^.Number];
        end;
       end else begin
        if (Channel^.Breath and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.Breath shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.Breath shr 7) and $7f];
        end else if (Channel^.Breath and $7f)=((Channel^.Breath shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.Breath shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.Breath shr 7) and $7f];
        end else begin
         Value:=Channel^.Breath*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiVOLUME:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingVolume.Active and Channel^.RampingVolume.HasBufferAlreadyFilled and ((Channel^.RampingVolume.BufferAlreadyFilledValue=0) or (Channel^.RampingVolume.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingVolume.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelVolumeBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelVolumeBuffer[Channel^.Number,1];
        end;
       end else begin
        if (Channel^.MainVolume and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.MainVolume shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.MainVolume shr 7) and $7f];
        end else if (Channel^.MainVolume and $7f)=((Channel^.MainVolume shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.MainVolume shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.MainVolume shr 7) and $7f];
        end else begin
         Value:=Channel^.MainVolume*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiEXPRESSION:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingExpression.Active and Channel^.RampingExpression.HasBufferAlreadyFilled and ((Channel^.RampingExpression.BufferAlreadyFilledValue=0) or (Channel^.RampingExpression.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingExpression.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelExpressionBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelExpressionBuffer[Channel^.Number,1];
        end;
       end else begin
        if (Channel^.Expression and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.Expression shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.Expression shr 7) and $7f];
        end else if (Channel^.Expression and $7f)=((Channel^.Expression shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.Expression shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.Expression shr 7) and $7f];
        end else begin
         Value:=Channel^.Expression*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiPANNING:begin
       if ((Item^.SourceFlags and 2)<>0) or (Channel^.RampingPanning.Active and Channel^.RampingPanning.HasBufferAlreadyFilled) then begin
        if Channel^.RampingPanning.Active and Channel^.RampingPanning.HasBufferAlreadyFilled and ((Channel^.RampingPanning.BufferAlreadyFilledValue=0) or (Channel^.RampingPanning.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingPanning.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelPanningBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelPanningBuffer[Channel^.Number,1];
        end;
       end else begin
        Value:=Clip(Clip((((((Channel^.Panning*fCI128)-64)*(Channel^.Balance*fCI128))*fCI64)+64)-1,0,126)*fCI126,0,1);
{$ifdef UseSSE}
        if SSEExt and Track^.UseSSE then begin
         SynthFillFloatSSE(SrcBuf,Value,Samples);
        end else{$endif} begin
         SynthFillFloat(SrcBuf,Value,Samples);
        end;
       end;
      end;
      mmiPORTAMENTOTIME:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingPortamentoTime.Active and Channel^.RampingPortamentoTime.HasBufferAlreadyFilled and ((Channel^.RampingPortamentoTime.BufferAlreadyFilledValue=0) or (Channel^.RampingPortamentoTime.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingPortamentoTime.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelPortamentoTimeBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelPortamentoTimeBuffer[Channel^.Number,1];
        end;
       end else begin
        if (Channel^.PortamentoTime and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.PortamentoTime shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.PortamentoTime shr 7) and $7f];
        end else if (Channel^.PortamentoTime and $7f)=((Channel^.PortamentoTime shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.PortamentoTime shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.PortamentoTime shr 7) and $7f];
        end else begin
         Value:=Channel^.PortamentoTime*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiFOOTPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingFootPedal.Active and Channel^.RampingFootPedal.HasBufferAlreadyFilled and ((Channel^.RampingFootPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingFootPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingFootPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelFootPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelFootPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if (Channel^.FootPedal and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.FootPedal shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.FootPedal shr 7) and $7f];
        end else if (Channel^.FootPedal and $7f)=((Channel^.FootPedal shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.FootPedal shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.FootPedal shr 7) and $7f];
        end else begin
         Value:=Channel^.FootPedal*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      mmiHOLDPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingHoldPedal.Active and Channel^.RampingHoldPedal.HasBufferAlreadyFilled and ((Channel^.RampingHoldPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingHoldPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingHoldPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelHoldPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelHoldPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.HoldPedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiPORTAMENTOPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingPortamentoPedal.Active and Channel^.RampingPortamentoPedal.HasBufferAlreadyFilled and ((Channel^.RampingPortamentoPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingPortamentoPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingPortamentoPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelPortamentoPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelPortamentoPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.PortamentoPedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiSOSTENUTOPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingSostenutoPedal.Active and Channel^.RampingSostenutoPedal.HasBufferAlreadyFilled and ((Channel^.RampingSostenutoPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingSostenutoPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingSostenutoPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelSostenutoPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelSostenutoPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.SostenutoPedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiSOFTPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingSoftPedal.Active and Channel^.RampingSoftPedal.HasBufferAlreadyFilled and ((Channel^.RampingSoftPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingSoftPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingSoftPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelSoftPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelSoftPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.SoftPedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiLEGATOPEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingLegatoPedal.Active and Channel^.RampingLegatoPedal.HasBufferAlreadyFilled and ((Channel^.RampingLegatoPedal.BufferAlreadyFilledValue=0) or (Channel^.RampingLegatoPedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingLegatoPedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelLegatoPedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelLegatoPedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.LegatoPedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiHOLD2PEDAL:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingHold2Pedal.Active and Channel^.RampingHold2Pedal.HasBufferAlreadyFilled and ((Channel^.RampingHold2Pedal.BufferAlreadyFilledValue=0) or (Channel^.RampingHold2Pedal.BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingHold2Pedal.BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelHold2PedalBuffer[Channel^.Number,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelHold2PedalBuffer[Channel^.Number,1];
        end;
       end else begin
        if Channel^.Hold2Pedal then begin
         SrcBuf:=Track^.F1D0Buffer;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=Track^.ZeroBuffer;
         SrcBufSqr:=SrcBuf;
        end;
       end;
      end;
      mmiVALUEEXT:begin
       SrcBuf:=@Track^.WorkBuffers^.Values8BitExtBuffers[Item^.SourceIndex and $ff];
       SrcBufSqr:=@Track^.WorkBuffers^.Values8BitExtSqrBuffers[Item^.SourceIndex and $ff];
      end;
      mmiRESCALE:begin
       SrcBuf:=@Track^.WorkBuffers^.ValuesRescaleBuffers[Item^.SourceIndex and $ff];
       SrcBufSqr:=@Track^.WorkBuffers^.ValuesRescaleSqrBuffers[Item^.SourceIndex and $ff];
      end;
      mmiINVRESCALE:begin
       SrcBuf:=@Track^.WorkBuffers^.ValuesInvRescaleBuffers[Item^.SourceIndex and $ff];
       SrcBufSqr:=@Track^.WorkBuffers^.ValuesInvRescaleSqrBuffers[Item^.SourceIndex and $ff];
      end;
      mmiMEMORY:begin
       SrcBuf:=Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Item^.SourceIndex and 7];
      end;
      mmiNRPN:begin
       if (Item^.SourceFlags and 2)<>0 then begin
        if Channel^.RampingNRPNControllers[Item^.SourceIndex].Active and Channel^.RampingNRPNControllers[Item^.SourceIndex].HasBufferAlreadyFilled and ((Channel^.RampingNRPNControllers[Item^.SourceIndex].BufferAlreadyFilledValue=0) or (Channel^.RampingNRPNControllers[Item^.SourceIndex].BufferAlreadyFilledValue=1)) then begin
         if Channel^.RampingNRPNControllers[Item^.SourceIndex].BufferAlreadyFilledValue=1 then begin
          SrcBuf:=Track^.F1D0Buffer;
         end else begin
          SrcBuf:=Track^.ZeroBuffer;
         end;
         SrcBufSqr:=SrcBuf;
        end else begin
         SrcBuf:=@Track^.WorkBuffers^.ChannelNRPNControllersBuffer[Channel^.Number,Item^.SourceIndex,0];
         SrcBufSqr:=@Track^.WorkBuffers^.ChannelNRPNControllersBuffer[Channel^.Number,Item^.SourceIndex,1];
        end;
       end else begin
        if (Channel^.NRPNControllers[Item^.SourceIndex] and $7f)=0 then begin
         SrcBuf:=@Track^.WorkBuffers^.Values14BitBuffers[(Channel^.NRPNControllers[Item^.SourceIndex] shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values14BitSqrBuffers[(Channel^.NRPNControllers[Item^.SourceIndex] shr 7) and $7f];
        end else if (Channel^.NRPNControllers[Item^.SourceIndex] and $7f)=((Channel^.NRPNControllers[Item^.SourceIndex] shr 7) and $7f) then begin
         SrcBuf:=@Track^.WorkBuffers^.Values7BitBuffers[(Channel^.NRPNControllers[Item^.SourceIndex] shr 7) and $7f];
         SrcBufSqr:=@Track^.WorkBuffers^.Values7BitSqrBuffers[(Channel^.NRPNControllers[Item^.SourceIndex] shr 7) and $7f];
        end else begin
         Value:=Channel^.NRPNControllers[Item^.SourceIndex]*fCI16383;
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFillFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFillFloat(SrcBuf,Value,Samples);
         end;
        end;
       end;
      end;
      else begin
       SrcBuf:=nil;
      end;
     end;
     if assigned(SrcBuf) then begin
      if (SrcBuf=@Track^.WorkBuffers^.Values7BitBuffers[0]) or (SrcBuf=@Track^.WorkBuffers^.Values8BitBuffers[0]) or (SrcBuf=@Track^.WorkBuffers^.Values14BitBuffers[0]) then begin
       SrcBuf:=Track^.ZeroBuffer;
      end else if (SrcBuf=@Track^.WorkBuffers^.Values7BitBuffers[127]) or (SrcBuf=@Track^.WorkBuffers^.Values8BitBuffers[255]) then begin
       SrcBuf:=Track^.F1D0Buffer;
      end;
      if (Item^.Amount=64) and ((Item^.SourceFlags and 1)=0) and ((Item^.SourceMode=mmismSQR) and assigned(SrcBufSqr)) then begin
       SrcBuf:=SrcBufSqr;
      end else if not ((Item^.Amount=64) and ((Item^.SourceFlags and 1)=0) and (Item^.SourceMode=mmismLINEAR)) then begin
       if SrcBuf<>TempBuf then begin
        Move(SrcBuf^,TempBuf^,Samples*sizeof(TSynthFloatValue));
        SrcBuf:=TempBuf;
       end;
       if (SrcBuf<>Track^.ZeroBuffer) and (SrcBuf<>Track^.F0D5Buffer) and (SrcBuf<>Track^.F1D0Buffer) then begin
        if Item^.Amount<64 then begin
         Value:=Item^.Amount*fCI64;
  {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthFloatBufferMulFloatSSE(SrcBuf,Value,Samples);
         end else{$endif} begin
          SynthFloatBufferMulFloat(SrcBuf,Value,Samples);
         end;
        end;
        case Item^.SourceMode of
         mmismLINEAR:begin
         end;
         mmismSQR:begin
  {$ifdef UseSSE}
          if SSEExt and Track^.UseSSE then begin
           SynthProcessModSqrSSE(SrcBuf,Samples);
          end else{$endif} begin
           SynthProcessModSqr(SrcBuf,Samples);
          end;
         end;
         mmismSQRT:begin
          for i:=0 to Samples-1 do begin
           psingles(SrcBuf)^[i]:=FastSQRT(psingles(SrcBuf)^[i]);
          end;
         end;
         mmismSIN1D4:begin
          for i:=0 to Samples-1 do begin
           psingles(SrcBuf)^[i]:=sin(psingles(SrcBuf)^[i]*halfpi);
          end;
         end;
         mmismCOS1D4:begin
          for i:=0 to Samples-1 do begin
           psingles(SrcBuf)^[i]:=sin((psingles(SrcBuf)^[i]*halfpi)+halfpi);
          end;
         end;
        end;
        if (Item^.SourceFlags and 1)<>0 then begin
         for i:=0 to Samples-1 do begin
          psingles(SrcBuf)^[i]:=1.0-psingles(SrcBuf)^[i];
         end;
        end;
       end;
      end;
      if (ActiveCount=1) and (Item^.Polarity=mmpADD) then begin
       if SrcBuf=@Track^.WorkBuffers^.TempModulationMatrixBuffers[ThreadNumber] then begin
        Move(SrcBuf^,DestBuf^,Samples*sizeof(single));
       end else begin
        DestBuf:=SrcBuf;
       end;
      end else begin
       case Item^.Polarity of
        mmpMUL:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModMulSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModMul(DestBuf,SrcBuf,Samples);
         end;
        end;
        mmpMULABS:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModMulAbsSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModMulAbs(DestBuf,SrcBuf,Samples);
         end;
        end;
        mmpADD:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModAddSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModAdd(DestBuf,SrcBuf,Samples);
         end;
        end;
        mmpSUB:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModSubSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModSub(DestBuf,SrcBuf,Samples);
         end;
        end;
        mmpDIV:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModDivSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModDiv(DestBuf,SrcBuf,Samples);
         end;
        end;
        mmpDIVABS:begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModDivAbsSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModDivAbs(DestBuf,SrcBuf,Samples);
         end;
        end;
        else begin
 {$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthProcessModAddSSE(DestBuf,SrcBuf,Samples);
         end else{$endif} begin
          SynthProcessModAdd(DestBuf,SrcBuf,Samples);
         end;
        end;
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

procedure SynthProcessVoiceOscillator(Track:PSynthTrack;ThreadNumber:longint;Voice:PSynthVoice;Instrument:PSynthInstrument;Oscillator:PSynthInstrumentOscillator;OscillatorData:PSynthInstrumentOscillatorData;Target,LastTarget:PSynthBufferSample;HardSyncBuffer:pboolean;Samples:longint;NewTick:boolean;OscNr:longint;VoicePitchBuffer:PSynthFloatValue);
const m1:single=-1;
var FrequencyModulationTarget,Buf:PSynthBufferSample;
    TransposeBuffer,PitchBuffer,ColorBuffer,FeedBackBuffer,VolumeBuffer,HardSyncActiveBuffer,GlideBuffer,SmpPosBuffer,
    PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer:PSynthFloatValue;
    Transpose,vi,i:longint;
    PhaseIncrement,v,vl,vr{,Amp}:single;
begin
 OscillatorData^.Patch:=Voice^.Patch;

 if OscillatorData^.NewNote or OscillatorData^.NewFrequency then begin

  OscillatorData^.NewNoteEx:=OscillatorData^.NewNote;
  OscillatorData^.NewFrequencyEx:=OscillatorData^.NewFrequency;

  Transpose:=0;
  if Samples>0 then begin
   TransposeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   SynthProcessModulationMatrix(Track,ThreadNumber,TransposeBuffer,Instrument,Voice^.Channel,Voice,mmoOscTranspose,OscNr,1,nil);
   if assigned(TransposeBuffer) then begin
    inc(Transpose,SoftTRUNC(TransposeBuffer^*128));
   end;
   TransposeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   SynthProcessModulationMatrix(Track,ThreadNumber,TransposeBuffer,Instrument,Voice^.Channel,Voice,mmoTranspose,0,1,nil);
   if assigned(TransposeBuffer) then begin
    inc(Transpose,SoftTRUNC(TransposeBuffer^*128));
   end;
  end;
  PhaseIncrement:=power(2,(((Voice^.FloatNote+(Instrument^.Transpose+Oscillator^.Transpose+Transpose))-69)+(Oscillator^.FineTune*fCI100))*fCI12);
  OscillatorData^.RealPhaseIncrement:=(440*Track^.InternalSampleRateFactor)*PhaseIncrement;
  OscillatorData^.PhaseIncrement:=OscillatorData^.RealPhaseIncrement;
  if not Voice^.Carry then begin
   OscillatorData^.RampingPhase.Current:=OscillatorData^.PhaseIncrement;
   OscillatorData^.RampingPhase.Active:=false;
  end;
  if Oscillator^.Glide<>0 then begin
   OscillatorData^.PhaseIncrement:=1;
   OscillatorData^.GlideSamples:=SynthConvertGlideTimeByteToSamples(Track,Oscillator^.Glide);
  end else begin
   OscillatorData^.GlideSamples:=0;
  end;
  GlideBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
  SynthProcessModulationMatrix(Track,ThreadNumber,GlideBuffer,Instrument,Voice^.Channel,Voice,mmoOscGlide,OscNr,1,nil);
  if assigned(GlideBuffer) then begin
   OscillatorData^.GlideSamples:=softtrunc((OscillatorData^.GlideSamples*GlideBuffer^)+0.5);
  end;
  if OscillatorData^.NewNote then begin
   if not (Voice^.Carry and OscillatorData^.SampleActive and Oscillator^.Carry) then begin
    OscillatorData^.Sample:=@Track^.Samples[Voice^.Patch,(Oscillator^.Color+$40) and $7f];
    if OscillatorData^.Sample^.Header.RandomStartPosition then begin
     OscillatorData^.SampleIndex:=round64((abs(RandomFloat(OscillatorData^.Seed))*(OscillatorData^.Sample^.Header.Samples-1))*PositionFactor);
    end else begin
     OscillatorData^.SampleIndex:=0;
    end;
    OscillatorData^.SampleBackwards:=false;
    OscillatorData^.SampleActive:=true;
   end;
  end;
  OscillatorData^.NewNote:=false;
  OscillatorData^.NewFrequency:=false;
 end;

 SmpPosBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
 SynthProcessModulationMatrix(Track,ThreadNumber,SmpPosBuffer,Instrument,Voice^.Channel,Voice,mmoOscSmpPos,OscNr,1,nil);
 if assigned(SmpPosBuffer) then begin
  vi:=softtrunc((SmpPosBuffer^*127)+0.5);
  if (vi<>0) and assigned(OscillatorData^.Sample) and OscillatorData^.SampleActive then begin
   OscillatorData^.SampleIndex:=round64((SmpPosBuffer^*(OscillatorData^.Sample^.Header.Samples-1))*PositionFactor);
  end;
 end;

 OscillatorData^.KeyOff:=Voice^.KeyOff;

 if Oscillator^.Glide<>0 then begin
  OscillatorData^.PhaseIncrement:=1;
  SynthProcessRamping(Track,OscillatorData^.RampingPhase,@Track^.WorkBuffers^.GlideBuffer[ThreadNumber],nil,Samples,OscillatorData^.GlideSamples,rmLINEAR,OscillatorData^.RealPhaseIncrement,false);
 end else begin
  OscillatorData^.PhaseIncrement:=OscillatorData^.RealPhaseIncrement;
 end;

 if ((Oscillator^.SynthesisType in [stPhaseModulation,stFrequencyModulation,stPhaseMulModulation,stFrequencyMulModulation]) or
     (Oscillator^.WaveForm=wfPLUCKEDSTRING)) and assigned(LastTarget) then begin
  FrequencyModulationTarget:=LastTarget;
 end else begin
  FrequencyModulationTarget:=nil;
 end;

 OscillatorData^.FeedBack:=Oscillator^.FeedBack*fCI256;

 PitchBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
 ColorBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
 FeedBackBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
 HardSyncActiveBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
 PluckedStringReflectionBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
 PluckedStringPickBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
 PluckedStringPickUpBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,6];
 SuperOscDetuneBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,7];
 SuperOscMixBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,8];
 SynthProcessModulationMatrix(Track,ThreadNumber,PitchBuffer,Instrument,Voice^.Channel,Voice,mmoOscPitch,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,ColorBuffer,Instrument,Voice^.Channel,Voice,mmoOscColor,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,FeedBackBuffer,Instrument,Voice^.Channel,Voice,mmoOscFeedBack,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,HardSyncActiveBuffer,Instrument,Voice^.Channel,Voice,mmoOscHardSync,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,PluckedStringReflectionBuffer,Instrument,Voice^.Channel,Voice,mmoOscPluckedStringReflection,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,PluckedStringPickBuffer,Instrument,Voice^.Channel,Voice,mmoOscPluckedStringPick,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,PluckedStringPickUpBuffer,Instrument,Voice^.Channel,Voice,mmoOscPluckedStringPickUp,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,SuperOscDetuneBuffer,Instrument,Voice^.Channel,Voice,mmoOscSuperOscDetune,OscNr,Samples,Track^.F1D0Buffer);
 SynthProcessModulationMatrix(Track,ThreadNumber,SuperOscMixBuffer,Instrument,Voice^.Channel,Voice,mmoOscSuperOscMix,OscNr,Samples,Track^.F1D0Buffer);

 if assigned(VoicePitchBuffer) then begin
  if assigned(PitchBuffer) and (PitchBuffer<>Track^.F1D0Buffer) then begin
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthFloatBufferMulFloatBufferSSE(PitchBuffer,VoicePitchBuffer,Samples);
   end else{$endif} begin
    SynthFloatBufferMulFloatBuffer(PitchBuffer,VoicePitchBuffer,Samples);
   end;
  end else begin
   PitchBuffer:=VoicePitchBuffer;
  end;
  if Oscillator^.Glide<>0 then begin
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthFloatBufferMulFloatBufferSSE(@Track^.WorkBuffers^.GlideBuffer[ThreadNumber],PitchBuffer,Samples);
   end else{$endif} begin
    SynthFloatBufferMulFloatBuffer(@Track^.WorkBuffers^.GlideBuffer[ThreadNumber],PitchBuffer,Samples);
   end;
   PitchBuffer:=@Track^.WorkBuffers^.GlideBuffer[ThreadNumber];
  end;
 end else begin
  if Oscillator^.Glide<>0 then begin
   if assigned(PitchBuffer) and (PitchBuffer<>Track^.F1D0Buffer) then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthFloatBufferMulFloatBufferSSE(PitchBuffer,@Track^.WorkBuffers^.GlideBuffer[ThreadNumber],Samples);
    end else{$endif} begin
     SynthFloatBufferMulFloatBuffer(PitchBuffer,@Track^.WorkBuffers^.GlideBuffer[ThreadNumber],Samples);
    end;
   end else begin
    PitchBuffer:=@Track^.WorkBuffers^.GlideBuffer[ThreadNumber];
   end;
  end;
 end;

{ PhaseIncrement:=0;
 SynthFillFloat(Target^,Samples,PhaseIncrement);}

 SynthOscillatorGenerateWaveFormProcs[Oscillator^.WaveForm](Track,Oscillator,OscillatorData,Target,FrequencyModulationTarget,PitchBuffer,ColorBuffer,FeedBackBuffer,HardSyncActiveBuffer,PluckedStringReflectionBuffer,PluckedStringPickBuffer,PluckedStringPickUpBuffer,SuperOscDetuneBuffer,SuperOscMixBuffer,HardSyncBuffer,Samples);
{$ifdef UseSSE}
 if SSEExt and Track^.UseSSE then begin
  SynthProcessOscillatorVolumeSSE(Target,Samples,Oscillator^.Volume);
 end else{$endif} begin
  SynthProcessOscillatorVolume(Target,Samples,Oscillator^.Volume);
 end;

 if Oscillator^.UsePanning then begin
  v:=((Oscillator^.Panning+$40)*fci128)*halfpi;
  vl:=cos(v);
  vr:=sin(v);
  Buf:=Target;
  for i:=1 to Samples do begin
   Buf^.Left:=Buf^.Left*vl;
   Buf^.Right:=Buf^.Right*vr;
   longword(pointer(@Buf^.Left)^):=longword(pointer(@Buf^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Buf^.Right)^):=longword(pointer(@Buf^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(Buf);
  end;
 end;

 VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
 SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Instrument,Voice^.Channel,Voice,mmoOscVolume,OscNr,Samples,Track^.F1D0Buffer);
 if assigned(VolumeBuffer) and (VolumeBuffer<>Track^.F1D0Buffer) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthSampleBufferMulFloatBufferSSE(Target,VolumeBuffer,Samples);
  end else{$endif} begin
   SynthSampleBufferMulFloatBuffer(Target,VolumeBuffer,Samples);
  end;         
 end;

 if assigned(LastTarget) then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthProcessOscillatorModulationSSE[Oscillator^.SynthesisType](Target,LastTarget,Samples);
  end else{$endif} begin
   SynthProcessOscillatorModulation[Oscillator^.SynthesisType](Target,LastTarget,Samples);
  end;
 end else if Oscillator^.SynthesisType=stSubtractive then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthSampleBufferMulFloatSSE(Target,m1,Samples);
  end else{$endif} begin
   SynthSampleBufferMulFloat(Target,m1,Samples);
  end;
 end;

end;

{$WARNINGS OFF}
procedure SynthPreprocessVoice(Track:PSynthTrack;Voice:PSynthVoice);
begin
 if (Voice^.Holding and not Voice^.Channel^.HoldPedal) or
    (Voice^.KeyOff and Voice^.Sostenutoing and not Voice^.Channel^.SostenutoPedal) then begin
  SynthVoiceKeyOff(Track,Voice);
 end;
end;

procedure SynthProcessVoice(Track:PSynthTrack;ThreadNumber:longint;Voice:PSynthVoice;Samples:longint;NewTick:boolean);
var SrcBuf,BufValue,BufValueEx,Buf,Dst,LastProcessBuffer,CurrentProcessBuffer,OutputProcessBuffer,VoiceBuffer:PSynthBufferSample;
    CutOffBuffer,ResonanceBuffer,PhaseIncrementBuffer,PhaseBuffer,DepthBuffer,MiddleBuffer,VolumeBuffer,PanningBuffer,AttackBuffer,DecayBuffer,SustainBuffer,
    ReleaseBuffer,DecayLevelBuffer,AmplifyBuffer,GainBuffer,DistBuffer,RateBuffer,VolBuf,PitchBuffer:PSynthFloatValue;
    HardSyncBuffer,CurrentHardSyncBuffer:pboolean;
    Left,Right,Volume,AValue:single;
    Instrument:PSynthInstrument;
    Counter,OrderCounter,SamplesCounter,FiltersUsed:longint;
    HardSyncBufferIsFilled,DoClickRemoval,Chain:boolean;
    NeedFlags,NeedMemoryFlags,ProcessBufferFilled,HardBufferMustFill,HardBufferFilled,RemainOscs:byte;
begin
 DoClickRemoval:=false;

 Instrument:=Voice^.Instrument;

 Volume:=sqr(Instrument^.Volume*fci255);

 VoiceBuffer:=@Track^.WorkBuffers^.VoiceBuffer[Voice^.Number];

 Voice^.TempLast.Left:=0;
 Voice^.TempLast.Right:=0;

 Voice^.NeedClickRemoval:=false;

 NeedFlags:=0;
 NeedMemoryFlags:=0;
 for Counter:=0 to MaxModulationMatrixMemory-1 do begin
  Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter]:=nil;
 end;
 for Counter:=0 to Instrument^.ModulationMatrixItems-1 do begin
  if (Instrument^.ModulationMatrix[Counter].SourceFlags and 2)<>0 then begin
   case Instrument^.ModulationMatrix[Counter].Source of
    mmiNOTE:begin
     NeedFlags:=NeedFlags or 1;
    end;
    mmiVELOCITY:begin
     NeedFlags:=NeedFlags or 2;
    end;
    mmiKEYOFFVELOCITY:begin
     NeedFlags:=NeedFlags or 4;
    end;
    mmiAFTERTOUCH:begin
     NeedFlags:=NeedFlags or 8;
    end;
   end;
  end;
  case Instrument^.ModulationMatrix[Counter].Source of
   mmiMEMORY:begin
    NeedMemoryFlags:=NeedMemoryFlags or (1 shl Instrument^.ModulationMatrix[Counter].SourceIndex);
   end;
  end;
 end;
 if (NeedFlags and 1)<>0 then begin
  SynthProcessRamping(Track,Voice^.RampingNote,@Track^.WorkBuffers^.VoiceNoteBuffer[Voice^.Number,0],@Track^.WorkBuffers^.VoiceNoteBuffer[Voice^.Number,1],Samples,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Voice^.Note*fCI127,true);
 end;
 if (NeedFlags and 2)<>0 then begin
  SynthProcessRamping(Track,Voice^.RampingVelocity,@Track^.WorkBuffers^.VoiceVelocityBuffer[Voice^.Number,0],@Track^.WorkBuffers^.VoiceVelocityBuffer[Voice^.Number,1],Samples,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Voice^.Velocity*fCI127,true);
 end;
 if (NeedFlags and 4)<>0 then begin
  SynthProcessRamping(Track,Voice^.RampingKeyOffVelocity,@Track^.WorkBuffers^.VoiceKeyOffVelocityBuffer[Voice^.Number,0],@Track^.WorkBuffers^.VoiceKeyOffVelocityBuffer[Voice^.Number,1],Samples,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Voice^.KeyOffVelocity*fCI127,true);
 end;
 if (NeedFlags and 8)<>0 then begin
  SynthProcessRamping(Track,Voice^.RampingAfterTouch,@Track^.WorkBuffers^.VoiceAfterTouchBuffer[Voice^.Number,0],@Track^.WorkBuffers^.VoiceAfterTouchBuffer[Voice^.Number,1],Samples,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Voice^.AfterTouch*fCI127,true);
 end;
 for Counter:=0 to MaxModulationMatrixMemory-1 do begin
  if (NeedMemoryFlags and (1 shl Counter))<>0 then begin
   Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter]:=@Track^.WorkBuffers^.MemoryBuffers[ThreadNumber,Counter];
   SynthProcessModulationMatrix(Track,ThreadNumber,Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter],Instrument,Voice^.Channel,Voice,mmoMEMORY,Counter,Samples,nil);
  end;                     
 end;

 // ADSR
 Voice^.Active:=false;
{$ifdef BR808ADSR}
 for Counter:=0 to MaxInstrumentADSR-1 do begin
  if Instrument^.ADSR[Counter].Active then begin
   Track^.ADSRBuffersActive[ThreadNumber,Counter]:=true;
   AttackBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   DecayBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
   SustainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
   ReleaseBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
   DecayLevelBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
   AmplifyBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
   SynthProcessModulationMatrix(Track,ThreadNumber,AttackBuffer,Instrument,Voice^.Channel,Voice,mmoADSRAttack,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,DecayBuffer,Instrument,Voice^.Channel,Voice,mmoADSRDecay,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,SustainBuffer,Instrument,Voice^.Channel,Voice,mmoADSRSustain,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,ReleaseBuffer,Instrument,Voice^.Channel,Voice,mmoADSRRelease,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,DecayLevelBuffer,Instrument,Voice^.Channel,Voice,mmoADSRDecayLevel,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,AmplifyBuffer,Instrument,Voice^.Channel,Voice,mmoADSRAmplify,Counter,Samples,Track^.F1D0Buffer);
   SynthProcessADSR(Track,@Instrument^.ADSR[Counter],@Voice^.ADSRData[Counter],@Track.WorkBuffers^.ADSRBuffers[ThreadNumber,Counter],AttackBuffer,DecayBuffer,SustainBuffer,ReleaseBuffer,DecayLevelBuffer,AmplifyBuffer,Samples);
   if Instrument^.ADSR[Counter].ActiveCheck and (Voice^.ADSRData[Counter].State<>emNONE) then begin
    Voice^.Active:=true;
   end;
  end else begin
   Track^.ADSRBuffersActive[ThreadNumber,Counter]:=false;
  end;
 end;
{$endif}

 // Envelope
{$ifdef BR808ENVELOPES}
 for Counter:=0 to MaxInstrumentEnvelopes-1 do begin
  if Instrument^.Envelope[Counter].Active then begin
   Track^.EnvelopeBuffersActive[ThreadNumber,Counter]:=true;
   AmplifyBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   SynthProcessModulationMatrix(Track,ThreadNumber,AmplifyBuffer,Instrument,Voice^.Channel,Voice,mmoEnvelopeAmplify,Counter,Samples,Track^.F1D0Buffer);
   SynthProcessEnvelope(Track,@Instrument^.Envelope[Counter],@Voice^.EnvelopeData[Counter],@Track^.Envelopes[Voice^.Patch,Counter],@Track^.WorkBuffers^.EnvelopeBuffers[ThreadNumber,Counter],AmplifyBuffer,Samples);
   if Instrument^.Envelope[Counter].ActiveCheck and not Voice^.EnvelopeData[Counter].EndOfEnvelope then begin
    Voice^.Active:=true;
   end;
  end else begin
   Track^.EnvelopeBuffersActive[ThreadNumber,Counter]:=false;
  end;
 end;
{$endif}

 // LFO
{$ifdef BR808LFO}
 for Counter:=0 to MaxInstrumentLFO-1 do begin
  if Instrument^.LFO[Counter].WaveForm<>lwfNONE then begin
   PhaseIncrementBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   PhaseBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
   DepthBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
   MiddleBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
   SynthProcessModulationMatrix(Track,ThreadNumber,PhaseIncrementBuffer,Instrument,Voice^.Channel,Voice,mmoLFORate,Counter,Samples,Track^.F1D0Buffer);
   SynthProcessModulationMatrix(Track,ThreadNumber,PhaseBuffer,Instrument,Voice^.Channel,Voice,mmoLFOPhase,Counter,Samples,nil);
   SynthProcessModulationMatrix(Track,ThreadNumber,DepthBuffer,Instrument,Voice^.Channel,Voice,mmoLFODepth,Counter,Samples,Track^.F1D0Buffer);
   SynthProcessModulationMatrix(Track,ThreadNumber,MiddleBuffer,Instrument,Voice^.Channel,Voice,mmoLFOMiddle,Counter,Samples,Track^.ZeroBuffer);
  end else begin
   PhaseIncrementBuffer:=Track^.F1D0Buffer;
   PhaseBuffer:=Track^.F1D0Buffer;
   DepthBuffer:=Track^.F1D0Buffer;
   MiddleBuffer:=Track^.ZeroBuffer;
  end;
  Track^.LFOBuffersActive[ThreadNumber,Counter]:=SynthProcessLFO(Track,Voice,@Instrument^.LFO[Counter],@Voice^.LFOData[Counter],@Track.WorkBuffers^.LFOBuffers[ThreadNumber,Counter],PhaseIncrementBuffer,PhaseBuffer,DepthBuffer,MiddleBuffer,Samples);
 end;
{$endif}

 // Process pitch modulation matrix
 PitchBuffer:=@Track^.WorkBuffers^.PitchBuffers[ThreadNumber];
 SynthProcessModulationMatrix(Track,ThreadNumber,PitchBuffer,Instrument,Voice^.Channel,Voice,mmoPitch,0,Samples,nil);

 // Synthesing
 HardSyncBuffer:=@Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,-1];
 FillChar(HardSyncBuffer^,Samples*sizeof(boolean),#0);
 HardSyncBufferIsFilled:=false;
 BufValue:=nil;
 CurrentProcessBuffer:=@Track.WorkBuffers^.ProcessBuffers[ThreadNumber,0];
 LastProcessBuffer:=nil;
 OutputProcessBuffer:=nil;
 ProcessBufferFilled:=0;
 HardBufferMustFill:=0;
 HardBufferFilled:=0;
 RemainOscs:=0;
 for Counter:=0 to MaxInstrumentOscillator-1 do begin
  if (Instrument^.Oscillator[Counter].WaveForm<>wfNONE) and ((Voice^.Note>=Instrument^.Oscillator[Counter].NoteBegin) and (Voice^.Note<=Instrument^.Oscillator[Counter].NoteEnd)) then begin
   if (Instrument^.Oscillator[Counter].HardSyncInput>=0) and (Instrument^.Oscillator[Counter].HardSyncInput<MaxInstrumentOscillator) then begin
    HardBufferMustFill:=HardBufferMustFill or (1 shl Instrument^.Oscillator[Counter].HardSyncInput);
   end;
   RemainOscs:=RemainOscs or (1 shl Counter);
  end;
 end;
 for Counter:=0 to MaxInstrumentOscillator-1 do begin

  if (Instrument^.Oscillator[Counter].WaveForm<>wfNONE) and ((Voice^.Note>=Instrument^.Oscillator[Counter].NoteBegin) and (Voice^.Note<=Instrument^.Oscillator[Counter].NoteEnd)) then begin

   begin

    if (Instrument^.Oscillator[Counter].Input>=0) and (Instrument^.Oscillator[Counter].Input<MaxInstrumentOscillator) then begin
     if (ProcessBufferFilled and (1 shl Instrument^.Oscillator[Counter].Input))<>0 then begin
      LastProcessBuffer:=@Track.WorkBuffers^.ProcessBuffers[ThreadNumber,Instrument^.Oscillator[Counter].Input];
     end else begin
      LastProcessBuffer:=@Track.WorkBuffers^.SilenceBuffer;
     end;
    end;

    if (Instrument^.Oscillator[Counter].HardSyncInput>=0) and (Instrument^.Oscillator[Counter].HardSyncInput<MaxInstrumentOscillator) then begin
     if (HardBufferFilled and (1 shl Instrument^.Oscillator[Counter].HardSyncInput))<>0 then begin
      Move(Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,Instrument^.Oscillator[Counter].HardSyncInput],Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,-2],Samples*sizeof(boolean));
     end else begin
      FillChar(Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,-2],Samples*sizeof(boolean),#0);
     end;
     CurrentHardSyncBuffer:=@Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,-2];
    end else begin
     CurrentHardSyncBuffer:=HardSyncBuffer;
    end;

    CurrentProcessBuffer:=@Track.WorkBuffers^.ProcessBuffers[ThreadNumber,Counter];

   end;

   SynthProcessVoiceOscillator(Track,ThreadNumber,Voice,Instrument,@Instrument^.Oscillator[Counter],@Voice^.OscillatorData[Counter],CurrentProcessBuffer,LastProcessBuffer,CurrentHardSyncBuffer,Samples,NewTick,Counter,PitchBuffer);

   begin
    RemainOscs:=RemainOscs and not (1 shl Counter);

    ProcessBufferFilled:=ProcessBufferFilled or (1 shl Counter);

    LastProcessBuffer:=CurrentProcessBuffer;
    
    if Instrument^.Oscillator[Counter].Output then begin
     if assigned(OutputProcessBuffer) then begin
{$ifdef UseSSE}
      if SSEExt and Track^.UseSSE then begin
       SynthMixToBufferSSE(CurrentProcessBuffer,OutputProcessBuffer,Samples);
      end else{$endif} begin
       SynthMixToBuffer(CurrentProcessBuffer,OutputProcessBuffer,Samples);
      end;
     end else begin
      OutputProcessBuffer:=@Track^.WorkBuffers^.OutputVoiceBuffer[ThreadNumber];
      Move(CurrentProcessBuffer^,OutputProcessBuffer^,Samples*sizeof(TSynthBufferSample));
     end;
     BufValue:=nil;
    end else begin
     BufValue:=CurrentProcessBuffer;
    end;

    if RemainOscs<>0 then begin
     if Instrument^.Oscillator[Counter].HardSync then begin
      if ((HardBufferMustFill and (1 shl Counter))<>0) then begin
       Move(CurrentHardSyncBuffer^,Track^.WorkBuffers^.HardSyncBuffer[ThreadNumber,Counter],Samples*sizeof(boolean));
       HardBufferFilled:=HardBufferFilled or (1 shl Counter);
      end;
      if CurrentHardSyncBuffer<>HardSyncBuffer then begin
       Move(CurrentHardSyncBuffer^,HardSyncBuffer^,Samples*sizeof(boolean));
      end;
      HardSyncBufferIsFilled:=true;
     end else begin
      if HardSyncBufferIsFilled then begin
       FillChar(HardSyncBuffer^,Samples*sizeof(boolean),#0);
       HardSyncBufferIsFilled:=false;
      end;
     end;
    end;

   end;

  end;

 end;

 if assigned(OutputProcessBuffer) then begin
  if assigned(BufValue) then begin
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthMixToBufferSSE(BufValue,OutputProcessBuffer,Samples);
   end else{$endif} begin
    SynthMixToBuffer(BufValue,OutputProcessBuffer,Samples);
   end;
  end;
  BufValue:=OutputProcessBuffer;
 end else if not assigned(BufValue) then begin
  FillChar(CurrentProcessBuffer^,Samples*sizeof(TSynthBufferSample),#0);
  BufValue:=CurrentProcessBuffer;
 end;

 VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
 SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Instrument,Voice^.Channel,Voice,mmoVolume,0,Samples,nil);

 if assigned(BufValue) and assigned(VolumeBuffer) then begin
  PanningBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
  SynthProcessModulationMatrix(Track,ThreadNumber,PanningBuffer,Instrument,Voice^.Channel,Voice,mmoPanning,0,Samples,Track^.F0D5Buffer);

{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthSampleBufferMulFloatSSE(BufValue,Volume,Samples);
  end else{$endif} begin
   SynthSampleBufferMulFloat(BufValue,Volume,Samples);
  end;

  for OrderCounter:=low(TSynthInstrumentVoiceOrder) to high(TSynthInstrumentVoiceOrder) do begin
   case Instrument^.VoiceOrder[OrderCounter] of
    voDistortion:begin
{$ifdef BR808VOICEDISTORTION}
     for Counter:=0 to MaxInstrumentDistortion-1 do begin
      if Voice^.Instrument^.VoiceDistortion[Counter].Mode<>dmNONE then begin
       GainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
       DistBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
       RateBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
       SynthProcessModulationMatrix(Track,ThreadNumber,GainBuffer,Instrument,Voice^.Channel,Voice,mmoVoiceDistortionGain,Counter,Samples,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,DistBuffer,Instrument,Voice^.Channel,Voice,mmoVoiceDistortionDist,Counter,Samples,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,RateBuffer,Instrument,Voice^.Channel,Voice,mmoVoiceDistortionRate,Counter,Samples,Track^.F1D0Buffer);
       SynthProcessDistortion(Track,@Voice^.Instrument^.VoiceDistortion[Counter],@Voice^.VoiceDistortionData[Counter],BufValue,GainBuffer,DistBuffer,RateBuffer,Samples);
      end;
     end;
{$endif}
    end;
    voFilter:begin
{$ifdef BR808VOICEFILTER}
     // Filter
     FiltersUsed:=0;
     for Counter:=0 to MaxInstrumentFilter-1 do begin
      if Instrument^.Filter[Counter].Mode<>fmNONE then begin
       inc(FiltersUsed);
      end;
     end;
     if FiltersUsed>0 then begin
      if FiltersUsed>1 then begin
       FillChar(Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Samples*sizeof(TSynthBufferSample),#0);
      end;
      SrcBuf:=BufValue;
      Chain:=false;
      for Counter:=0 to MaxInstrumentFilter-1 do begin
       if Instrument^.Filter[Counter].Mode<>fmNONE then begin
        CutOffBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
        ResonanceBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
        GainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
        AmplifyBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
        SynthProcessModulationMatrix(Track,ThreadNumber,CutOffBuffer,Instrument,Voice^.Channel,Voice,mmoFilterCutOff,Counter,Samples,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,ResonanceBuffer,Instrument,Voice^.Channel,Voice,mmoFilterResonance,Counter,Samples,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,GainBuffer,Instrument,Voice^.Channel,Voice,mmoFilterVolume,Counter,Samples,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,AmplifyBuffer,Instrument,Voice^.Channel,Voice,mmoFilterAmplify,Counter,Samples,Track^.F1D0Buffer);
        if FiltersUsed=1 then begin
         Dst:=BufValue;
        end else begin
         Dst:=@Track^.WorkBuffers^.FilterBuffer[ThreadNumber];
        end;
        SynthProcessFilter(Track,@Instrument^.Filter[Counter],@Voice^.FilterData[Counter],SrcBuf,Dst,CutOffBuffer,ResonanceBuffer,GainBuffer,AmplifyBuffer,Samples);
        if FiltersUsed>1 then begin
         Chain:=Instrument^.Filter[Counter].Chain;
         if Chain then begin
          Move(Track^.WorkBuffers^.FilterBuffer[ThreadNumber],Track^.WorkBuffers^.FilterTempBuffer[ThreadNumber],Samples*sizeof(TSynthBufferSample));
          SrcBuf:=@Track^.WorkBuffers^.FilterTempBuffer[ThreadNumber];
         end else begin
{$ifdef UseSSE}
          if SSEExt and Track^.UseSSE then begin
           SynthMixToBufferSSE(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Samples);
          end else{$endif} begin
           SynthMixToBuffer(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Samples);
          end;
          SrcBuf:=BufValue;
         end;
        end;
       end;
      end;
      if FiltersUsed>1 then begin
       if Chain then begin
{$ifdef UseSSE}
        if SSEExt and Track^.UseSSE then begin
         SynthMixToBufferSSE(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Samples);
        end else{$endif} begin
         SynthMixToBuffer(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Samples);
        end;
       end;
       Move(Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],BufValue^,Samples*sizeof(TSynthBufferSample));
      end;
     end;
{$endif}
    end;
   end;
  end;

  // Ampifing
  if assigned(VolumeBuffer) then begin
   VolBuf:=VolumeBuffer;
   BufValueEx:=BufValue;
   Buf:=VoiceBuffer;
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthCopyAndMulOnlyBufferSSE(BufValueEx,Buf,VolBuf,Samples);
   end else{$endif} begin     
    for SamplesCounter:=1 to Samples do begin
     Buf^.Left:=BufValueEx^.Left*VolBuf^;
     Buf^.Right:=BufValueEx^.Right*VolBuf^;
     longword(pointer(@Buf^.Left)^):=longword(pointer(@Buf^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@Buf^.Right)^):=longword(pointer(@Buf^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(Buf);
     inc(BufValueEx);
     inc(VolBuf);
    end;
   end;

   if assigned(PanningBuffer) then begin
    Buf:=VoiceBuffer;
    for SamplesCounter:=1 to Samples do begin
     AValue:=PanningBuffer^*halfpi;
     Buf^.Left:=Buf^.Left*cos(AValue);
     Buf^.Right:=Buf^.Right*sin(AValue);
     longword(pointer(@Buf^.Left)^):=longword(pointer(@Buf^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@Buf^.Right)^):=longword(pointer(@Buf^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(Buf);
     inc(PanningBuffer);
    end;
   end;
  end else begin
   if assigned(PanningBuffer) then begin
    BufValueEx:=BufValue;
    Buf:=VoiceBuffer;
    for SamplesCounter:=1 to Samples do begin
     AValue:=PanningBuffer^*halfpi;
     Buf^.Left:=BufValueEx^.Left*cos(AValue);
     Buf^.Right:=BufValueEx^.Right*sin(AValue);
     longword(pointer(@Buf^.Left)^):=longword(pointer(@Buf^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@Buf^.Right)^):=longword(pointer(@Buf^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(Buf);
     inc(BufValueEx);
     inc(PanningBuffer);
    end;
   end else begin
    Move(BufValue^,VoiceBuffer^,Samples*sizeof(TSynthBufferSample));
   end;
  end;

  if Samples>0 then begin
   Buf:=@PSynthBufferSamples(VoiceBuffer)^[Samples-1];
   Left:=Buf^.Left;
   Right:=Buf^.Right;
  end else begin
   Left:=0;
   Right:=0;
  end;

  Voice^.Last.Left:=Left;
  Voice^.Last.Right:=Right;

  inc(Voice^.LifeTime,Samples);
  if not Voice^.Active then begin
   DoClickRemoval:=true;
  end;
 end else begin
  DoClickRemoval:=true;
 end;
 if DoClickRemoval then begin
  SynthKillDenormal(Voice^.Last.Left);
  SynthKillDenormal(Voice^.Last.Right);
  Voice^.NeedClickRemoval:=true;
  Voice^.TempLast:=Voice^.Last;
  Voice^.Last.Left:=0;
  Voice^.Last.Right:=0;
 end;
 Voice^.LastInstrument:=Voice^.Instrument;

 Track^.VoiceBufferOut[Voice^.Number]:=VoiceBuffer;

 if assigned(Voice^.Channel) and not Voice^.KeyOff then begin
  InterlockedExchange(longint(Voice^.Channel^.KeyOff),longint(longbool(false)));
 end;
end;

{$ifdef UseSSE}
procedure SynthProcessChannelAutomaticClickRemovalSSE(Channel:PSynthChannel;Sample:PSynthBufferSample;SamplesCount:longint;ClickFactor:single); assembler; stdcall;
asm
 push eax
 push ebx
 push ecx
 push edi
 push esi
  mov edi,dword ptr Channel

  movss xmm2,dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Left]
  movss xmm3,dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Right]
  movss dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Left],xmm2
  movss dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Right],xmm3

  movss xmm4,dword ptr ClickFactor

  test dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Left],$7fffffff
  jnz @OkayWeHaveAnythingToDo

  test dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Right],$7fffffff
  jnz @OkayWeHaveAnythingToDo

  jmp @AntiClickingNothingToDo

   @OkayWeHaveAnythingToDo:
    mov esi,dword ptr Sample
    mov ecx,dword ptr SamplesCount
    test ecx,ecx
    jz @NothingToDo
     @Loop:

      movss xmm0,dword ptr [esi]
      movss xmm1,dword ptr [esi+4]

      mulss xmm2,xmm4
      mulss xmm3,xmm4

      addss xmm0,xmm2
      addss xmm1,xmm3

      movss dword ptr [esi],xmm0
      movss dword ptr [esi+4],xmm1

      add esi,8

      dec ecx
     jnz @Loop
    @NothingToDo:

   movss dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Left],xmm2
   movss dword ptr [edi+TSynthChannel.Last+TSynthBufferSample.Right],xmm3

  @AntiClickingNothingToDo:

 pop esi
 pop edi
 pop ecx
 pop ebx
 pop eax
end;
{$endif}

procedure SynthProcessChannelAutomaticClickRemoval(Channel:PSynthChannel;Sample:PSynthBufferSample;SamplesCount:longint;ClickFactor:single);
var Left,Right:single;
    SamplesCounter:longint;
begin
 SynthKillDenormal(Channel^.Last.Left);
 SynthKillDenormal(Channel^.Last.Right);
 if ((plongword(@Channel^.Last.Left)^ and $7fffffff)<>0) or ((plongword(@Channel^.Last.Right)^ and $7fffffff)<>0) then begin
  // Automatic Click Removal
  Left:=Channel^.Last.Left;
  Right:=Channel^.Last.Right;
  for SamplesCounter:=1 to SamplesCount do begin
   Left:=Left*ClickFactor;
   Right:=Right*ClickFactor;
   longword(pointer(@Left)^):=longword(pointer(@Left)^) and longword($ffffffff+longword(((((longword(pointer(@Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@Right)^):=longword(pointer(@Right)^) and longword($ffffffff+longword(((((longword(pointer(@Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   Sample^.Left:=Sample^.Left+Left;
   Sample^.Right:=Sample^.Right+Right;
   inc(Sample);
  end;
  Channel^.Last.Left:=Left;
  Channel^.Last.Right:=Right;
 end;
end;

procedure SynthAmplifyChannelBuffer(Target:PSynthBufferSample;VolumeBuffer:PSynthFloatValue;Samples:longint);
var SampleCounter:longint;
begin
 for SampleCounter:=1 to Samples do begin
  Target^.Left:=Target^.Left*VolumeBuffer^;
  Target^.Right:=Target^.Right*VolumeBuffer^;
  longword(pointer(@Target^.Left)^):=longword(pointer(@Target^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Target^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  longword(pointer(@Target^.Right)^):=longword(pointer(@Target^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Target^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
  inc(Target);
  inc(VolumeBuffer);
 end;
end;
{$WARNINGS ON}

procedure SynthPreprocessChannel(Track:PSynthTrack;ThreadNumber:longint;Channel:PSynthChannel;SamplesCount:longint;NewTick:boolean);
var VoiceCounter:longint;
    Voice,NewestVoice:PSynthVoice;
begin
 NewestVoice:=nil;
 for VoiceCounter:=0 to Channel^.CountVoices-1 do begin
  Voice:=Channel^.Voices[VoiceCounter];
  if (Voice^.Channel=Channel) and Voice^.Active and (Voice^.Note>=0) then begin
   SynthPreprocessVoice(Track,Voice);
   if not assigned(NewestVoice) then begin
    NewestVoice:=Voice;
   end else if Voice.LifeTime<=NewestVoice^.LifeTime then begin
    NewestVoice:=Voice;
   end;
  end;
 end;
 Channel^.NewestVoice:=NewestVoice;

 if assigned(Channel^.Instrument) and (Channel^.Instrument^.ChannelCompressor.Mode>cmNONE) and (Channel^.Instrument^.ChannelCompressor.SideIn>0) then begin
  Channel^.SideIn:=(Channel^.Instrument^.ChannelCompressor.SideIn-1) and $f;
  Track^.Channels[Channel^.SideIn].MustHaveBuffer:=true;
 end else begin
  Channel^.SideIn:=Channel^.Number and $f;
 end;
 InterlockedExchange(longint(Channel^.Ready),longint(longbool(false)));
end;

procedure SynthProcessChannelInit(Track:PSynthTrack;ThreadNumber:longint;Channel:PSynthChannel;SamplesCount:longint;NewTick:boolean);
var Counter:longint;
begin
 if Channel^.Instrument<>Channel^.LastInstrument then begin
  Channel^.ChannelLFOData.Phase:=0;
{$ifdef BR808CHANNELDISTORTION}
  SynthProcessChannelDistortionInit(Track,@Channel^.Instrument^.ChannelDistortion,@Channel^.ChannelDistortionData);
{$endif}
{$ifdef BR808CHANNELFILTER}
  SynthProcessChannelFilterInit(Track,@Channel^.Instrument^.ChannelFilter,@Channel^.ChannelFilterData);
{$endif}
{$ifdef BR808DELAY}
  SynthProcessDelayInit(Track,@Channel^.Instrument^.ChannelDelay,@Channel^.ChannelDelayData);
{$endif}
{$ifdef BR808CHORUSFLANGER}
  SynthProcessChorusFlangerInit(Track,@Channel^.Instrument^.ChannelChorusFlanger,@Channel^.ChannelChorusFlangerData);
{$endif}
{$ifdef BR808COMPRESSOR}
  SynthProcessCompressorInit(Track,@Channel^.Instrument^.ChannelCompressor,@Channel^.ChannelCompressorData);
{$endif}
{$ifdef BR808PITCHSHIFTER}
  SynthProcessPitchShifterInit(Track,@Channel^.Instrument^.ChannelPitchShifter,@Channel^.ChannelPitchShifterData);
{$endif}
{$ifdef BR808EQ}
  SynthProcessEQInit(Track,@Channel^.Instrument^.ChannelEQ,@Channel^.ChannelEQData);
{$endif}
{$ifdef BR808SPEECH}
  SynthSpeechReset(Channel^.SpeechInstance);
{$endif}
  Channel^.SpeechInstance.FrameLength:=Channel^.Instrument^.ChannelSpeech.FrameLength;
  Channel^.SpeechInstance.Speed:=Channel^.Instrument^.ChannelSpeech.Speed;
  Channel^.SpeechInstance.Color:=Channel^.Instrument^.ChannelSpeech.Color;
  Channel^.SpeechInstance.NoiseGain:=Channel^.Instrument^.ChannelSpeech.NoiseGain;
  Channel^.SpeechInstance.Gain:=Channel^.Instrument^.ChannelSpeech.Gain;
  Channel^.SpeechInstance.CascadeGain:=Channel^.Instrument^.ChannelSpeech.CascadeGain;
  Channel^.SpeechInstance.ParallelGain:=Channel^.Instrument^.ChannelSpeech.ParallelGain;
  Channel^.SpeechInstance.AspirationGain:=Channel^.Instrument^.ChannelSpeech.AspirationGain;
  Channel^.SpeechInstance.FricationGain:=Channel^.Instrument^.ChannelSpeech.FricationGain;
  Channel^.LastInstrument:=Channel^.Instrument;
 end;

 SynthKillDenormal(Channel^.Last.Left);
 SynthKillDenormal(Channel^.Last.Right);
 if ((plongword(@Channel^.Last.Left)^ and $7fffffff)<>0) or ((plongword(@Channel^.Last.Right)^ and $7fffffff)<>0) then begin

  FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);

{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthProcessChannelAutomaticClickRemovalSSE(Channel,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount,Track^.ClickRemovalFactor);
  end else{$endif} begin
   SynthProcessChannelAutomaticClickRemoval(Channel,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount,Track^.ClickRemovalFactor);
  end;

  Channel^.HasBuffer:=true;
 end else begin
  Channel^.HasBuffer:=false;
 end;

 SynthProcessRamping(Track,Channel^.RampingVolume,@Track^.WorkBuffers^.ChannelVolumeBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelVolumeBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.MainVolume*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingExpression,@Track^.WorkBuffers^.ChannelExpressionBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelExpressionBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.Expression*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingPanning,@Track^.WorkBuffers^.ChannelPanningBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelPanningBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Clip(Clip((((((Channel^.Panning*fCI128)-64)*(Channel^.Balance*fCI128))*fCI64)+64)-1,0,126)*fCI126,0,1),true);
 SynthProcessRamping(Track,Channel^.RampingBreath,@Track^.WorkBuffers^.ChannelBreathBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelBreathBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.Breath*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingModulation,@Track^.WorkBuffers^.ChannelModulationBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelModulationBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.Modulation*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingPortamentoTime,@Track^.WorkBuffers^.ChannelPortamentoTimeBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelPortamentoTimeBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.PortamentoTime*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingFootPedal,@Track^.WorkBuffers^.ChannelFootPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelFootPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.FootPedal*fCI16383,true);
 SynthProcessRamping(Track,Channel^.RampingHoldPedal,@Track^.WorkBuffers^.ChannelHoldPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelHoldPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.HoldPedal),true);
 SynthProcessRamping(Track,Channel^.RampingPortamentoPedal,@Track^.WorkBuffers^.ChannelPortamentoPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelPortamentoPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.PortamentoPedal),true);
 SynthProcessRamping(Track,Channel^.RampingSostenutoPedal,@Track^.WorkBuffers^.ChannelSostenutoPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelSostenutoPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.SostenutoPedal),true);
 SynthProcessRamping(Track,Channel^.RampingSoftPedal,@Track^.WorkBuffers^.ChannelSoftPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelSoftPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.SoftPedal),true);
 SynthProcessRamping(Track,Channel^.RampingLegatoPedal,@Track^.WorkBuffers^.ChannelLegatoPedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelLegatoPedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.LegatoPedal),true);
 SynthProcessRamping(Track,Channel^.RampingHold2Pedal,@Track^.WorkBuffers^.ChannelHold2PedalBuffer[Channel^.Number,0],@Track^.WorkBuffers^.ChannelHold2PedalBuffer[Channel^.Number,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,ord(Channel^.Hold2Pedal),true);
 for Counter:=0 to 127 do begin
  SynthProcessRamping(Track,Channel^.RampingControllers[Counter],@Track^.WorkBuffers^.ChannelControllersBuffer[Channel^.Number,Counter,0],@Track^.WorkBuffers^.ChannelControllersBuffer[Channel^.Number,Counter,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.Controllers[Counter]*fCI127,true);
 end;
 for Counter:=0 to 255 do begin
  SynthProcessRamping(Track,Channel^.RampingNRPNControllers[Counter],@Track^.WorkBuffers^.ChannelNRPNControllersBuffer[Channel^.Number,Counter,0],@Track^.WorkBuffers^.ChannelNRPNControllersBuffer[Channel^.Number,Counter,1],SamplesCount,Track^.CurrentRampingSamples,Track^.Global.RampingMode,Channel^.NRPNControllers[Counter]*fCI16383,true);
 end;

 Channel^.KeyOff:=true;

 Channel^.HaveAUXReverb:=false;
 Channel^.HaveAUXDelay:=false;
 Channel^.HaveAUXChorusFlanger:=false;
end;

procedure SynthProcessChannelFinalize(Track:PSynthTrack;ThreadNumber:longint;Channel:PSynthChannel;SamplesCount:longint;NewTick:boolean);
var VoiceCounter,OrderCounter,Counter,vi,FiltersUsed:longint;
    Voice,NewestVoice:PSynthVoice;
    VolumeBuffer,GainBuffer,DistBuffer,RateBuffer,
    CutOffBuffer,ResonanceBuffer,
    TimeLeftBuffer,FeedBackLeftBuffer,
    TimeRightBuffer,FeedBackRightBuffer,
    LFORateLeftBuffer,LFODepthLeftBuffer,
    LFORateRightBuffer,LFODepthRightBuffer,
    WindowBuffer,SoftHardKneeBuffer,ThresholdBuffer,RatioBuffer,
    AttackBuffer,ReleaseBuffer,OutGainBuffer,
    AmplifyBuffer,WetBuffer,DryBuffer,SpeechTextNumberBuffer,
    SpeechSpeedBuffer,SpeechColorBuffer,SpeechNoiseGainBuffer,
    SpeechGainBuffer,SpeechPositionBuffer,
    SpeechCascadeGainBuffer,SpeechParallelGainBuffer,
    SpeechAspirationGainBuffer,SpeechFricationGainBuffer,
    TuneBuffer,FineTuneBuffer,
    Gain0Buffer,Gain1Buffer,Gain2Buffer,Gain3Buffer,Gain4Buffer,Gain5Buffer,
    Gain6Buffer,Gain7Buffer,Gain8Buffer,Gain9Buffer:PSynthFloatValue;
    Value:TSynthFloatValue;
    SrcBuf,DstBuf:PSynthBufferSample;
    Chain:boolean;
    NeedMemoryFlags:byte;
begin
 if (not Channel^.Ready) and ((Channel^.SideIn=Channel^.Number) or Track^.Channels[Channel^.SideIn and $f].Ready) then begin

  NewestVoice:=Channel^.NewestVoice;

  for VoiceCounter:=0 to Channel^.CountVoices-1 do begin
   Voice:=Channel^.Voices[VoiceCounter];
   if Voice^.Channel=Channel then begin
    if Voice^.NeedClickRemoval then begin
     Voice^.NeedClickRemoval:=false;
     Voice^.Channel^.Last.Left:=Voice^.Channel^.Last.Left+Voice^.TempLast.Left;
     Voice^.Channel^.Last.Right:=Voice^.Channel^.Last.Right+Voice^.TempLast.Right;
     Voice^.TempLast.Left:=0;
     Voice^.TempLast.Right:=0;
    end;
    if assigned(Track^.VoiceBufferOut[Voice^.Number]) then begin
     if Channel^.HasBuffer then begin
{$ifdef UseSSE}
      if SSEExt and Track^.UseSSE then begin
       SynthMixToBufferSSE(Track^.VoiceBufferOut[Voice^.Number],@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount);
      end else{$endif} begin
       SynthMixToBuffer(Track^.VoiceBufferOut[Voice^.Number],@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount);
      end;
     end else begin
      Move(Track^.VoiceBufferOut[Voice^.Number]^,Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample));
      Channel^.HasBuffer:=true;
     end;
     Track^.VoiceBufferOut[Voice^.Number]:=nil;
    end;
   end;
  end;

{ if not Channel^.HasBuffer then begin
   FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
   Channel^.HasBuffer:=true;
  end;}

  if assigned(Channel^.Instrument) then begin

   NeedMemoryFlags:=0;
   for Counter:=0 to MaxModulationMatrixMemory-1 do begin
    Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter]:=nil;
   end;
   for Counter:=0 to Channel^.Instrument^.ModulationMatrixItems-1 do begin
    case Channel^.Instrument^.ModulationMatrix[Counter].Source of
     mmiMEMORY:begin
      NeedMemoryFlags:=NeedMemoryFlags or (1 shl Channel^.Instrument^.ModulationMatrix[Counter].SourceIndex);
     end;
    end;
   end;
   for Counter:=0 to MaxModulationMatrixMemory-1 do begin
    if (NeedMemoryFlags and (1 shl Counter))<>0 then begin
     Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter]:=@Track^.WorkBuffers^.MemoryBuffers[ThreadNumber,Counter];
     SynthProcessModulationMatrix(Track,ThreadNumber,Track^.ModulationMatrixMemoryBuffers[ThreadNumber,Counter],Channel^.Instrument,Voice^.Channel,Voice,mmoMEMORY,Counter,SamplesCount,nil);
    end;
   end;

   if Channel^.Instrument^.ChannelLFO.Active then begin
    Channel^.ChannelLFOData.PhaseIncrement:=(power(0.0001,(255-Channel^.Instrument^.ChannelLFO.Rate)*fCI255)*100)*Track^.InternalSampleRateFactor;
    Channel^.ChannelLFOData.Phase:=frac(Channel^.ChannelLFOData.Phase+Channel^.ChannelLFOData.PhaseIncrement*SamplesCount);
   end;

   for OrderCounter:=low(TSynthInstrumentChannelOrder) to high(TSynthInstrumentChannelOrder) do begin
    case Channel^.Instrument^.ChannelOrder[OrderCounter] of
     coDistortion:begin
{$ifdef BR808CHANNELDISTORTION}
      for Counter:=0 to MaxInstrumentDistortion-1 do begin
       if Channel^.Instrument^.ChannelDistortion[Counter].Mode<>dmNONE then begin
        if not Channel^.HasBuffer then begin
         FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
         Channel^.HasBuffer:=true;
        end;
        GainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
        DistBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
        RateBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
        SynthProcessModulationMatrix(Track,ThreadNumber,GainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDistortionGain,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,DistBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDistortionDist,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,RateBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDistortionRate,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessDistortion(Track,@Channel^.Instrument^.ChannelDistortion[Counter],@Channel^.ChannelDistortionData[Counter],@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],GainBuffer,DistBuffer,RateBuffer,SamplesCount);
       end;
      end;
 {$endif}
     end;
     coFilter:begin
 {$ifdef BR808CHANNELFILTER}
      // Filter
      FiltersUsed:=0;
      for Counter:=0 to MaxInstrumentFilter-1 do begin
       if Channel^.Instrument^.ChannelFilter[Counter].Mode<>fmNONE then begin
        inc(FiltersUsed);
       end;
      end;
      if FiltersUsed>0 then begin
       if FiltersUsed>1 then begin
        FillChar(Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],SamplesCount*sizeof(TSynthBufferSample),#0);
       end;
       SrcBuf:=@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number];
       Chain:=false;
       for Counter:=0 to MaxInstrumentFilter-1 do begin
        if Channel^.Instrument^.ChannelFilter[Counter].Mode<>fmNONE then begin
         if not Channel^.HasBuffer then begin
          FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
          Channel^.HasBuffer:=true;
         end;
         CutOffBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
         ResonanceBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
         VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
         AmplifyBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
         SynthProcessModulationMatrix(Track,ThreadNumber,CutOffBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelFilterCutOff,Counter,SamplesCount,Track^.F1D0Buffer);
         SynthProcessModulationMatrix(Track,ThreadNumber,ResonanceBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelFilterResonance,Counter,SamplesCount,Track^.F1D0Buffer);
         SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelFilterVolume,Counter,SamplesCount,Track^.F1D0Buffer);
         SynthProcessModulationMatrix(Track,ThreadNumber,AmplifyBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelFilterAmplify,Counter,SamplesCount,Track^.F1D0Buffer);
         if FiltersUsed=1 then begin
          DstBuf:=@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number];
         end else begin
          DstBuf:=@Track^.WorkBuffers^.FilterBuffer[ThreadNumber];
         end;
         SynthProcessFilter(Track,@Channel^.Instrument^.ChannelFilter[Counter],@Channel^.ChannelFilterData[Counter],SrcBuf,DstBuf,CutOffBuffer,ResonanceBuffer,VolumeBuffer,AmplifyBuffer,SamplesCount);
         if FiltersUsed>1 then begin
          Chain:=Channel^.Instrument^.ChannelFilter[Counter].Chain;
          if Chain then begin
           Move(Track^.WorkBuffers^.FilterBuffer[ThreadNumber],Track^.WorkBuffers^.FilterTempBuffer[ThreadNumber],SamplesCount*sizeof(TSynthBufferSample));
           SrcBuf:=@Track^.WorkBuffers^.FilterTempBuffer[ThreadNumber];
          end else begin
{$ifdef UseSSE}
           if SSEExt and Track^.UseSSE then begin
            SynthMixToBufferSSE(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],SamplesCount);
           end else{$endif} begin
            SynthMixToBuffer(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],SamplesCount);
           end;
           SrcBuf:=@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number];
          end;
         end;
        end;
       end;
       if FiltersUsed>1 then begin
        if Chain then begin
{$ifdef UseSSE}
         if SSEExt and Track^.UseSSE then begin
          SynthMixToBufferSSE(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],SamplesCount);
         end else{$endif} begin
          SynthMixToBuffer(@Track^.WorkBuffers^.FilterBuffer[ThreadNumber],@Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],SamplesCount);
         end;
        end;
        Move(Track^.WorkBuffers^.FilterOutputBuffer[ThreadNumber],Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample));
       end;
      end;
{$endif}
     end;
     coDelay:begin
{$ifdef BR808DELAY}
      for Counter:=0 to MaxInstrumentDelay-1 do begin
       if Channel^.Instrument^.ChannelDelay[Counter].Active then begin
        if not Channel^.HasBuffer then begin
         FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
         Channel^.HasBuffer:=true;
        end;
        TimeLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
        FeedBackLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
        TimeRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
        FeedBackRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
        WetBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
        DryBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
        SynthProcessModulationMatrix(Track,ThreadNumber,TimeLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayTimeLeft,Counter,SamplesCount,Track^.ZeroBuffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,FeedBackLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayFeedBackLeft,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,TimeRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayTimeRight,Counter,SamplesCount,Track^.ZeroBuffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,FeedBackRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayFeedBackRight,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,WetBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayWet,Counter,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,DryBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelDelayDry,Counter,SamplesCount,Track^.F1D0Buffer);
        if not assigned(Channel^.DelayBuffer[Counter]) then begin
         GetMemZero(Channel^.DelayBuffer[Counter],Track^.DelayBufferSize*sizeof(TSynthBufferSample));
        end;
        SynthProcessDelay(Track,@Channel^.Instrument^.ChannelDelay[Counter],@Channel^.ChannelDelayData[Counter],@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Channel^.DelayBuffer[Counter],TimeLeftBuffer,FeedBackLeftBuffer,TimeRightBuffer,FeedBackRightBuffer,WetBuffer,DryBuffer,SamplesCount);
       end else begin
        if assigned(Channel^.DelayBuffer[Counter]) then begin
         FreeMemAligned(Channel^.DelayBuffer[Counter]);
         Channel^.DelayBuffer[Counter]:=nil;
        end;
       end;
      end;
{$endif}
     end;
     coChorusFlanger:begin
{$ifdef BR808CHORUSFLANGER}
      if Channel^.Instrument^.ChannelChorusFlanger.Active then begin
       if not Channel^.HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
        Channel^.HasBuffer:=true;
       end;
       TimeLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
       FeedBackLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
       TimeRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
       FeedBackRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
       LFORateLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
       LFODepthLeftBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
       LFORateRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,6];
       LFODepthRightBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,7];
       VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,8];
       SynthProcessModulationMatrix(Track,ThreadNumber,TimeLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerTimeLeft,0,SamplesCount,Track^.ZeroBuffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,FeedBackLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerFeedBackLeft,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,TimeRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerTimeRight,0,SamplesCount,Track^.ZeroBuffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,FeedBackRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerFeedBackRight,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,LFORateLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerLFORateLeft,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,LFODepthLeftBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerLFODepthLeft,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,LFORateRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerLFORateRight,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,LFODepthRightBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerLFODepthRight,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,WetBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerWet,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,DryBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelChorusFlangerDry,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessChorusFlanger(Track,@Channel^.Instrument^.ChannelChorusFlanger,@Channel^.ChannelChorusFlangerData,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Channel^.ChorusFlangerBuffer,TimeLeftBuffer,FeedBackLeftBuffer,TimeRightBuffer,FeedBackRightBuffer,LFORateLeftBuffer,LFODepthLeftBuffer,LFORateRightBuffer,LFODepthRightBuffer,WetBuffer,DryBuffer,SamplesCount);
      end;
{$endif}
     end;
     coCompressor:begin
{$ifdef BR808COMPRESSOR}
      if Channel^.Instrument^.ChannelCompressor.Mode<>cmNONE then begin
       if not Channel^.HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
        Channel^.HasBuffer:=true;
       end;
       if not Track^.Channels[Channel^.SideIn].HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.SideIn],SamplesCount*sizeof(TSynthBufferSample),#0);
        Track^.Channels[Channel^.SideIn].HasBuffer:=true;
       end;
       WindowBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
       SoftHardKneeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
       ThresholdBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
       RatioBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
       AttackBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
       ReleaseBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
       OutGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,6];
       SynthProcessModulationMatrix(Track,ThreadNumber,WindowBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorWindowSize,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,SoftHardKneeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorSoftHardKnee,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,ThresholdBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorThreshold,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,RatioBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorRatio,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,AttackBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorAttack,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,ReleaseBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorRelease,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessModulationMatrix(Track,ThreadNumber,OutGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelCompressorOutGain,0,SamplesCount,Track^.F1D0Buffer);
       SynthProcessCompressor(Track,@Channel^.Instrument^.ChannelCompressor,@Channel^.ChannelCompressorData,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.ChannelBuffer[Channel^.SideIn],Channel^.CompressorBuffer,WindowBuffer,SoftHardKneeBuffer,ThresholdBuffer,RatioBuffer,AttackBuffer,ReleaseBuffer,OutGainBuffer,SamplesCount,Track^.InternalSampleRate);
      end;
{$endif}
     end;
     coSpeech:begin
{$ifdef BR808SPEECH}
      if Channel^.Instrument^.ChannelSpeech.Active then begin
       if not Channel^.HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
        Channel^.HasBuffer:=true;
       end;
       SpeechTextNumberBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
       SpeechSpeedBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
       SpeechColorBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
       SpeechNoiseGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
       SpeechGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
       SpeechPositionBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
       SpeechCascadeGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,6];
       SpeechParallelGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,7];
       SpeechAspirationGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,8];
       SpeechFricationGainBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,9];
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechTextNumberBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechTextNumber,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechSpeedBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechSpeed,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechColorBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechColor,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechNoiseGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechNoiseGain,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechGain,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechPositionBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechPosition,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechCascadeGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechCascadeGain,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechParallelGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechParallelGain,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechAspirationGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechAspirationGain,0,1,nil);
       SynthProcessModulationMatrix(Track,ThreadNumber,SpeechFricationGainBuffer,Channel^.Instrument,Channel,NewestVoice,mmoChannelSpeechFricationGain,0,1,nil);
       if assigned(SpeechTextNumberBuffer) then begin
        Channel^.SpeechInstance.TextNumber:=SoftTRUNC((SpeechTextNumberBuffer^*Channel^.Instrument^.ChannelSpeech.TextNumber)+0.5);
       end else begin
        Channel^.SpeechInstance.TextNumber:=Channel^.Instrument^.ChannelSpeech.TextNumber;
       end;
       Channel^.SpeechInstance.TextNumber:=Channel^.SpeechInstance.TextNumber and $7f;
       if Channel^.SpeechInstance.SegmentList.List<>@Track^.SpeechSegmentLists[Channel^.Patch and $7f,Channel^.SpeechInstance.TextNumber and $7f] then begin
        Channel^.SpeechInstance.SegmentList.List:=@Track^.SpeechSegmentLists[Channel^.Patch and $7f,Channel^.SpeechInstance.TextNumber and $7f];
        Channel^.SpeechInstance.SegmentList.Position:=-1;
        Channel^.SpeechInstance.FrameRemain:=0;
        Channel^.SpeechInstance.TimeRemain:=0;
       end;
       if assigned(SpeechPositionBuffer) then begin
        vi:=SoftTRUNC((SpeechPositionBuffer^*127)+0.5);
        case vi of
         1:begin
          Channel^.SpeechInstance.SegmentList.Position:=-1;
          Channel^.SpeechInstance.FrameRemain:=0;
          Channel^.SpeechInstance.TimeRemain:=0;
         end;
         2..127:begin
          Channel^.SpeechInstance.SegmentList.Position:=vi-2;
          Channel^.SpeechInstance.FrameRemain:=0;
          Channel^.SpeechInstance.TimeRemain:=0;
         end;
        end;
       end;
       if Channel^.SpeechInstance.SegmentList.Position=-1 then begin
        Channel^.SpeechInstance.FrameLength:=Channel^.Instrument^.ChannelSpeech.FrameLength;
        Channel^.SpeechInstance.Speed:=Channel^.Instrument^.ChannelSpeech.Speed;
        Channel^.SpeechInstance.Color:=Channel^.Instrument^.ChannelSpeech.Color;
        Channel^.SpeechInstance.NoiseGain:=Channel^.Instrument^.ChannelSpeech.NoiseGain;
        Channel^.SpeechInstance.Gain:=Channel^.Instrument^.ChannelSpeech.Gain;
       end;
       if assigned(SpeechSpeedBuffer) then begin
        Channel^.SpeechInstance.Speed:=Channel^.Instrument^.ChannelSpeech.Speed+SoftTRUNC((SpeechSpeedBuffer^*127)+0.5);
       end else begin
        Channel^.SpeechInstance.Speed:=Channel^.Instrument^.ChannelSpeech.Speed;
       end;
       if assigned(SpeechColorBuffer) then begin
        Channel^.SpeechInstance.Color:=Channel^.Instrument^.ChannelSpeech.Color+((SoftTRUNC((SpeechColorBuffer^*127)+0.5)-64)*2);
       end else begin
        Channel^.SpeechInstance.Color:=Channel^.Instrument^.ChannelSpeech.Color;
       end;
       if assigned(SpeechNoiseGainBuffer) then begin
        Channel^.SpeechInstance.NoiseGain:=SoftTRUNC((SpeechNoiseGainBuffer^*Channel^.Instrument^.ChannelSpeech.NoiseGain)+0.5);
       end else begin
        Channel^.SpeechInstance.NoiseGain:=Channel^.Instrument^.ChannelSpeech.NoiseGain;
       end;
       if assigned(SpeechGainBuffer) then begin
        Channel^.SpeechInstance.Gain:=SoftTRUNC((SpeechGainBuffer^*Channel^.Instrument^.ChannelSpeech.Gain)+0.5);
       end else begin
        Channel^.SpeechInstance.Gain:=Channel^.Instrument^.ChannelSpeech.Gain;
       end;
       if assigned(SpeechCascadeGainBuffer) then begin
        Channel^.SpeechInstance.CascadeGain:=SoftTRUNC((SpeechCascadeGainBuffer^*Channel^.Instrument^.ChannelSpeech.CascadeGain)+0.5);
       end else begin
        Channel^.SpeechInstance.CascadeGain:=Channel^.Instrument^.ChannelSpeech.CascadeGain;
       end;
       if assigned(SpeechParallelGainBuffer) then begin
        Channel^.SpeechInstance.ParallelGain:=SoftTRUNC((SpeechParallelGainBuffer^*Channel^.Instrument^.ChannelSpeech.ParallelGain)+0.5);
       end else begin
        Channel^.SpeechInstance.ParallelGain:=Channel^.Instrument^.ChannelSpeech.ParallelGain;
       end;
       if assigned(SpeechAspirationGainBuffer) then begin
        Channel^.SpeechInstance.AspirationGain:=SoftTRUNC((SpeechAspirationGainBuffer^*Channel^.Instrument^.ChannelSpeech.AspirationGain)+0.5);
       end else begin
        Channel^.SpeechInstance.AspirationGain:=Channel^.Instrument^.ChannelSpeech.AspirationGain;
       end;
       if assigned(SpeechFricationGainBuffer) then begin
        Channel^.SpeechInstance.FricationGain:=SoftTRUNC((SpeechFricationGainBuffer^*Channel^.Instrument^.ChannelSpeech.FricationGain)+0.5);
       end else begin
        Channel^.SpeechInstance.FricationGain:=Channel^.Instrument^.ChannelSpeech.FricationGain;
       end;
       if assigned(NewestVoice) then begin
        Channel^.SpeechInstance.Active:=not Channel^.KeyOff;
        SynthSpeechProcess(Track,Channel^.SpeechInstance,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount);
       end else begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
       end;
      end;
{$endif}
     end;
     coPitchShifter:begin
{$ifdef BR808PITCHSHIFTER}
      if Channel^.Instrument^.ChannelPitchShifter.Active then begin
       if not Channel^.HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
        Channel^.HasBuffer:=true;
       end;
       if assigned(NewestVoice) then begin
        TuneBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
        FineTuneBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
        SynthProcessModulationMatrix(Track,ThreadNumber,TuneBuffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelPitchShifterTune,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,FineTuneBuffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelPitchShifterFineTune,0,SamplesCount,Track^.F1D0Buffer);
       end else begin
        TuneBuffer:=Track^.F1D0Buffer;
        FineTuneBuffer:=Track^.F1D0Buffer;
       end;
       SynthProcessPitchShifter(Track,@Channel^.Instrument^.ChannelPitchShifter,@Channel^.ChannelPitchShifterData,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],TuneBuffer,FineTuneBuffer,SamplesCount);
      end;
{$endif}
     end;
     coEQ:begin
{$ifdef BR808EQ}
      if Channel^.Instrument^.ChannelEQ.Active then begin
       if not Channel^.HasBuffer then begin
        FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
        Channel^.HasBuffer:=true;
       end;
       if assigned(NewestVoice) then begin
        Gain0Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
        Gain1Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,1];
        Gain2Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,2];
        Gain3Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,3];
        Gain4Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,4];
        Gain5Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,5];
        Gain6Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,6];
        Gain7Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,7];
        Gain8Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,8];
        Gain9Buffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,9];
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain0Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain0,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain1Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain1,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain2Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain2,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain3Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain3,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain4Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain4,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain5Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain5,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain6Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain6,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain7Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain7,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain8Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain8,0,SamplesCount,Track^.F1D0Buffer);
        SynthProcessModulationMatrix(Track,ThreadNumber,Gain9Buffer,NewestVoice^.Instrument,Channel,NewestVoice,mmoChannelEQGain9,0,SamplesCount,Track^.F1D0Buffer);
       end else begin
        Gain0Buffer:=Track^.F1D0Buffer;
        Gain1Buffer:=Track^.F1D0Buffer;
        Gain2Buffer:=Track^.F1D0Buffer;
        Gain3Buffer:=Track^.F1D0Buffer;
        Gain4Buffer:=Track^.F1D0Buffer;
        Gain5Buffer:=Track^.F1D0Buffer;
        Gain6Buffer:=Track^.F1D0Buffer;
        Gain7Buffer:=Track^.F1D0Buffer;
        Gain8Buffer:=Track^.F1D0Buffer;
        Gain9Buffer:=Track^.F1D0Buffer;
       end;
       SynthProcessEQ(Track,@Channel^.Instrument^.ChannelEQ,@Channel^.ChannelEQData,@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Gain0Buffer,Gain1Buffer,Gain2Buffer,Gain3Buffer,Gain4Buffer,Gain5Buffer,Gain6Buffer,Gain7Buffer,Gain8Buffer,Gain9Buffer,SamplesCount);
      end;
{$endif}
     end;
    end;
   end;

  end;

  if Channel^.HasBuffer then begin

   VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
   SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoGlobalChannelVolume,0,SamplesCount,nil);
   if assigned(VolumeBuffer) then begin
    if assigned(Channel^.Instrument) then begin
     Value:=sqr(Channel^.Instrument^.ChannelVolume*fci255);
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthFloatBufferMulFloatSSE(VolumeBuffer,Value,SamplesCount);
     end else{$endif} begin
      SynthFloatBufferMulFloat(VolumeBuffer,Value,SamplesCount);
     end;
    end;
    SynthAmplifyChannelBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],VolumeBuffer,SamplesCount);
    Channel^.LastVolumeFactor:=psingles(VolumeBuffer)^[SamplesCount-1];
   end else begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthSampleBufferMulFloatSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Channel^.LastVolumeFactor,SamplesCount);
    end else{$endif} begin
     SynthSampleBufferMulFloat(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Channel^.LastVolumeFactor,SamplesCount);
    end;
   end;

   if Track^.ScanPeaks then begin
    SrcBuf:=@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number];
    for Counter:=1 to SamplesCount do begin
     Channel^.Peaks.Left:=Channel^.Peaks.Left+((sqr(SrcBuf^.Left)-Channel^.Peaks.Left)*Track^.ScanPeakFactor);
     Channel^.Peaks.Right:=Channel^.Peaks.Right+((sqr(SrcBuf^.Right)-Channel^.Peaks.Right)*Track^.ScanPeakFactor);
     longword(pointer(@Channel^.Peaks.Left)^):=longword(pointer(@Channel^.Peaks.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Channel^.Peaks.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@Channel^.Peaks.Right)^):=longword(pointer(@Channel^.Peaks.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Channel^.Peaks.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    end;
   end;

{$ifdef MultiOutput}
   Move(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Track^.WorkBuffers^.ChannelOutRouteBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample));
{$endif}

   if assigned(Channel^.Instrument) then begin
    if Channel^.Instrument^.GlobalReverb<>0 then begin
     Value:=sqr(Channel^.Instrument^.GlobalReverb*fci255);
     VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
     SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoGlobalReverb,0,SamplesCount,Track^.F1D0Buffer);
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthCopyAndMulBufferSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXReverbBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end else{$endif} begin
      SynthCopyAndMulBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXReverbBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end;
     Channel^.HaveAUXReverb:=true;
    end;
    if Channel^.Instrument^.GlobalDelay<>0 then begin
     Value:=sqr(Channel^.Instrument^.GlobalDelay*fci255);
     VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
     SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoGlobalDelay,0,SamplesCount,Track^.F1D0Buffer);
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthCopyAndMulBufferSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXDelayBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end else{$endif} begin
      SynthCopyAndMulBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXDelayBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end;
     Channel^.HaveAUXDelay:=true;
    end;
    if Channel^.Instrument^.GlobalChorusFlanger<>0 then begin
     Value:=sqr(Channel^.Instrument^.GlobalChorusFlanger*fci255);
     VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
     SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoGlobalChorusFlanger,0,SamplesCount,Track^.F1D0Buffer);
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthCopyAndMulBufferSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXChorusFlangerBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end else{$endif} begin
      SynthCopyAndMulBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],@Track^.WorkBuffers^.AUXChorusFlangerBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end;
     Channel^.HaveAUXChorusFlanger:=true;
    end;
    begin
     Value:=sqr(Channel^.Instrument^.GlobalOutput*fci255);
     VolumeBuffer:=@Track^.WorkBuffers^.ModulationMatrixBuffers[ThreadNumber,0];
     SynthProcessModulationMatrix(Track,ThreadNumber,VolumeBuffer,Channel^.Instrument,Channel,NewestVoice,mmoGlobalOutput,0,SamplesCount,Track^.F1D0Buffer);
{$ifdef UseSSE}
     if SSEExt and Track^.UseSSE then begin
      SynthOnlyMulBufferSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end else{$endif} begin
      SynthOnlyMulBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],VolumeBuffer,Value,SamplesCount);
     end;
    end; 
   end;

  end else begin
   if Track^.ScanPeaks then begin
    for Counter:=1 to SamplesCount do begin
     Channel^.Peaks.Left:=Channel^.Peaks.Left-(Channel^.Peaks.Left*Track^.ScanPeakFactor);
     Channel^.Peaks.Right:=Channel^.Peaks.Right-(Channel^.Peaks.Right*Track^.ScanPeakFactor);
     longword(pointer(@Channel^.Peaks.Left)^):=longword(pointer(@Channel^.Peaks.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Channel^.Peaks.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@Channel^.Peaks.Right)^):=longword(pointer(@Channel^.Peaks.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Channel^.Peaks.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    end;
   end;
   if Channel^.MustHaveBuffer then begin
    FillChar(Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],SamplesCount*sizeof(TSynthBufferSample),#0);
    Channel^.HasBuffer:=true;
   end;
  end;

  InterlockedExchange(longint(Channel^.Ready),longint(longbool(true)));
 end;
end;

procedure SynthProcessChannelMix(Track:PSynthTrack;Channel:PSynthChannel;Buffer:PSynthBufferSample;SamplesCount:longint);
begin
 if Channel^.HasBuffer then begin
  if Channel^.HaveAUXReverb then begin
   if Track^.HasReverb then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthMixToBufferSSE(@Track^.WorkBuffers^.AUXReverbBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalReverbBuffer,SamplesCount);
    end else{$endif} begin
     SynthMixToBuffer(@Track^.WorkBuffers^.AUXReverbBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalReverbBuffer,SamplesCount);
    end;
   end else begin
    Move(Track^.WorkBuffers^.AUXReverbBuffer[Channel^.Number],Track^.WorkBuffers^.GlobalReverbBuffer,SamplesCount*sizeof(TSynthBufferSample));
    Track^.HasReverb:=true;
   end;
  end;
  if Channel^.HaveAUXDelay then begin
   if Track^.HasDelay then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthMixToBufferSSE(@Track^.WorkBuffers^.AUXDelayBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalDelayBuffer,SamplesCount);
    end else{$endif} begin
     SynthMixToBuffer(@Track^.WorkBuffers^.AUXDelayBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalDelayBuffer,SamplesCount);
    end;
   end else begin
    Move(Track^.WorkBuffers^.AUXDelayBuffer[Channel^.Number],Track^.WorkBuffers^.GlobalDelayBuffer,SamplesCount*sizeof(TSynthBufferSample));
    Track^.HasDelay:=true;
   end;
  end;
  if Channel^.HaveAUXChorusFlanger then begin
   if Track^.HasChorusFlanger then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthMixToBufferSSE(@Track^.WorkBuffers^.AUXChorusFlangerBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalChorusFlangerBuffer,SamplesCount);
    end else{$endif} begin
     SynthMixToBuffer(@Track^.WorkBuffers^.AUXChorusFlangerBuffer[Channel^.Number],@Track^.WorkBuffers^.GlobalChorusFlangerBuffer,SamplesCount);
    end;
   end else begin
    Move(Track^.WorkBuffers^.AUXChorusFlangerBuffer[Channel^.Number],Track^.WorkBuffers^.GlobalChorusFlangerBuffer,SamplesCount*sizeof(TSynthBufferSample));
    Track^.HasChorusFlanger:=true;
   end;
  end;
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthMixToBufferSSE(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Buffer,SamplesCount);
  end else{$endif} begin
   SynthMixToBuffer(@Track^.WorkBuffers^.ChannelBuffer[Channel^.Number],Buffer,SamplesCount);
  end;
 end;
end;

procedure SynthJobManagerProcessThread(Track:PSynthTrack;ThreadNumber:longint);
var JobManager:PSynthJobManager;
    Job:PSynthJob;
    Index:longint;
begin
 JobManager:=@Track^.JobManager;
 while true do begin
  Index:=InterlockedDecrement(JobManager^.JobQueueIndex)+1;
  if Index>=0 then begin
   Job:=@JobManager^.Jobs[Index];
   case Job^.Mode of
    sjmCHANNELINIT:begin
     SynthProcessChannelInit(Job^.Track,ThreadNumber,Job^.Channel,Job^.Samples,Job^.NewTick);
    end;
    sjmVOICE:begin
     SynthProcessVoice(Job^.Track,ThreadNumber,Job^.Voice,Job^.Samples,Job^.NewTick);
    end;
    sjmCHANNELFINALIZE:begin
     SynthProcessChannelFinalize(Job^.Track,ThreadNumber,Job^.Channel,Job^.Samples,Job^.NewTick);
    end;
   end;
  end else begin
   break;
  end;
 end;
end;

{$ifdef WIN32ReallyPlain}
procedure SynthJobThread(JobThread:PSynthJobThread); stdcall;
{$else}
function SynthJobThread(JobThread:PSynthJobThread):longint;
{$endif}
{$ifdef cpu386}
var OldFCW:word;
{$endif}
{$ifdef UseSSE}
var OldSIMDCtrl:longword;
{$endif}
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   stmxcsr dword ptr OldSIMDCtrl
  end;
  SIMDSetFlags;
 end;
{$endif}
 InterlockedIncrement(JobThread^.Track^.Threads);
 while not JobThread^.Track^.ThreadsTerminated do begin
{$ifdef fpc}
  RTLEventWaitFor(JobThread^.Event);
{$else}
  WaitForSingleObject(JobThread^.Event,INFINITE);
{$endif}
  if JobThread^.Track^.ThreadsTerminated then begin
   break;
  end else begin
{$ifdef cpu386}
   asm
    fldcw word ptr SynthFCW
   end;
{$endif}
{$ifdef UseSSE}
   if SSEExt then begin
    SIMDSetFlags;
   end;
{$endif}
   SynthJobManagerProcessThread(JobThread^.Track,JobThread^.ThreadNumber);
{$ifdef fpc}
   RTLEventSetEvent(JobThread^.DoneEvent);
{$else}
   SetEvent(JobThread^.DoneEvent);
{$endif}
  end;
 end;
 InterlockedDecrement(JobThread^.Track^.Threads);
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   ldmxcsr dword ptr OldSIMDCtrl
  end;
 end;
{$endif}
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
{$ifdef WIN32ReallyPlain}
 ExitThread(0);
{$else}
 EndThread(0);
 result:=0;
{$endif}
end;

procedure SynthJobCreateThreads(Track:PSynthTrack);
var i,j:longint;
{$ifdef win32}
    sinfo:SYSTEM_INFO;
    dwProcessAffinityMask,dwSystemAffinityMask:{$if declared(NativeUInt)}NativeUInt{$else}longword{$ifend};
 {$endif}
    Cores:array[0..MaxThreads-1] of longint;
begin
{$ifdef win32}
 GetSystemInfo(sinfo);
 GetProcessAffinityMask(GetCurrentProcess,dwProcessAffinityMask,dwSystemAffinityMask);
 j:=0;
 for i:=0 to sinfo.dwNumberOfProcessors-1 do begin
  if (dwProcessAffinityMask and (1 shl i))<>0 then begin
   Cores[j]:=i;
   inc(j);
   if j>=MaxThreads then begin
    break;
   end;
  end;
 end;
 Track^.JobManager.CountThreads:=j;
 if Track^.JobManager.CountThreads<1 then begin
  Track^.JobManager.CountThreads:=1;
 end else if Track^.JobManager.CountThreads>MaxThreads then begin
  Track^.JobManager.CountThreads:=MaxThreads;
 end;
{$else}
 Cores[0]:=0;
 Track^.JobManager.CountThreads:=1;
{$endif}
 Track^.UseMultithreading:=Track^.JobManager.CountThreads>1;
//Track^.JobManager.CountThreads:=1;
 for i:=0 to Track^.JobManager.CountThreads-1 do begin
  Track^.JobManager.Threads[i].Track:=Track;
  Track^.JobManager.Threads[i].ThreadNumber:=i;
  Track^.JobManager.Threads[i].ThreadHandle:=0;
  Track^.JobManager.Threads[i].ThreadID:=0;
{$ifdef win32}
  Track^.JobManager.DoneEventHandles[i]:=0;
{$endif}
 end;
 if Track^.JobManager.CountThreads>1 then begin
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
   Track^.JobManager.Threads[i].Event:={$ifdef fpc}RTLEventCreate{$else}CreateEventA(nil,false,false,''){$endif};
   Track^.JobManager.Threads[i].DoneEvent:={$ifdef fpc}RTLEventCreate{$else}CreateEventA(nil,false,false,''){$endif};
{$ifdef win32}
   Track^.JobManager.DoneEventHandles[i]:=Track^.JobManager.Threads[i].DoneEvent;
{$endif}
{$ifdef win32ReallyPlain}
   Track^.JobManager.Threads[i].ThreadHandle:=CreateThread(nil,0,@SynthJobThread,@Track^.JobManager.Threads[i],0,Track^.JobManager.Threads[i].ThreadID);
{$else}
   Track^.JobManager.Threads[i].ThreadHandle:=BeginThread(nil,0,@SynthJobThread,@Track^.JobManager.Threads[i],0,Track^.JobManager.Threads[i].ThreadID);
{$endif}
{$ifdef win32}
   SetThreadPriority(Track^.JobManager.Threads[i].ThreadHandle,THREAD_PRIORITY_TIME_CRITICAL);
   if GetThreadPriority(Track^.JobManager.Threads[i].ThreadHandle)<>THREAD_PRIORITY_TIME_CRITICAL then begin
    // Fallback for no adminstrator windows users
    SetThreadPriority(Track^.JobManager.Threads[i].ThreadHandle,THREAD_PRIORITY_HIGHEST);
    if GetThreadPriority(Track^.JobManager.Threads[i].ThreadHandle)<>THREAD_PRIORITY_HIGHEST then begin
     SetThreadPriority(Track^.JobManager.Threads[i].ThreadHandle,THREAD_PRIORITY_ABOVE_NORMAL);
    end;
   end; 
   SetThreadIdealProcessor(Track^.JobManager.Threads[i].ThreadHandle,Cores[i]);
// SetThreadAffinityMask(Track^.JobManager.Threads[i].ThreadHandle,1 shl Cores[i]);
{$endif}
  end;
 end;
end;

procedure SynthJobWakeThreads(Track:PSynthTrack);
var i:longint;
begin
 if Track^.JobManager.CountThreads>1 then begin
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
{$ifdef fpc}
   RTLEventSetEvent(Track^.JobManager.Threads[i].Event);
{$else}
   SetEvent(Track^.JobManager.Threads[i].Event);
{$endif}
  end;
 end;
end;

procedure SynthJobWaitThreads(Track:PSynthTrack);
{$ifdef fpc}
var i:longint;
{$else}
{$ifndef win32}
var i:longint;
{$endif}
{$endif}
begin
 if Track^.JobManager.CountThreads>1 then begin
{$ifdef fpc}
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
   RTLEventWaitFor(Track^.JobManager.Threads[i].DoneEvent);
  end;
{$else}
{$ifdef win32}
  WaitForMultipleObjects(Track^.JobManager.CountThreads,@Track^.JobManager.DoneEventHandles[0],true,INFINITE);
{$else}
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
   WaitForSingleObject(Track^.JobManager.Threads[i].DoneEvent,INFINITE);
  end;
{$endif}
{$endif}
 end;
end;

procedure SynthJobFreeThreads(Track:PSynthTrack);
var i:longint;
begin
 if Track^.JobManager.CountThreads>1 then begin
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
{$ifdef win32}
   WaitForSingleObject(Track^.JobManager.Threads[i].ThreadHandle,25);
{$endif}
{$ifdef fpc}
   System.KillThread(Track^.JobManager.Threads[i].ThreadID);
{$else}
   TerminateThread(Track^.JobManager.Threads[i].ThreadHandle,0);
{$endif}
{$ifdef win32}
   if Track^.JobManager.Threads[i].ThreadHandle<>0 then begin
    CloseHandle(Track^.JobManager.Threads[i].ThreadHandle);
   end;
{$endif}
  end;
  for i:=0 to Track^.JobManager.CountThreads-1 do begin
{$ifdef fpc}
   RTLEventDestroy(Track^.JobManager.Threads[i].Event);
   RTLEventDestroy(Track^.JobManager.Threads[i].DoneEvent);
{$else}
   CloseHandle(Track^.JobManager.Threads[i].Event);
   CloseHandle(Track^.JobManager.Threads[i].DoneEvent);
{$endif}
  end;
 end;
end;

procedure SynthJobManagerInitSynthProcessChannelInit(Track:PSynthTrack;SamplesCount:longint;NewTick:boolean);
var i:longint;
begin
 for i:=0 to NumberOfChannels-1 do begin
  Track^.JobManager.Jobs[i].Mode:=sjmCHANNELINIT;
  Track^.JobManager.Jobs[i].Track:=Track;
  Track^.JobManager.Jobs[i].Samples:=SamplesCount;
  Track^.JobManager.Jobs[i].NewTick:=NewTick;
  Track^.JobManager.Jobs[i].Channel:=@Track^.Channels[i];
 end;
 Track^.JobManager.CountJobs:=NumberOfChannels;
end;

procedure SynthJobManagerInitSynthProcessVoices(Track:PSynthTrack;SamplesCount:longint;NewTick:boolean);
var i,j:longint;
    Voice:PSynthVoice;
begin
 j:=0;
 for i:=0 to NumberOfVoices-1 do begin
  Voice:=@Track^.Voices[i];
  if Voice^.Active and (Voice^.Note>=0) then begin
   Voice^.Number:=i;
   Track^.JobManager.Jobs[j].Mode:=sjmVOICE;
   Track^.JobManager.Jobs[j].Track:=Track;
   Track^.JobManager.Jobs[j].Samples:=SamplesCount;
   Track^.JobManager.Jobs[j].NewTick:=NewTick;
   Track^.JobManager.Jobs[j].Channel:=Voice^.Channel;
   Track^.JobManager.Jobs[j].Voice:=Voice;
   inc(j);
  end;
 end;
 Track^.JobManager.CountJobs:=j;
end;

procedure SynthJobManagerInitSynthProcessChannelFinalize(Track:PSynthTrack;SamplesCount:longint;NewTick:boolean);
var i,j:longint;
begin
 j:=0;
 for i:=0 to NumberOfChannels-1 do begin
  if not Track^.Channels[i].Ready then begin
   Track^.JobManager.Jobs[j].Mode:=sjmCHANNELFINALIZE;
   Track^.JobManager.Jobs[j].Track:=Track;
   Track^.JobManager.Jobs[j].Samples:=SamplesCount;
   Track^.JobManager.Jobs[j].NewTick:=NewTick;
   Track^.JobManager.Jobs[j].Channel:=@Track^.Channels[i];
   inc(j);
  end;
 end;
 Track^.JobManager.CountJobs:=j;
end;

procedure SynthJobManagerProcess(Track:PSynthTrack);
var JobManager:PSynthJobManager;
begin
 JobManager:=@Track^.JobManager;
 if JobManager^.CountJobs>0 then begin
  Track^.JobManager.JobQueueIndex:=JobManager^.CountJobs-1;
  if Track^.UseMultithreading and (Track^.JobManager.CountThreads>1) then begin
   SynthJobWakeThreads(Track);
   SynthJobWaitThreads(Track);
   while JobManager^.JobQueueIndex>=0 do begin
{$ifdef win32}
    sleep(0);
{$endif}
   end;
  end else begin
   SynthJobManagerProcessThread(Track,0);
  end;
  JobManager^.CountJobs:=0;
 end;
end;

procedure SynthProcessDSP(Track:PSynthTrack;var Sample:PSynthBufferSample;SamplesCount:longint;NewTick:boolean);
var ChannelCounter,Counter,Remain:longint;
    Voice:PSynthVoice;
    Value,Left,Right:single;
    Buf:PSynthBufferSample;
begin
 begin;
  Value:=Track^.Global.RampingLen*Track^.InternalSampleRateRampingFactor;
  Track^.CurrentRampingSamples:=SoftTRUNC(Value)+ord(frac(Value)>0);
  if Track^.CurrentRampingSamples<0 then begin
   Track^.CurrentRampingSamples:=0;
  end;
 end;
 Track^.HasReverb:=false;
 Track^.HasDelay:=false;
 Track^.HasChorusFlanger:=false;
 for ChannelCounter:=0 to NumberOfChannels-1 do begin
  Track^.Channels[ChannelCounter].CountVoices:=0;
  Track^.Channels[ChannelCounter].MustHaveBuffer:=false;
 end;
 for Counter:=0 to NumberOfVoices-1 do begin
  Voice:=@Track^.Voices[Counter];
  Voice^.Number:=Counter;
  Track^.VoiceBufferOut[Counter]:=nil;
  if assigned(Voice^.Channel) then begin
   Voice^.Channel^.Voices[Voice^.Channel.CountVoices]:=@Track^.Voices[Counter];
   inc(Voice^.Channel^.CountVoices);
  end;
 end;
 for ChannelCounter:=0 to NumberOfChannels-1 do begin
  SynthPreprocessChannel(Track,0,@Track^.Channels[ChannelCounter],SamplesCount,NewTick);
 end;
 begin
  begin
   SynthJobManagerInitSynthProcessChannelInit(Track,SamplesCount,NewTick);
   SynthJobManagerProcess(Track);
  end;
  begin
   SynthJobManagerInitSynthProcessVoices(Track,SamplesCount,NewTick);
   SynthJobManagerProcess(Track);
  end;
  begin
   for Counter:=1 to NumberOfChannels do begin
    SynthJobManagerInitSynthProcessChannelFinalize(Track,SamplesCount,NewTick);
    SynthJobManagerProcess(Track);
    begin
     Remain:=NumberOfChannels;
     for ChannelCounter:=0 to NumberOfChannels-1 do begin
      if Track^.Channels[ChannelCounter].Ready then begin
       dec(Remain);
      end;
     end;
     if Remain=0 then begin
      break;
     end;
    end;
   end;
  end;
  for ChannelCounter:=0 to NumberOfChannels-1 do begin
   if Track^.Channels[ChannelCounter].Ready then begin
    SynthProcessChannelMix(Track,@Track^.Channels[ChannelCounter],Sample,SamplesCount);
   end;
  end;
 end;
//SynthCleanBuffer(Sample,SamplesCount*2);
{$ifdef BR808REVERB}
 if Track^.Global.Reverb.Active then begin
  if not Track^.HasReverb then begin
   FillChar(Track^.WorkBuffers^.GlobalReverbBuffer,SamplesCount*sizeof(TSynthBufferSample),#0);
  end;
  SynthProcessReverb(Track,@Track^.Global.Reverb,@Track^.GlobalData.Reverb,@Track^.WorkBuffers^.GlobalReverbBuffer,SamplesCount);
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthMixToBufferSSE(@Track^.WorkBuffers^.GlobalReverbBuffer,Sample,SamplesCount);
  end else{$endif} begin
   SynthMixToBuffer(@Track^.WorkBuffers^.GlobalReverbBuffer,Sample,SamplesCount);
  end;
 end;
{$endif}
{$ifdef BR808DELAY}
 if Track^.Global.Delay.Active then begin
  if not Track^.HasDelay then begin
   FillChar(Track^.WorkBuffers^.GlobalDelayBuffer,SamplesCount*sizeof(TSynthBufferSample),#0);
  end;
  SynthProcessDelay(Track,@Track^.Global.Delay,@Track^.GlobalData.Delay,@Track^.WorkBuffers^.GlobalDelayBuffer,Track^.GlobalData.DelayBuffer,Track^.ZeroBuffer,Track^.F1D0Buffer,Track^.ZeroBuffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,SamplesCount);
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthMixToBufferSSE(@Track^.WorkBuffers^.GlobalDelayBuffer,Sample,SamplesCount);
  end else{$endif} begin
   SynthMixToBuffer(@Track^.WorkBuffers^.GlobalDelayBuffer,Sample,SamplesCount);
  end;
 end;
{$endif}
{$ifdef BR808CHORUSFLANGER}
 if Track^.Global.ChorusFlanger.Active then begin
  if not Track^.HasChorusFlanger then begin
   FillChar(Track^.WorkBuffers^.GlobalChorusFlangerBuffer,SamplesCount*sizeof(TSynthBufferSample),#0);
  end;
  SynthProcessChorusFlanger(Track,@Track^.Global.ChorusFlanger,@Track^.GlobalData.ChorusFlanger,@Track^.WorkBuffers^.GlobalChorusFlangerBuffer,Track^.GlobalData.ChorusFlangerBuffer,Track^.ZeroBuffer,Track^.F1D0Buffer,Track^.ZeroBuffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,SamplesCount);
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthMixToBufferSSE(@Track^.WorkBuffers^.GlobalChorusFlangerBuffer,Sample,SamplesCount);
  end else{$endif} begin
   SynthMixToBuffer(@Track^.WorkBuffers^.GlobalChorusFlangerBuffer,Sample,SamplesCount);
  end;
 end;
{$endif}
 for Counter:=low(TSynthGlobalOrder) to high(TSynthGlobalOrder) do begin
  case Track^.Global.Order[Counter] of
   goPITCHSHIFTER:begin
{$ifdef BR808PITCHSHIFTER}
    if Track^.Global.PitchShifter.Active then begin
     SynthProcessPitchShifter(Track,@Track^.Global.PitchShifter,@Track^.GlobalData.PitchShifter,Sample,Track^.F1D0Buffer,Track^.F1D0Buffer,SamplesCount);
    end;
{$endif}
   end;
   goENDFILTER:begin
{$ifdef BR808ENDFILTER}
    if Track^.Global.EndFilter.Active then begin
     SynthProcessEndFilter(Track,@Track^.Global.EndFilter,@Track^.GlobalData.EndFilter,Sample,SamplesCount);
    end;
{$endif}
   end;
   goEQ:begin
{$ifdef BR808EQ}
    if Track^.Global.EQ.Active then begin
     SynthProcessEQ(Track,@Track^.Global.EQ,@Track^.GlobalData.EQ,Sample,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,SamplesCount);
    end;
{$endif}
   end;
   goCOMPRESSOR:begin
{$ifdef BR808COMPRESSOR}
    if Track^.Global.Compressor.Mode<>cmNONE then begin
     SynthProcessCompressor(Track,@Track^.Global.Compressor,@Track^.GlobalData.Compressor,Sample,Sample,Track^.GlobalData.CompressorBuffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,SamplesCount,Track^.InternalSampleRate);
    end;
{$endif}
   end;
  end;
 end;
 begin
  if Track^.MasterBalance<>8192 then begin
   Value:=Track^.MasterBalance*fCI16384;
   Left:=(1-Value)*0.5;
   Right:=Value*0.5;
   Buf:=Sample;
   for Counter:=1 to SamplesCount do begin
    Buf^.Left:=Buf^.Left*Left;
    Buf^.Right:=Buf^.Right*Right;
    longword(pointer(@Buf^.Left)^):=longword(pointer(@Buf^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    longword(pointer(@Buf^.Right)^):=longword(pointer(@Buf^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@Buf^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
    inc(Buf);
   end;
  end;
  if Track^.MasterVolume<>16383 then begin
 {$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthSampleBufferMulFloatSSE(Sample,Track^.MasterVolume*fCI16383,SamplesCount);
   end else{$endif} begin
    SynthSampleBufferMulFloat(Sample,Track^.MasterVolume*fCI16383,SamplesCount);
   end;
  end;
 end;
end;

function SynthProcessPart(Track:PSynthTrack;var Sample:PSynthBufferSample;Remain:longint):longint;
var SamplesRemain,FillRemain,ToFill:longint;
    DifferenceTicks{$ifndef TimingHandlingShortVersion}{$ifndef cpu386},SamplesFrac{$endif}{$endif}:longword;
    NewTick:boolean;
    Event:PSynthEvent;
    SamplesRemainAdd:int64;
begin
 NewTick:=PInt64(@Track^.SamplesRemain)^.Hi<=0;
 if NewTick then begin
  inc(Track^.Time,Track^.DifferenceTicksIncrement);
  while assigned(Track^.CurrentEvent) and (Track^.Time>=Track^.CurrentEvent^.Time) do begin
   Event:=Track^.CurrentEvent;
   Track^.CurrentEvent:=Event^.Next;
   Event^.SampleIndex:=Track^.ProcessedSamples;
   if Track^.OmniMode or (((Event^.Command shr 4)=$f) or (Track^.OmniChannel=(Event^.Command and $f))) then begin
    if assigned(Track^.EventHook) then begin
     Track^.EventHook(Track,Event);
    end;
    SynthProcessEvent(Track,Event);
   end;
  end;
  if assigned(Track^.CurrentEvent) and (Track^.CurrentEvent^.Time>=Track^.Time) then begin
   DifferenceTicks:=Track^.CurrentEvent^.Time-Track^.Time;
   if DifferenceTicks=0 then begin
    DifferenceTicks:=1;
   end;
  end else begin
   if Track^.Looping then begin
    Track^.CurrentEvent:=Track^.EventQuery;
    Track^.Time:=0;
   end;
{$ifdef VSTi}
   DifferenceTicks:=Remain;
{$else}
   DifferenceTicks:=1;
{$endif}
  end;
{$ifdef VSTi}
  SamplesRemainAdd:=int64(DifferenceTicks) shl 32;
{$else}                     
  if Track^.IntervalSamples=FracFactor then begin
   SamplesRemainAdd:=int64(DifferenceTicks) shl 32;
  end else begin
   SamplesRemainAdd:=0;
   while true do begin
    SamplesRemainAdd:=Track^.IntervalSamples*DifferenceTicks;
    if (DifferenceTicks>0) and ((SamplesRemainAdd div DifferenceTicks)<>Track^.IntervalSamples) then begin // Check on overflow
     // If an overflow -> try to correct it
     if (DifferenceTicks and (DifferenceTicks-1))=0 then begin
      DifferenceTicks:=DifferenceTicks shr 1;
     end else begin
      dec(DifferenceTicks);
     end;
     continue;
    end;
    break;
   end;
  end;
{$endif}
  inc(Track^.SamplesRemain,SamplesRemainAdd);
  Track^.DifferenceTicksIncrement:=DifferenceTicks;
 end;
 if assigned(Track^.CurrentEvent) then begin
  SamplesRemain:=PInt64(@Track^.SamplesRemain)^.Hi;
  if SamplesRemain>Remain then begin
   SamplesRemain:=Remain;
  end;
 end else begin
  SamplesRemain:=Remain;
 end;
 dec(Track^.SamplesRemain,int64(SamplesRemain) shl 32);
 inc(Track^.ProcessedSamples,SamplesRemain);
 if SamplesRemain>0 then begin
  if Track^.DoAudioProcessing then begin
   FillRemain:=SamplesRemain;
   while FillRemain>0 do begin
    ToFill:=FillRemain;
    if ToFill>FixedWorkBufferSize then begin
     ToFill:=FixedWorkBufferSize;
    end;
    SynthProcessDSP(Track,Sample,ToFill,NewTick);
    NewTick:=false;
    inc(Sample,ToFill);
    dec(FillRemain,ToFill);
   end;
  end else begin
   inc(Sample,SamplesRemain);
  end;
  Track^.GlobalLFOPhase:=frac(Track^.GlobalLFOPhase+(Track^.GlobalLFOPhaseIncrement*SamplesRemain));
 end;
{$ifdef textdebug}
 if not Track^.DebugWait then begin
  inc(Track^.TimeDebug,SamplesRemain);
 end;
{$endif}
 result:=SamplesRemain;
end;

procedure SynthProcessTrack(Track:PSynthTrack;DestBuffer:PSynthBufferSample;BufferSamples:longint);
var Counter,SamplesRemain,Count{$ifdef MultiOutput},Index{$endif}:longint;
    Sample:PSynthBufferSample;
    Channel:PSynthChannel;
begin
 if assigned(Track) and (BufferSamples>0) then begin
{$ifndef VSTi}
  if Track^.ScanPeaks then begin
   Track^.ScanPeakFactor:=1.0-exp(-1.0/Track^.BaseBufferSamples);
  end;
{$endif}
  Sample:=DestBuffer;
  SamplesRemain:=BufferSamples;
{$ifdef MultiOutput}
  Index:=0;
{$endif}
  while SamplesRemain>0 do begin
   Count:=SynthProcessPart(Track,Sample,SamplesRemain);
{$ifdef MultiOutput}
   for Counter:=0 to NumberOfChannels-1 do begin
    if Track^.Channels[Counter].HasBuffer then begin
     Move(Track^.WorkBuffers^.ChannelOutRouteBuffer[Counter],PSynthBufferSamples(Track^.ChannelBuffer[Counter])^[Index],Count*sizeof(TSynthBufferSample));
    end else begin                          
     FillChar(PSynthBufferSamples(Track^.ChannelBuffer[Counter])^[Index],Count*sizeof(TSynthBufferSample),#0);
    end;
   end;
   inc(Index,Count);
{$endif}
   dec(SamplesRemain,Count);
  end;
  if Track^.ScanPeaks then begin
   for Counter:=0 to NumberOfChannels-1 do begin
    Channel:=@Track^.Channels[Counter];
    Channel^.OutPeaks.Left:=Channel^.Peaks.Left;
    Channel^.OutPeaks.Right:=Channel^.Peaks.Right;
   end;
  end else begin
   for Counter:=0 to NumberOfChannels-1 do begin
    Channel:=@Track^.Channels[Counter];
    Channel^.OutPeaks.Left:=0;
    Channel^.OutPeaks.Right:=0;
   end;
  end;
 end;
end;

procedure SynthProcessTrackSampleInstance(TrackSampleInstance:PSynthTrackSampleInstance;DestBuffer:PSynthBufferSample;BufferSamples:longint);
{$ifndef BR808EXEMUSPLAYER}
var SubArray:PSynthSINCSubArray;
    RealPos:longword;
    vl,vr,cf,vlf,vrf:single;
    i,j,k:longint;
    bs:PSynthBufferSample;
    pinc:int64;
 function GetSampleLength(CountSamplesValue:longint):longint;
 var SmpLen,SmpLoopStart,SmpLoopEnd,CountSamples,MaxSamples,Difference:int64;
     LoopMode:longint;
 begin
  SmpLen:=TrackSampleInstance^.Parent^.Samples*i32;
  if (TrackSampleInstance^.Parent^.SustainLoop.Mode<>slNONE) and not TrackSampleInstance^.KeyOff then begin
   LoopMode:=TrackSampleInstance^.Parent^.SustainLoop.Mode;
   SmpLoopStart:=TrackSampleInstance^.Parent^.SustainLoop.StartSample*i32;
   SmpLoopEnd:=TrackSampleInstance^.Parent^.SustainLoop.EndSample*i32;
  end else if TrackSampleInstance^.Parent^.Loop.Mode<>slNONE then begin
   LoopMode:=TrackSampleInstance^.Parent^.Loop.Mode;
   SmpLoopStart:=TrackSampleInstance^.Parent^.Loop.StartSample*i32;
   SmpLoopEnd:=TrackSampleInstance^.Parent^.Loop.EndSample*i32;
  end else begin
   LoopMode:=slNONE;
   SmpLoopStart:=0;
   SmpLoopEnd:=SmpLen;
  end;
  if LoopMode<>slNONE then begin
   if TrackSampleInstance^.Position<SmpLoopStart then begin
    if TrackSampleInstance^.Backwards then begin
     if LoopMode=slPINGPONG then begin
      TrackSampleInstance^.Position:=SmpLoopStart-(SmpLoopStart-TrackSampleInstance^.Position);
      TrackSampleInstance^.Backwards:=false;
      if (TrackSampleInstance^.Position<SmpLoopStart) or (TrackSampleInstance^.Position>=((SmpLoopStart+SmpLoopEnd) div 2)) then begin
       TrackSampleInstance^.Position:=SmpLoopStart;
      end;
     end else if LoopMode=slBACKWARD then begin
      TrackSampleInstance^.Position:=SmpLen-(SmpLoopStart-TrackSampleInstance^.Position);
      if TrackSampleInstance^.Position>=SmpLoopEnd then begin
       TrackSampleInstance^.Position:=TrackSampleInstance^.Position+(SmpLoopStart-SmpLoopEnd);
       if TrackSampleInstance^.Position<SmpLoopStart then begin
        TrackSampleInstance^.Position:=SmpLoopStart;
       end;
      end;
     end else begin
      TrackSampleInstance^.Position:=SmpLoopEnd-(SmpLoopStart-TrackSampleInstance^.Position);
      TrackSampleInstance^.Backwards:=false;
      if TrackSampleInstance^.Position>=SmpLoopEnd then begin
       TrackSampleInstance^.Position:=TrackSampleInstance^.Position+(SmpLoopStart-SmpLoopEnd);
       if TrackSampleInstance^.Position<SmpLoopStart then begin
        TrackSampleInstance^.Position:=SmpLoopStart;
       end;
      end;
     end;
    end else begin
     if TrackSampleInstance^.Position<0 then begin
      TrackSampleInstance^.Position:=0;
     end;
    end;
   end else if TrackSampleInstance^.Position>=SmpLoopEnd then begin
    if LoopMode=slBACKWARD then begin
     TrackSampleInstance^.Backwards:=true;
    end else if LoopMode=slPINGPONG then begin
     TrackSampleInstance^.Position:=SmpLoopEnd-(TrackSampleInstance^.Position-SmpLoopEnd);
     TrackSampleInstance^.Backwards:=true;
     if (TrackSampleInstance^.Position<SmpLoopStart) or (TrackSampleInstance^.Position>=((SmpLoopStart+SmpLoopEnd) div 2)) then begin
      TrackSampleInstance^.Position:=SmpLoopStart;
     end;
    end else begin
     TrackSampleInstance^.Position:=TrackSampleInstance^.Position+(SmpLoopStart-SmpLoopEnd);
     if TrackSampleInstance^.Position<SmpLoopStart then begin
      TrackSampleInstance^.Position:=SmpLoopStart;
     end;
    end;
   end;
  end;
  if (TrackSampleInstance^.Position<0) OR (TrackSampleInstance^.Position>=SmpLen) OR
     ((TrackSampleInstance^.Position<SmpLoopStart) AND
      ((TrackSampleInstance^.Position<0) OR TrackSampleInstance^.Backwards)) then begin
   result:=0;
   exit;
  end;
  CountSamples:=CountSamplesValue;
  MaxSamples:=PositionAllRemainFactor div ((TrackSampleInstance^.Increment div PositionFactor)+1);
  if MaxSamples<2 then MaxSamples:=2;
  if CountSamplesValue>MaxSamples then CountSamplesValue:=MaxSamples;
  if TrackSampleInstance^.Backwards then begin
   Difference:=(TrackSampleInstance^.Position-(TrackSampleInstance^.Increment*(CountSamplesValue-1)));
   if Difference<SmpLoopStart then begin
    CountSamples:=((TrackSampleInstance^.Position-SmpLoopStart-1) div TrackSampleInstance^.Increment)+1;
   end;
  end else begin
   Difference:=(TrackSampleInstance^.Position+(TrackSampleInstance^.Increment*(CountSamplesValue-1)));
   if Difference>=SmpLoopEnd then begin
    CountSamples:=((SmpLoopEnd-TrackSampleInstance^.Position-1) div TrackSampleInstance^.Increment)+1;
   end;
  end;
  if CountSamples<=1 then begin
   result:=1;
   exit;
  end else if CountSamples>CountSamplesValue then begin
   result:=CountSamplesValue;
   exit;
  end;
  result:=CountSamples;
 end;
begin
 if (TrackSampleInstance^.Increment=0) or not TrackSampleInstance^.Active then exit;
 vl:=0;
 vr:=0;
 bs:=DestBuffer;
 i:=BufferSamples;
 while i>0 do begin
  j:=i;
  if (TrackSampleInstance^.VolumeRampingRemain>0) and (TrackSampleInstance^.VolumeRampingRemain<j) then begin
   j:=TrackSampleInstance^.VolumeRampingRemain;
  end;
  j:=GetSampleLength(j);
  if j=0 then begin
   TrackSampleInstance^.Active:=false;
   if (abs(vl)<FixDenormalValue) and (abs(vr)<FixDenormalValue) then begin
    vl:=0;
    vr:=0;
   end else begin
    cf:=TrackSampleInstance^.Parent^.Parent^.BaseClickRemovalFactor;
    while i>0 do begin
     vl:=vl*cf;
     vr:=vr*cf;
     longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     bs^.Left:=bs^.Left+vl;
     bs^.Right:=bs^.Right+vr;
     longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(bs);
     dec(i);
    end;
   end;
   TrackSampleInstance^.Parent^.LastLeft:=TrackSampleInstance^.Parent^.LastLeft+vl;
   TrackSampleInstance^.Parent^.LastRight:=TrackSampleInstance^.Parent^.LastRight+vr;
   TrackSampleInstance^.LastLeft:=0;
   TrackSampleInstance^.LastRight:=0;
   break;
  end;
  if TrackSampleInstance^.Backwards then begin
   pinc:=-TrackSampleInstance^.Increment;
  end else begin
   pinc:=TrackSampleInstance^.Increment;
  end;
  if TrackSampleInstance^.Increment=i32 then begin
   if TrackSampleInstance^.VolumeRampingRemain>0 then begin
    for k:=1 to j do begin
     TrackSampleInstance^.VolumeLeft:=TrackSampleInstance^.VolumeLeft+TrackSampleInstance^.VolumeRampingLeft;
     TrackSampleInstance^.VolumeRight:=TrackSampleInstance^.VolumeRight+TrackSampleInstance^.VolumeRampingRight;
     dec(TrackSampleInstance^.VolumeRampingRemain);
     RealPos:=(TrackSampleInstance^.Position shr PositionShift)+SampleFixUp;
     vl:=PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Left;
     vr:=PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Right;
     vl:=vl*TrackSampleInstance^.VolumeLeft;
     vr:=vr*TrackSampleInstance^.VolumeRight;
     longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     bs^.Left:=bs^.Left+vl;
     bs^.Right:=bs^.Right+vr;
     longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(TrackSampleInstance^.Position,pinc);
     inc(bs);
    end;
    if TrackSampleInstance^.VolumeRampingRemain<=0 then begin
     TrackSampleInstance^.VolumeLeft:=TrackSampleInstance^.DestVolumeLeft;
     TrackSampleInstance^.VolumeRight:=TrackSampleInstance^.DestVolumeRight;
    end;
   end else begin
    vlf:=TrackSampleInstance^.VolumeLeft;
    vrf:=TrackSampleInstance^.VolumeRight;
    if (vlf=0) and (vrf=0) then begin
     inc(TrackSampleInstance^.Position,pinc*j);
     inc(bs,j);
    end else begin
     for k:=1 to j do begin
      RealPos:=(TrackSampleInstance^.Position shr PositionShift)+SampleFixUp;
      vl:=PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Left;
      vr:=PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Right;
      vl:=vl*vlf;
      vr:=vr*vrf;
      longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      bs^.Left:=bs^.Left+vl;
      bs^.Right:=bs^.Right+vr;
      longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(TrackSampleInstance^.Position,pinc);
      inc(bs);
     end;
    end;
   end;
  end else begin
   if TrackSampleInstance^.VolumeRampingRemain>0 then begin
    for k:=1 to j do begin
     TrackSampleInstance^.VolumeLeft:=TrackSampleInstance^.VolumeLeft+TrackSampleInstance^.VolumeRampingLeft;
     TrackSampleInstance^.VolumeRight:=TrackSampleInstance^.VolumeRight+TrackSampleInstance^.VolumeRampingRight;
     dec(TrackSampleInstance^.VolumeRampingRemain);
     RealPos:=(TrackSampleInstance^.Position shr PositionShift)+SampleFixUp;
     SubArray:=@TrackSampleInstance^.Parent^.Parent^.SINCTable[(longword(TrackSampleInstance^.Position and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
     vl:=(SubArray^[0]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-7].Left+
          SubArray^[1]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-6].Left+
          SubArray^[2]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-5].Left+
          SubArray^[3]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-4].Left+
          SubArray^[4]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-3].Left+
          SubArray^[5]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-2].Left+
          SubArray^[6]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-1].Left+
          SubArray^[7]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Left+
          SubArray^[8]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+1].Left+
          SubArray^[9]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+2].Left+
          SubArray^[10]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+3].Left+
          SubArray^[11]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+4].Left+
          SubArray^[12]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+5].Left+
          SubArray^[13]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+6].Left+
          SubArray^[14]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+7].Left+
          SubArray^[15]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+8].Left);
     vr:=(SubArray^[0]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-7].Right+
          SubArray^[1]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-6].Right+
          SubArray^[2]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-5].Right+
          SubArray^[3]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-4].Right+
          SubArray^[4]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-3].Right+
          SubArray^[5]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-2].Right+
          SubArray^[6]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-1].Right+
          SubArray^[7]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Right+
          SubArray^[8]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+1].Right+
          SubArray^[9]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+2].Right+
          SubArray^[10]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+3].Right+
          SubArray^[11]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+4].Right+
          SubArray^[12]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+5].Right+
          SubArray^[13]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+6].Right+
          SubArray^[14]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+7].Right+
          SubArray^[15]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+8].Right);
     vl:=vl*TrackSampleInstance^.VolumeLeft;
     vr:=vr*TrackSampleInstance^.VolumeRight;
     longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     bs^.Left:=bs^.Left+vl;
     bs^.Right:=bs^.Right+vr;
     longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
     inc(TrackSampleInstance^.Position,pinc);
     inc(bs);
    end;
    if TrackSampleInstance^.VolumeRampingRemain<=0 then begin
     TrackSampleInstance^.VolumeLeft:=TrackSampleInstance^.DestVolumeLeft;
     TrackSampleInstance^.VolumeRight:=TrackSampleInstance^.DestVolumeRight;
    end;
   end else begin
    vlf:=TrackSampleInstance^.VolumeLeft;
    vrf:=TrackSampleInstance^.VolumeRight;
    if (vlf=0) and (vrf=0) then begin
     inc(TrackSampleInstance^.Position,pinc*j);
     inc(bs,j);
    end else begin
     for k:=1 to j do begin
      RealPos:=(TrackSampleInstance^.Position shr PositionShift)+SampleFixUp;
      SubArray:=@TrackSampleInstance^.Parent^.Parent^.SINCTable[(longword(TrackSampleInstance^.Position and PositionMask) shr SINC16_FRACSHIFT) and SINC16_FRACMASK];
      vl:=(SubArray^[0]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-7].Left+
           SubArray^[1]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-6].Left+
           SubArray^[2]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-5].Left+
           SubArray^[3]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-4].Left+
           SubArray^[4]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-3].Left+
           SubArray^[5]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-2].Left+
           SubArray^[6]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-1].Left+
           SubArray^[7]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Left+
           SubArray^[8]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+1].Left+
           SubArray^[9]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+2].Left+
           SubArray^[10]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+3].Left+
           SubArray^[11]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+4].Left+
           SubArray^[12]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+5].Left+
           SubArray^[13]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+6].Left+
           SubArray^[14]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+7].Left+
           SubArray^[15]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+8].Left);
      vr:=(SubArray^[0]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-7].Right+
           SubArray^[1]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-6].Right+
           SubArray^[2]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-5].Right+
           SubArray^[3]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-4].Right+
           SubArray^[4]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-3].Right+
           SubArray^[5]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-2].Right+
           SubArray^[6]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos-1].Right+
           SubArray^[7]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos].Right+
           SubArray^[8]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+1].Right+
           SubArray^[9]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+2].Right+
           SubArray^[10]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+3].Right+
           SubArray^[11]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+4].Right+
           SubArray^[12]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+5].Right+
           SubArray^[13]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+6].Right+
           SubArray^[14]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+7].Right+
           SubArray^[15]*PSynthBufferSamples(TrackSampleInstance^.Parent^.Data)^[RealPos+8].Right);
      vl:=vl*vlf;
      vr:=vr*vrf;
      longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      bs^.Left:=bs^.Left+vl;
      bs^.Right:=bs^.Right+vr;
      longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
      inc(TrackSampleInstance^.Position,pinc);
      inc(bs);
     end;
    end;
   end;
  end;
  TrackSampleInstance^.LastLeft:=vl;
  TrackSampleInstance^.LastRight:=vr;
  dec(i,j);
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthProcessTrackSampleInstances(TrackSample:PSynthTrackSample;DestBuffer:PSynthBufferSample;BufferSamples:longint);
{$ifndef BR808EXEMUSPLAYER}
var CurrentTrackSampleInstance:PSynthTrackSampleInstance;
begin
 CurrentTrackSampleInstance:=TrackSample^.TrackSampleInstanceRoot;
 while assigned(CurrentTrackSampleInstance) do begin
  SynthProcessTrackSampleInstance(CurrentTrackSampleInstance,DestBuffer,BufferSamples);
  CurrentTrackSampleInstance:=CurrentTrackSampleInstance^.Next;
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthProcessTrackSample(TrackSample:PSynthTrackSample;DestBuffer:PSynthBufferSample;BufferSamples:longint);
{$ifndef BR808EXEMUSPLAYER}
var bs:PSynthBufferSample;
    i:longint;
    vl,vr,cf:single;
begin
 vl:=TrackSample^.LastLeft;
 vr:=TrackSample^.LastRight;
 longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
 if (vl<>0) or (vr<>0) then begin
  cf:=TrackSample^.Parent^.BaseClickRemovalFactor;
  bs:=DestBuffer;
  i:=BufferSamples;
  while i>0 do begin
   vl:=vl*cf;
   vr:=vr*cf;
   longword(pointer(@vl)^):=longword(pointer(@vl)^) and longword($ffffffff+longword(((((longword(pointer(@vl)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@vr)^):=longword(pointer(@vr)^) and longword($ffffffff+longword(((((longword(pointer(@vr)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   bs^.Left:=bs^.Left+vl;
   bs^.Right:=bs^.Right+vr;
   longword(pointer(@bs^.Left)^):=longword(pointer(@bs^.Left)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Left)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   longword(pointer(@bs^.Right)^):=longword(pointer(@bs^.Right)^) and longword($ffffffff+longword(((((longword(pointer(@bs^.Right)^) and $7f800000)+$800000) and $7f800000)-$1000000) shr 31));
   inc(bs);
   dec(i);
  end;
 end;
 TrackSample^.LastLeft:=vl;
 TrackSample^.LastRight:=vr;
 SynthProcessTrackSampleInstances(TrackSample,DestBuffer,BufferSamples);
end;
{$else}
begin
end;
{$endif}

procedure SynthProcessTrackSamples(Track:PSynthTrack;DestBuffer:PSynthBufferSample;BufferSamples:longint);
{$ifndef BR808EXEMUSPLAYER}
var CurrentTrackSample:PSynthTrackSample;
begin
 CurrentTrackSample:=Track^.TrackSampleRoot;
 while assigned(CurrentTrackSample) do begin
  SynthProcessTrackSample(CurrentTrackSample,DestBuffer,BufferSamples);
  CurrentTrackSample:=CurrentTrackSample^.Next;
 end;
end;
{$else}
begin
end;
{$endif}

procedure SynthResetEventQuery(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthResetEventQuery@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
{$ifdef textdebug}
 Track^.TimeDebug:=0;
 Track^.DebugWait:=true;
{$endif}
 Track^.Time:=0;
 Track^.SamplesRemain:=0;
 Track^.CurrentEvent:=Track^.EventQuery;
 Track^.DifferenceTicksIncrement:=0;
end;

procedure SynthDownsample(Track:PSynthTrack;Buffer:PSynthBufferSample;Samples,Which:longint);
var InBuf,OutBuf:PSynthBufferSample;
    Counter,SubCounter,Index,Mask,Points,Count,PeekIndex,Len:longint;
    RingBuf:PSynthBufferSamples;
    SINCLUT:PSingles;
    Value:TSynthBufferSample;
begin
 if Track^.Oversampling>0 then begin
  InBuf:=Buffer;
  OutBuf:=Buffer;
  RingBuf:=Track^.DownsampleSINCRingBuffer[Which];
  SINCLUT:=Track^.DownsampleSINC;
  Points:=Track^.DownsampleSINCPoints;
  Count:=Track^.OversamplingFactor;
  Len:=Track^.DownsampleSINCRingBufferLen;
  Index:=Track^.DownsampleSINCRingBufferIndex[Which];
  if (Len<>0) and ((Len and (Len-1))<>0) then begin
   while Index<0 do begin
    inc(Index,Len);
   end;
   while Index>=Len do begin
    dec(Index,Len);
   end;
   for Counter:=1 to Samples do begin
    for SubCounter:=0 to Count-1 do begin
     RingBuf^[Index]:=InBuf^;
     inc(Index);
     while Index<0 do begin
      inc(Index,Len);
     end;
     while Index>=Len do begin
      dec(Index,Len);
     end;
     inc(InBuf);
    end;
    Value.Left:=0;
    Value.Right:=0;
    for SubCounter:=0 to Points-1 do begin
     PeekIndex:=(Index-Points)+SubCounter;
     while PeekIndex<0 do begin
      inc(PeekIndex,Len);
     end;
     while PeekIndex>=Len do begin
      dec(PeekIndex,Len);
     end;
     Value.Left:=Value.Left+(SINCLUT^[SubCounter]*RingBuf[PeekIndex].Left);
     Value.Right:=Value.Right+(SINCLUT^[SubCounter]*RingBuf[PeekIndex].Right);
    end;
    OutBuf^:=Value;
    inc(OutBuf);
   end;
  end else begin
   Mask:=Track^.DownsampleSINCRingBufferMask;
   Index:=Index and Mask;
   for Counter:=1 to Samples do begin
    for SubCounter:=0 to Count-1 do begin
     RingBuf^[Index]:=InBuf^;
     Index:=(Index+1) and Mask;
     inc(InBuf);
    end;
    Value.Left:=0;
    Value.Right:=0;
    for SubCounter:=0 to Points-1 do begin
     PeekIndex:=((Index-Points)+SubCounter) and Mask;
     Value.Left:=Value.Left+(SINCLUT^[SubCounter]*RingBuf[PeekIndex].Left);
     Value.Right:=Value.Right+(SINCLUT^[SubCounter]*RingBuf[PeekIndex].Right);
    end;
    OutBuf^:=Value;
    inc(OutBuf);
   end;
  end;
  Track^.DownsampleSINCRingBufferIndex[Which]:=Index;
 end;
end;

procedure SynthOversample(Track:PSynthTrack;Buffer:PSynthBufferSample;Samples,Which:longint);
var InBuf,OutBuf:PSynthBufferSample;
    Counter:longint;
begin
 if Track^.Oversampling>0 then begin
  if Track^.FineOversampling then begin
   if Track^.FineSincOversampling then begin
    SynthDownsample(Track,Buffer,Samples,Which);
   end else begin
    InBuf:=Buffer;
    OutBuf:=Buffer;
    for Counter:=1 to Samples do begin
     OutBuf^.Left:=SynthOversamplerProcessDown(Track^.Oversamplers[Which,0],InBuf,0);
     OutBuf^.Right:=SynthOversamplerProcessDown(Track^.Oversamplers[Which,1],InBuf,1);
     inc(InBuf,Track^.OversamplingFactor);
     inc(OutBuf);
    end;
   end;
  end else begin
   InBuf:=Buffer;
   for Counter:=1 to Samples do begin
    InBuf^.Left:=SynthOversamplerProcess(Track^.Oversamplers[Which,0],InBuf^.Left)*Track^.OversamplingFactor;
    InBuf^.Right:=SynthOversamplerProcess(Track^.Oversamplers[Which,1],InBuf^.Right)*Track^.OversamplingFactor;
    inc(InBuf);
   end;
  end;
 end;
end;

procedure SynthFillBuffer(Track:PSynthTrack;Samples:longint{$ifdef vsti};InputBuffer:PSynthBufferSample{$endif}); {$ifdef csdk}stdcall; [public,alias:'_SynthFillBuffer@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var SamplingSamples{$ifdef MultiOutput},Counter{$endif}{$ifdef VSTi},RemainSamples,ToDo{$endif}:longint;
{$ifdef VSTi}
    Buffer:PSynthBufferSample;
{$endif}
{$ifdef cpu386}
    OldFCW:word;
{$endif}
{$ifdef UseSSE}
    OldSIMDCtrl:longword;
{$endif}
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   stmxcsr dword ptr OldSIMDCtrl
  end;
  SIMDSetFlags;
 end;
{$endif}
{$ifdef VSTi}
 Track^.Time:=0;
 Track^.SamplesRemain:=0;
 Track^.CurrentEvent:=Track^.EventQuery;
 Track^.DifferenceTicksIncrement:=0;//1;
{$endif}
 if Samples>Track^.BaseBufferSamples then begin
  Samples:=Track^.BaseBufferSamples;
 end;
 Track^.Oversampling:=Track^.Global.Oversample;
 Track^.FineOversampling:=Track^.Global.FineOversample;
 Track^.FineSincOversampling:=Track^.Global.FineSincOversample;
 Track^.OversamplingOrder:=Track^.Global.OversampleOrder;
 SynthReinitOversample(Track);
 SamplingSamples:=Samples*Track^.InternalSamplingFactor;
 if Track^.DoAudioProcessing then begin
  FillChar(Track^.Buffer^,SamplingSamples*sizeof(TSynthBufferSample),#0);
 end;
 if assigned(Track^.BufferStartHook) then begin
  Track^.BufferStartHook(Track);
 end;
 SynthProcessTrack(Track,Track^.Buffer,SamplingSamples);
 if Track^.DoAudioProcessing then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthSampleBufferMulFloatSSE(Track^.Buffer,Track^.Volume,SamplingSamples);
  end else{$endif} begin
   SynthSampleBufferMulFloat(Track^.Buffer,Track^.Volume,SamplingSamples);
  end;
  SynthOversample(Track,Track^.Buffer,Samples,-1);
{$ifdef MultiOutput}
  for Counter:=0 to NumberOfChannels-1 do begin
   SynthOversample(Track,Track^.ChannelBuffer[Counter],Samples,Counter);
  end;
{$endif}
  SynthProcessTrackSamples(Track,Track^.Buffer,Samples);
 end;
 if assigned(Track^.BufferEndHook) then begin
  Track^.BufferEndHook(Track);
 end;
{$ifdef VSTi}
 if Track^.DoAudioProcessing then begin
  if assigned(InputBuffer) then begin
{$ifdef UseSSE}
   if SSEExt and Track^.UseSSE then begin
    SynthMixToBufferSSE(InputBuffer,Track^.Buffer,Samples);
   end else{$endif} begin
    SynthMixToBuffer(InputBuffer,Track^.Buffer,Samples);
   end;
  end;
  if Track^.Master then begin
   if Track^.Global.FinalCompressor.Mode<>cmNONE then begin
    Buffer:=Track^.Buffer;
    RemainSamples:=Samples;
    while RemainSamples>0 do begin
     ToDo:=RemainSamples;
     if ToDo>FixedWorkBufferSize then begin
      ToDo:=FixedWorkBufferSize;
     end;
     SynthProcessCompressor(Track,@Track^.Global.FinalCompressor,@Track^.GlobalData.FinalCompressor,Buffer,Buffer,Track^.GlobalData.FinalCompressorBuffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,ToDo,Track^.BaseSampleRate);
     inc(Buffer,ToDo);
     dec(RemainSamples,ToDo);
    end;
   end;
   if Track^.Global.Clipping then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthClipSamplesSSE(Track^.Buffer,Samples);
    end else{$endif} begin
     SynthClipSamples(Track^.Buffer,Samples);
    end;
   end;
   SynthAGC(Track,Track^.Buffer,Samples);
   if Track^.ClipSamples then begin
{$ifdef UseSSE}
    if SSEExt and Track^.UseSSE then begin
     SynthClipSamplesSSE(Track^.Buffer,Samples);
    end else{$endif} begin
     SynthClipSamples(Track^.Buffer,Samples);
    end;
   end;
  end;
 end;
 SynthFreeEventsVSTi(Track,Samples);
{$endif}
{$ifdef UseSSE}
 if SSEExt then begin
  asm
   ldmxcsr dword ptr OldSIMDCtrl
  end;
 end;
{$endif}
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
end;

procedure SynthFloatArray2ShortArray(OrgSrc:PSynthBufferSample;Dst:psmallint;Samples:longint);
var Src:psingle;
    Counter,Value:longint;
begin
 Src:=pointer(OrgSrc);
 for Counter:=1 to Samples*2 do begin
  Value:=round(Src^*32757);
  if Value<-32768 then begin
   Value:=-32768;
  end else if Value>32767 then begin
   Value:=32767;
  end;
  Dst^:=Value;
  inc(Src);
  inc(Dst);
 end;
end;

{$ifndef VSTi}
procedure SynthFillOutputBuffer(Track:PSynthTrack;OutputData:pointer); {$ifdef csdk}stdcall; [public,alias:'_SynthFillOutputBuffer@8'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var CurrentLinkTrack:PSynthTrack;
{$ifdef cpu386}
    OldFCW:word;
{$endif}
    Buffer:PSynthBufferSample;
    RemainSamples,ToDo:longint;
begin
{$ifdef cpu386}
 asm
  fstcw word ptr OldFCW
  fldcw word ptr SynthFCW
 end;
{$endif}
 Track^.DoAudioProcessing:=true;
 SynthFillBuffer(Track,Track^.BaseBufferSamples);
 CurrentLinkTrack:=Track^.LinkRoot;
 while assigned(CurrentLinkTrack) do begin
  SynthFillBuffer(CurrentLinkTrack,Track^.BaseBufferSamples);
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthMixToBufferSSE(CurrentLinkTrack^.Buffer,Track^.Buffer,Track^.BaseBufferSamples);
  end else{$endif} begin
   SynthMixToBuffer(CurrentLinkTrack^.Buffer,Track^.Buffer,Track^.BaseBufferSamples);
  end;
  CurrentLinkTrack:=CurrentLinkTrack^.LinkNext;
 end;
 if Track^.Global.FinalCompressor.Mode<>cmNONE then begin
  Buffer:=Track^.Buffer;
  RemainSamples:=Track^.BaseBufferSamples;
  while RemainSamples>0 do begin
   ToDo:=RemainSamples;
   if ToDo>FixedWorkBufferSize then begin
    ToDo:=FixedWorkBufferSize;
   end;
   SynthProcessCompressor(Track,@Track^.Global.FinalCompressor,@Track^.GlobalData.FinalCompressor,Buffer,Buffer,Track^.GlobalData.FinalCompressorBuffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,Track^.F1D0Buffer,ToDo,Track^.BaseSampleRate);
   inc(Buffer,ToDo);
   dec(RemainSamples,ToDo);
  end;
 end;
 if Track^.Global.Clipping then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthClipSamplesSSE(Track^.Buffer,Track^.BaseBufferSamples);
  end else{$endif} begin
   SynthClipSamples(Track^.Buffer,Track^.BaseBufferSamples);
  end;
 end;
 SynthAGC(Track,Track^.Buffer,Track^.BaseBufferSamples);
 if Track^.ClipSamples then begin
{$ifdef UseSSE}
  if SSEExt and Track^.UseSSE then begin
   SynthClipSamplesSSE(Track^.Buffer,Track^.BaseBufferSamples);
  end else{$endif} begin
   SynthClipSamples(Track^.Buffer,Track^.BaseBufferSamples);
  end;
 end;
 SynthFloatArray2ShortArray(Track^.Buffer,OutputData,Track^.BaseBufferSamples);
{$ifdef cpu386}
 asm
  fldcw word ptr OldFCW
 end;
{$endif}
end;
{$endif}

function SynthSeekToSample(Track:PSynthTrack;DestSample:int64=-1):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthSeekToSample@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var i,SamplesCount:int64;
    CurrentLinkTrack:PSynthTrack;
begin
 result:=0;
 CurrentLinkTrack:=Track^.LinkRoot;
 while assigned(CurrentLinkTrack) do begin
  i:=SynthSeekToSample(CurrentLinkTrack,DestSample);
  if result<i then begin
   result:=i;
  end;
  CurrentLinkTrack:=CurrentLinkTrack^.LinkNext;
 end;
 DestSample:=DestSample*Track^.InternalSamplingFactor;
 Track^.DoAudioProcessing:=false;
 SynthReset(Track);
 while assigned(Track^.CurrentEvent) and
       (((DestSample>=0) and (Track^.ProcessedSamples<DestSample)) or
        (DestSample<0)) do begin
  if DestSample<0 then begin
   SamplesCount:=Track^.InternalBufferSamples;
  end else begin
   SamplesCount:=DestSample-Track^.ProcessedSamples;
   if (SamplesCount<=0) or (SamplesCount>Track^.InternalBufferSamples) then begin
    SamplesCount:=Track^.InternalBufferSamples;
   end;
  end;
  SynthProcessTrack(Track,Track^.Buffer,SamplesCount);
 end;
 i:=Track^.ProcessedSamples div Track^.InternalSamplingFactor;
 if result<i then begin
  result:=i;
 end;
 Track^.DoAudioProcessing:=true;
 if DestSample<0 then begin
  SynthReset(Track);
 end else begin
  SynthResetVoices(Track);
 end;
end;

function SynthSeekToMS(Track:PSynthTrack;DestMS:int64=-1):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthSeekToMS@12'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 if Track^.InternalSampleRate=0 then begin
  result:=0;
 end else begin
  if DestMS<0 then begin
   result:=SynthSeekToSample(Track,-1);
  end else begin
   result:=SynthSeekToSample(Track,(int64(DestMS)*Track^.InternalSampleRate) div 1000);
  end;
  result:=(int64(result)*1000) div Track^.InternalSampleRate;
 end;
end;

function SynthTimePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthTimePosition@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=(Track^.ProcessedSamples*1000) div Track^.InternalSampleRate;
end;

function SynthSamplePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthSamplePosition@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 result:=Track^.ProcessedSamples;
end;

{$ifdef WIN32Plain}
function SynthGetTimePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthGetTimePosition@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var MMTime:TMMTime;
begin
 if not Track^.SoundOutput then begin
  result:=SynthTimePosition(Track);
  exit;
 end;
 if Track^.IsSampleAccurate then begin
  MMTime.wType:=TIME_SAMPLES;
  if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
     (MMTime.wType=TIME_SAMPLES) then begin
   if MMTime.sample<Track^.LastGetPositionSample then begin
    if Track^.LastGetPositionSample<=$7ffffff then begin
     inc(Track^.AddGetPositionSample,$7ffffff);
    end else begin
     inc(Track^.AddGetPositionSample,Track^.LastGetPositionSample);
     if MMTime.sample<=longword(Track^.BaseBufferSamples) then begin
      inc(Track^.AddGetPositionSample,Track^.BaseBufferSamples);
      dec(Track^.AddGetPositionSample,MMTime.sample);
     end;
    end;
   end;
   Track^.LastGetPositionSample:=MMTime.sample;
   result:=(int64(MMTime.sample+Track^.AddGetPositionSample+Track^.FirstBufferSample)*1000) div Track^.WaveFormat.nSamplesPerSec;
   exit;
  end;
 end;

 MMTime.wType:=TIME_MS;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_MS) then begin
  result:=MMTime.ms+((int64(Track^.FirstBufferSample)*1000) div Track^.WaveFormat.nSamplesPerSec);
  exit;
 end;

 MMTime.wType:=TIME_BYTES;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_BYTES) then begin
  result:=(int64((MMTime.cb div Track^.WaveFormat.nBlockAlign)+Track^.FirstBufferSample)*1000) div Track^.WaveFormat.nSamplesPerSec;
  exit;
 end;

 MMTime.wType:=TIME_SMPTE;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_SMPTE) and (MMTime.FPS<>0) then begin
  result:=(int64((MMTime.hour*60)+MMTime.min*60)+MMTime.sec*1000)+((MMTime.Frame*1000) div MMTime.FPS)+((Track^.FirstBufferSample*1000) div Track^.WaveFormat.nSamplesPerSec);
  exit;
 end;

 result:=(timeGetTime-Track^.FirstBufferTime)+((int64(Track^.FirstBufferSample)*1000) div Track^.WaveFormat.nSamplesPerSec);
end;

{$WARNINGS OFF}
function SynthGetSamplePosition(Track:PSynthTrack):int64; {$ifdef csdk}stdcall; [public,alias:'_SynthGetSamplePosition@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
var MMTime:TMMTime;
begin
 if not Track^.SoundOutput then begin
  result:=SynthSamplePosition(Track);
  exit;
 end;
 if Track^.IsSampleAccurate then begin
  MMTime.wType:=TIME_SAMPLES;
  if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
     (MMTime.wType=TIME_SAMPLES) then begin
   if MMTime.sample<Track^.LastGetPositionSample then begin
    if Track^.LastGetPositionSample<=$7ffffff then begin
     inc(Track^.AddGetPositionSample,$7ffffff);
    end else begin
     inc(Track^.AddGetPositionSample,Track^.LastGetPositionSample);
     if MMTime.sample<=longword(Track^.BaseBufferSamples) then begin
      inc(Track^.AddGetPositionSample,Track^.BaseBufferSamples);
      dec(Track^.AddGetPositionSample,MMTime.sample);
     end;
    end;
   end;
   Track^.LastGetPositionSample:=MMTime.sample;
   result:=MMTime.sample+Track^.AddGetPositionSample+Track^.FirstBufferSample;
   exit;
  end;
 end;

 MMTime.wType:=TIME_MS;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_MS) then begin
  result:=((int64(MMTime.ms)*Track^.WaveFormat.nSamplesPerSec) div 1000)+Track^.FirstBufferSample;
  exit;
 end;

 MMTime.wType:=TIME_BYTES;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_BYTES) then begin
  result:=(MMTime.cb div Track^.WaveFormat.nBlockAlign)+Track^.FirstBufferSample;
  exit;
 end;

 MMTime.wType:=TIME_SMPTE;
 if (WaveOutGetPosition(Track^.WaveOutHandle,@MMTime,sizeof(TMMTime))=MMSYSERR_NOERROR) and
    (MMTime.wType=TIME_SMPTE) and (MMTime.FPS<>0) then begin
  result:=(int64((((MMTime.hour*60)+MMTime.min*60)+MMTime.sec*1000)+((MMTime.Frame*1000) div MMTime.FPS)*Track^.WaveFormat.nSamplesPerSec) div 1000)+Track^.FirstBufferSample;
  exit;
 end;

 result:=(int64((timeGetTime-Track^.FirstBufferTime)*Track^.WaveFormat.nSamplesPerSec) div 1000)+Track^.FirstBufferSample;
end;
{$WARNINGS ON}

procedure SynthPoll(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthPoll@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 if Track^.SoundOutput then begin
  if (Track^.WaveHandler[Track^.BufferCounter].dwFlags and WHDR_DONE)<>0 then begin
   if waveOutUnprepareHeader(Track^.WaveOutHandle,Track^.WaveHandler[Track^.BufferCounter],sizeof(TWAVEHDR))<>WAVERR_STILLPLAYING then begin
    if Track^.FirstBuffer then begin
     Track^.FirstBufferSample:=Track^.ProcessedSamples;
    end;
    Track^.WaveHandler[Track^.BufferCounter].dwFlags:=Track^.WaveHandler[Track^.BufferCounter].dwFlags and not WHDR_DONE;
    SynthFillOutputBuffer(Track,Track^.WaveHandler[Track^.BufferCounter].lpData);
    waveOutPrepareHeader(Track^.WaveOutHandle,Track^.WaveHandler[Track^.BufferCounter],sizeof(TWAVEHDR));
    waveOutWrite(Track^.WaveOutHandle,Track^.WaveHandler[Track^.BufferCounter],sizeof(TWAVEHDR));
    Track^.BufferCounter:=(Track^.BufferCounter+1) mod 4;
    if Track^.FirstBuffer then begin
     Track^.FirstBufferTime:=timeGetTime;
     Track^.FirstBuffer:=false;
    end;
   end;
  end;
 end;
end;

{$ifdef WIN32ReallyPlain}
procedure SynthThread(Track:PSynthTrack); stdcall;
{$else}
function SynthThread(Track:PSynthTrack):longint;
{$endif}
begin
 while not Track^.ThreadTerminated do begin
  InterlockedExchange(longint(longbool(Track^.ThreadIsWorking)),longint(longbool(true)));
  begin
   EnterCriticalSection(Track^.ThreadCriticalSection);
   if Track^.Active then begin
    SynthPoll(Track);
   end;
   LeaveCriticalSection(Track^.ThreadCriticalSection);
  end;
  InterlockedExchange(longint(longbool(Track^.ThreadIsWorking)),longint(longbool(false)));
  while (not Track^.Active) and not Track^.ThreadTerminated do begin
   Sleep(10);
  end;
  Sleep(10);
 end;
{$ifdef WIN32ReallyPlain}
 ExitThread(0);
{$else}
 EndThread(0);
 result:=0;
{$endif}
end;

procedure SynthCreateThread(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthCreateThread@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 InterlockedExchange(longint(longbool(Track^.ThreadTerminated)),longint(longbool(false)));
 InitializeCriticalSection(Track^.ThreadCriticalSection);
 if Track^.ThreadPlay then begin
{$ifdef WIN32ReallyPlain}
  Track^.ThreadHandle:=CreateThread(nil,0,@SynthThread,Track,CREATE_SUSPENDED,Track^.ThreadID);
{$else}
  Track^.ThreadHandle:=BeginThread(nil,0,@SynthThread,Track,CREATE_SUSPENDED,Track^.ThreadID);
{$endif}
  SetThreadPriority(Track^.ThreadHandle,THREAD_PRIORITY_TIME_CRITICAL);
 end else begin
  Track^.ThreadHandle:=0;
 end;
end;

procedure SynthExitThread(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthExitThread@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 InterlockedExchange(longint(longbool(Track^.ThreadTerminated)),longint(longbool(true)));
 if Track^.ThreadPlay then begin
  WaitForSingleObject(Track^.ThreadHandle,25);
  TerminateThread(Track^.ThreadHandle,0);
  WaitForSingleObject(Track^.ThreadHandle,5000);
  if Track^.ThreadHandle<>0 then begin
   CloseHandle(Track^.ThreadHandle);
  end;
 end;
 DeleteCriticalSection(Track^.ThreadCriticalSection);
end;

procedure SynthPlay(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthPlay@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 if not Track^.Played then begin
  Track^.Played:=true;
  Track^.DoAudioProcessing:=true;
  if Track^.ThreadPlay then begin
   ResumeThread(Track^.ThreadHandle);
  end;
  InterlockedExchange(longint(longbool(Track^.Active)),longint(longbool(true)));
 end;
end;

procedure SynthStop(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthStop@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 if Track^.Played then begin
  InterlockedExchange(longint(longbool(Track^.Active)),longint(longbool(false)));
  Track^.Played:=false;
  if Track^.ThreadPlay then begin
   while Track^.ThreadIsWorking do begin
{$ifdef win32}
    sleep(10);
{$endif}
   end;
   SuspendThread(Track^.ThreadHandle);
  end;
 end;
end;

procedure SynthEnter(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthEnter@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 EnterCriticalSection(Track^.ThreadCriticalSection);
end;

procedure SynthLeave(Track:PSynthTrack); {$ifdef csdk}stdcall; [public,alias:'_SynthLeave@4'];{$else}{$ifdef cpu386}register;{$endif}{$endif}
begin
 LeaveCriticalSection(Track^.ThreadCriticalSection);
end;
{$endif}

initialization
 CheckCPU;
end.







